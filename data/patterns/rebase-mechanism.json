{
  "id": "rebase-mechanism",
  "name": "Rebase Mechanism",
  "category": "Token Economics",
  "description": "Adjust all token balances proportionally to maintain target price. Elastic supply.",
  "when_to_use": "Algorithmic stablecoins, price-stable tokens, elastic supply models",
  "benefits": "Maintains target price, non-dilutive (proportional to all), algorithmic",
  "drawbacks": "Confusing UX (balance changes), tax implications, wallet compatibility",
  "use_cases": "Ampleforth (AMPL), elastic supply tokens, algorithmic pegs",
  "complexity": "High",
  "tags": [
    "tokenomics",
    "rebase",
    "elastic-supply",
    "algorithmic",
    "stablecoin"
  ],
  "examples": {
    "solidity": {
      "language": "solidity",
      "code": "contract RebaseToken {\n    uint256 private _totalGons;\n    uint256 private _gonsPerFragment;\n    \n    function rebase(int256 supplyDelta) external onlyOracle {\n        if (supplyDelta == 0) return;\n        \n        uint256 newTotalSupply = uint256(int256(_totalSupply) + supplyDelta);\n        _gonsPerFragment = _totalGons / newTotalSupply;\n        _totalSupply = newTotalSupply;\n        \n        emit Rebase(epoch++, _totalSupply);\n    }\n    \n    function balanceOf(address account) public view returns (uint256) {\n        return _gonBalances[account] / _gonsPerFragment;\n    }\n}"
    }
  }
}