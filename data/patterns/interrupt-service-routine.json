{
  "id": "interrupt-service-routine",
  "name": "Interrupt Service Routine",
  "category": "Embedded Systems",
  "description": "Handles asynchronous hardware events with minimal, time-critical code that quickly services the interrupt and defers complex processing to main execution context",
  "when_to_use": "Hardware event handling\nReal-time response requirements\nAsynchronous I/O operations\nTime-critical signal processing\nDevice driver implementation\nSensor data acquisition",
  "benefits": "Fast response to hardware events\nMinimal interrupt latency\nSeparation of urgent vs. complex processing\nEfficient resource utilization\nPredictable timing behavior",
  "drawbacks": "Complex concurrency management\nLimited operations in ISR context\nPotential for race conditions\nDebugging challenges\nStack usage considerations",
  "use_cases": "UART/serial communication\nTimer events\nGPIO pin changes\nADC/DAC conversions\nDMA completion\nExternal device interrupts",
  "complexity": "High",
  "tags": ["embedded", "interrupt", "asynchronous", "real-time", "hardware", "concurrency"],
  "examples": {
    "c": {
      "language": "c",
      "code": "// Global variables for ISR communication\nvolatile uint8_t uart_rx_buffer[256];\nvolatile uint16_t rx_head = 0;\nvolatile uint16_t rx_tail = 0;\nvolatile bool data_ready = false;\n\n// UART Interrupt Service Routine\nvoid UART0_IRQHandler(void) {\n    uint32_t status = UART0->MIS; // Masked Interrupt Status\n    \n    // Clear interrupt flags\n    UART0->ICR = status;\n    \n    if (status & UART_MIS_RXMIS) { // Receive interrupt\n        // Read data quickly\n        while (!(UART0->FR & UART_FR_RXFE)) { // While data available\n            uint8_t data = UART0->DR;\n            \n            // Store in circular buffer (ISR-safe)\n            uint16_t next_head = (rx_head + 1) % 256;\n            if (next_head != rx_tail) { // Check for overflow\n                uart_rx_buffer[rx_head] = data;\n                rx_head = next_head;\n                data_ready = true;\n            }\n            // Note: No complex processing here!\n        }\n    }\n    \n    if (status & UART_MIS_TXMIS) { // Transmit interrupt\n        // Handle transmit completion\n        // Could signal main loop to send more data\n    }\n}\n\n// Timer Interrupt Service Routine\nvoid TIMER0_IRQHandler(void) {\n    // Clear interrupt flag\n    TIMER0->ICR = TIMER_ICR_TATOCINT;\n    \n    // Minimal processing - just set flags or update counters\n    static uint32_t tick_count = 0;\n    tick_count++;\n    \n    // Signal main loop for time-based tasks\n    volatile bool timer_event = true;\n}\n\n// GPIO Interrupt Service Routine (Button debouncing)\nvoid GPIOA_IRQHandler(void) {\n    uint32_t pin_status = GPIOA->MIS;\n    GPIOA->ICR = pin_status; // Clear interrupts\n    \n    if (pin_status & (1 << BUTTON_PIN)) {\n        // Button press detected\n        static uint32_t last_press_time = 0;\n        uint32_t current_time = get_system_ticks();\n        \n        // Simple debouncing in ISR\n        if (current_time - last_press_time > DEBOUNCE_TICKS) {\n            volatile bool button_pressed = true;\n            last_press_time = current_time;\n        }\n    }\n}\n\n// Main application loop\nint main(void) {\n    system_init();\n    enable_interrupts();\n    \n    while (1) {\n        // Check for ISR signals and perform complex processing\n        if (data_ready) {\n            process_received_data();\n            data_ready = false;\n        }\n        \n        if (timer_event) {\n            handle_timer_tasks();\n            timer_event = false;\n        }\n        \n        if (button_pressed) {\n            handle_button_press();\n            button_pressed = false;\n        }\n        \n        // Other main loop tasks...\n    }\n}\n\n// Functions called from main loop (not ISR)\nvoid process_received_data(void) {\n    // Complex processing: parse commands, update state, etc.\n    while (rx_tail != rx_head) {\n        uint8_t data = uart_rx_buffer[rx_tail];\n        rx_tail = (rx_tail + 1) % 256;\n        \n        // Process data (parsing, validation, response generation)\n        handle_received_byte(data);\n    }\n}"
    },
    "typescript": {
      "language": "typescript",
      "code": "// Simulated interrupt handling for demonstration\nclass InterruptController {\n    private interrupts: Map<string, () => void> = new Map();\n    private volatileFlags: Map<string, boolean> = new Map();\n    \n    // Register an interrupt handler\n    registerInterrupt(name: string, handler: () => void): void {\n        this.interrupts.set(name, handler);\n        this.volatileFlags.set(name, false);\n    }\n    \n    // Simulate hardware interrupt (called asynchronously)\n    triggerInterrupt(name: string): void {\n        const handler = this.interrupts.get(name);\n        if (handler) {\n            // ISR execution - keep it minimal!\n            handler();\n        }\n    }\n    \n    // Check if interrupt flag is set (called from main loop)\n    isInterruptPending(name: string): boolean {\n        return this.volatileFlags.get(name) || false;\n    }\n    \n    // Clear interrupt flag (called from main loop)\n    clearInterrupt(name: string): void {\n        this.volatileFlags.set(name, false);\n    }\n}\n\n// UART-like device simulation\nclass UARTDevice {\n    private rxBuffer: number[] = [];\n    private interruptController: InterruptController;\n    \n    constructor(interruptController: InterruptController) {\n        this.interruptController = interruptController;\n        \n        // Register RX interrupt handler\n        interruptController.registerInterrupt('UART_RX', () => {\n            this.handleRxInterrupt();\n        });\n    }\n    \n    // Simulate receiving data (would be hardware-triggered)\n    receiveData(data: number): void {\n        // In real ISR, this would be called by hardware\n        this.rxBuffer.push(data);\n        this.interruptController.triggerInterrupt('UART_RX');\n    }\n    \n    private handleRxInterrupt(): void {\n        // Minimal ISR processing\n        // Just signal that data is ready\n        // Don't do complex parsing here!\n        console.log('UART RX interrupt: data ready');\n    }\n    \n    // Called from main loop to process received data\n    processReceivedData(): void {\n        while (this.rxBuffer.length > 0) {\n            const data = this.rxBuffer.shift()!;\n            console.log(`Processing received byte: ${data}`);\n            // Complex processing: parsing, validation, etc.\n            this.handleReceivedByte(data);\n        }\n    }\n    \n    private handleReceivedByte(data: number): void {\n        // Simulate command processing\n        if (data === 0x01) {\n            console.log('Command: Start');\n        } else if (data === 0x02) {\n            console.log('Command: Stop');\n        } else {\n            console.log(`Data: ${data}`);\n        }\n    }\n}\n\n// Timer simulation\nclass Timer {\n    private intervalId: NodeJS.Timeout | null = null;\n    private interruptController: InterruptController;\n    \n    constructor(interruptController: InterruptController) {\n        this.interruptController = interruptController;\n        \n        interruptController.registerInterrupt('TIMER', () => {\n            this.handleTimerInterrupt();\n        });\n    }\n    \n    start(intervalMs: number): void {\n        this.intervalId = setInterval(() => {\n            this.interruptController.triggerInterrupt('TIMER');\n        }, intervalMs);\n    }\n    \n    stop(): void {\n        if (this.intervalId) {\n            clearInterval(this.intervalId);\n            this.intervalId = null;\n        }\n    }\n    \n    private handleTimerInterrupt(): void {\n        // Minimal timer ISR\n        console.log('Timer interrupt: tick');\n        // Just signal - don't do timing-dependent work here\n    }\n}\n\n// Main application\nclass EmbeddedSystem {\n    private interruptController = new InterruptController();\n    private uart = new UARTDevice(this.interruptController);\n    private timer = new Timer(this.interruptController);\n    \n    start(): void {\n        this.timer.start(1000); // 1 second timer\n        \n        // Simulate receiving UART data\n        setTimeout(() => this.uart.receiveData(0x01), 500);\n        setTimeout(() => this.uart.receiveData(0x42), 1500);\n        setTimeout(() => this.uart.receiveData(0x02), 2500);\n        \n        // Main loop\n        setInterval(() => {\n            this.mainLoop();\n        }, 100);\n    }\n    \n    private mainLoop(): void {\n        // Check for pending interrupts and handle them\n        if (this.interruptController.isInterruptPending('UART_RX')) {\n            this.uart.processReceivedData();\n            this.interruptController.clearInterrupt('UART_RX');\n        }\n        \n        if (this.interruptController.isInterruptPending('TIMER')) {\n            this.handleTimerEvent();\n            this.interruptController.clearInterrupt('TIMER');\n        }\n        \n        // Other main loop tasks...\n    }\n    \n    private handleTimerEvent(): void {\n        console.log('Timer event: performing periodic tasks');\n        // Complex timer-based processing\n    }\n}\n\n// Usage\nconst system = new EmbeddedSystem();\nsystem.start();"
    }
  }
}
