{
  "id": "low-water-mark",
  "name": "Low-Water Mark",
  "category": "Distributed Systems",
  "description": "A pattern for tracking the minimum level of resources or progress in a system",
  "when_to_use": "Resource management, progress tracking, cleanup operations, batch processing",
  "benefits": "Efficient resource usage, prevents resource exhaustion, enables incremental processing",
  "drawbacks": "State management complexity, potential for lost progress on failures",
  "use_cases": "Log processing, queue management, cache invalidation, database cleanup",
  "complexity": "Medium",
  "tags": ["distributed-systems", "resource-management", "progress-tracking", "efficiency"],
  "examples": {
    "typescript": {
      "language": "typescript",
      "code": "class LowWaterMark {\n  private mark: number = 0;\n  private readonly storage: PersistentStorage;\n  \n  constructor(storage: PersistentStorage) {\n    this.storage = storage;\n    this.loadMark();\n  }\n  \n  private async loadMark() {\n    this.mark = await this.storage.get('low_water_mark') || 0;\n  }\n  \n  async updateMark(newMark: number) {\n    if (newMark > this.mark) {\n      this.mark = newMark;\n      await this.storage.set('low_water_mark', this.mark);\n    }\n  }\n  \n  getMark(): number {\n    return this.mark;\n  }\n  \n  async processBatch<T>(\n    items: T[],\n    processor: (item: T) => Promise<void>\n  ): Promise<void> {\n    let processedCount = 0;\n    \n    for (const item of items) {\n      await processor(item);\n      processedCount++;\n      \n      // Update low water mark periodically\n      if (processedCount % 100 === 0) {\n        await this.updateMark(this.mark + processedCount);\n      }\n    }\n    \n    // Final update\n    await this.updateMark(this.mark + processedCount);\n  }\n}\n\n// Log processing with low water mark\nclass LogProcessor {\n  private lowWaterMark: LowWaterMark;\n  private logStore: LogStore;\n  \n  constructor(lowWaterMark: LowWaterMark, logStore: LogStore) {\n    this.lowWaterMark = lowWaterMark;\n    this.logStore = logStore;\n  }\n  \n  async processLogs(): Promise<void> {\n    const lastProcessedId = this.lowWaterMark.getMark();\n    const logs = await this.logStore.getLogsSince(lastProcessedId);\n    \n    await this.lowWaterMark.processBatch(logs, async (log) => {\n      await this.processLogEntry(log);\n    });\n  }\n  \n  private async processLogEntry(log: LogEntry): Promise<void> {\n    // Process the log entry\n    console.log(`Processing log: ${log.message}`);\n    \n    // Simulate processing time\n    await new Promise(resolve => setTimeout(resolve, 10));\n  }\n}\n\n// Resource management with low water mark\nclass ResourcePool {\n  private lowWaterMark: LowWaterMark;\n  private resources: Resource[] = [];\n  private readonly maxResources: number;\n  \n  constructor(lowWaterMark: LowWaterMark, maxResources: number) {\n    this.lowWaterMark = lowWaterMark;\n    this.maxResources = maxResources;\n  }\n  \n  async acquireResource(): Promise<Resource> {\n    // Clean up resources below low water mark\n    await this.cleanupResources();\n    \n    if (this.resources.length >= this.maxResources) {\n      throw new Error('Resource pool exhausted');\n    }\n    \n    const resource = await this.createResource();\n    this.resources.push(resource);\n    return resource;\n  }\n  \n  async releaseResource(resource: Resource) {\n    const index = this.resources.indexOf(resource);\n    if (index > -1) {\n      this.resources.splice(index, 1);\n      await this.lowWaterMark.updateMark(this.lowWaterMark.getMark() + 1);\n    }\n  }\n  \n  private async cleanupResources() {\n    const mark = this.lowWaterMark.getMark();\n    this.resources = this.resources.filter(resource => \n      resource.id > mark\n    );\n  }\n  \n  private async createResource(): Promise<Resource> {\n    return { id: Date.now() + Math.random() };\n  }\n}\n\ninterface Resource {\n  id: number;\n}\n\ninterface LogEntry {\n  id: number;\n  message: string;\n  timestamp: number;\n}\n\ninterface LogStore {\n  getLogsSince(id: number): Promise<LogEntry[]>;\n}\n\ninterface PersistentStorage {\n  get(key: string): Promise<number | null>;\n  set(key: string, value: number): Promise<void>;\n}"
    }
  }
}
