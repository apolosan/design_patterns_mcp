{
  "id": "sql-query-optimization",
  "name": "Query Optimization Pattern",
  "category": "Performance",
  "description": "Techniques and best practices for optimizing SQL query performance through query plan analysis, execution statistics, and query rewriting. Focuses on understanding query execution, identifying bottlenecks, and applying optimization strategies to improve response times and resource utilization.",
  "when_to_use": "[\"Queries running slower than expected\",\"High CPU or memory usage\",\"Need to improve application performance\",\"Analyzing execution plans\",\"Optimizing for large datasets\",\"Reducing database server load\"]",
  "benefits": "[\"Dramatically improves query performance\",\"Reduces server resource consumption\",\"Better user experience\",\"Enables scaling without hardware upgrades\",\"Identifies missing indexes\",\"Reveals inefficient query patterns\"]",
  "drawbacks": "[\"Requires understanding of query execution\",\"Optimization can be time-consuming\",\"May need database-specific knowledge\",\"Over-optimization can reduce maintainability\",\"Performance depends on data distribution\"]",
  "use_cases": "[\"Slow-running reports and dashboards\",\"High-volume transaction processing\",\"Real-time analytics queries\",\"Data warehousing ETL processes\",\"API endpoint performance tuning\",\"Database migration optimization\"]",
  "complexity": "High",
  "tags": ["sql", "performance", "optimization", "execution-plan", "query-tuning", "bottleneck", "sargable"],
  "examples": {
    "tsql": {
      "description": "T-SQL query optimization techniques with execution plan analysis",
      "code": "-- Enable actual execution plan\nSET STATISTICS IO ON;\nSET STATISTICS TIME ON;\n\n-- BAD: Non-SARGable query (prevents index usage)\nSELECT * FROM Orders\nWHERE YEAR(OrderDate) = 2024;  -- Function on column\n\n-- GOOD: SARGable version (allows index usage)\nSELECT * FROM Orders\nWHERE OrderDate >= '2024-01-01' \n  AND OrderDate < '2025-01-01';\n\n-- BAD: SELECT * retrieves unnecessary columns\nSELECT * FROM Customers\nWHERE Country = 'USA';\n\n-- GOOD: Select only needed columns\nSELECT CustomerID, CustomerName, Email\nFROM Customers\nWHERE Country = 'USA';\n\n-- BAD: OR conditions prevent index usage\nSELECT * FROM Products\nWHERE Category = 'Electronics' OR Category = 'Computers';\n\n-- GOOD: Use IN clause instead\nSELECT * FROM Products\nWHERE Category IN ('Electronics', 'Computers');\n\n-- BAD: Implicit conversion (NVARCHAR to VARCHAR)\nSELECT * FROM Employees\nWHERE EmployeeID = N'123';  -- Parameter type mismatch\n\n-- GOOD: Correct data type\nSELECT * FROM Employees\nWHERE EmployeeID = 123;\n\n-- Optimize JOIN order (put most restrictive table first)\n-- BAD: Large table first\nSELECT o.OrderID, c.CustomerName\nFROM Orders o  -- 1 million rows\nINNER JOIN Customers c ON o.CustomerID = c.CustomerID\nWHERE o.OrderDate = '2024-01-01';  -- Filters to 100 rows\n\n-- BETTER: Use subquery or CTE to filter first\nWITH TodaysOrders AS (\n  SELECT OrderID, CustomerID\n  FROM Orders\n  WHERE OrderDate = '2024-01-01'\n)\nSELECT t.OrderID, c.CustomerName\nFROM TodaysOrders t\nINNER JOIN Customers c ON t.CustomerID = c.CustomerID;\n\n-- Use EXISTS instead of IN for subqueries\n-- BAD: IN with subquery\nSELECT * FROM Customers\nWHERE CustomerID IN (\n  SELECT CustomerID FROM Orders WHERE OrderDate >= '2024-01-01'\n);\n\n-- GOOD: EXISTS (stops at first match)\nSELECT * FROM Customers c\nWHERE EXISTS (\n  SELECT 1 FROM Orders o\n  WHERE o.CustomerID = c.CustomerID AND o.OrderDate >= '2024-01-01'\n);\n\n-- Optimize correlated subqueries with JOINs or window functions\n-- BAD: Correlated subquery (runs for each row)\nSELECT \n  EmployeeID,\n  Salary,\n  (SELECT AVG(Salary) FROM Employees e2 WHERE e2.Department = e1.Department) AS DeptAvg\nFROM Employees e1;\n\n-- GOOD: Window function (single pass)\nSELECT \n  EmployeeID,\n  Salary,\n  AVG(Salary) OVER (PARTITION BY Department) AS DeptAvg\nFROM Employees;\n\n-- Use query hints when needed (last resort)\nSELECT *\nFROM Orders WITH (INDEX(IX_Orders_OrderDate))\nWHERE OrderDate >= '2024-01-01';\n\n-- Optimize DISTINCT with GROUP BY\n-- POTENTIALLY SLOWER\nSELECT DISTINCT CustomerID FROM Orders;\n\n-- POTENTIALLY FASTER (with index on CustomerID)\nSELECT CustomerID FROM Orders GROUP BY CustomerID;\n\n-- Parameterize queries to enable plan reuse\n-- Avoid: SELECT * FROM Products WHERE CategoryID = 1;\n-- Use: EXEC sp_executesql N'SELECT * FROM Products WHERE CategoryID = @CategoryID', \n--      N'@CategoryID INT', @CategoryID = 1;\n\n-- Monitor query performance\nSELECT \n  qs.execution_count,\n  qs.total_elapsed_time / 1000000.0 AS total_seconds,\n  qs.total_elapsed_time / qs.execution_count / 1000000.0 AS avg_seconds,\n  SUBSTRING(qt.text, (qs.statement_start_offset/2)+1,\n    ((CASE qs.statement_end_offset\n      WHEN -1 THEN DATALENGTH(qt.text)\n      ELSE qs.statement_end_offset\n    END - qs.statement_start_offset)/2) + 1) AS query_text\nFROM sys.dm_exec_query_stats qs\nCROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) qt\nORDER BY qs.total_elapsed_time DESC;"
    },
    "postgresql": {
      "description": "PostgreSQL query optimization with EXPLAIN ANALYZE",
      "code": "-- Analyze query execution plan\nEXPLAIN ANALYZE\nSELECT * FROM orders WHERE order_date >= '2024-01-01';\n\n-- Detailed execution plan with buffers\nEXPLAIN (ANALYZE, BUFFERS, VERBOSE)\nSELECT o.order_id, c.customer_name\nFROM orders o\nJOIN customers c ON o.customer_id = c.customer_id\nWHERE o.order_date >= CURRENT_DATE - INTERVAL '30 days';\n\n-- Update table statistics for better query planning\nANALYZE orders;\nANALYZE VERBOSE customers;  -- With detailed output\n\n-- BAD: Function prevents index usage\nSELECT * FROM products WHERE LOWER(product_name) = 'laptop';\n\n-- GOOD: Functional index or case-insensitive search\nCREATE INDEX idx_product_name_lower ON products (LOWER(product_name));\n-- OR use ILIKE with appropriate index\nSELECT * FROM products WHERE product_name ILIKE 'laptop';\n\n-- Optimize large IN clauses with ANY/VALUES\n-- SLOWER for large lists\nSELECT * FROM products\nWHERE product_id IN (1, 2, 3, ..., 1000);\n\n-- FASTER\nSELECT * FROM products\nWHERE product_id = ANY(ARRAY[1, 2, 3, ..., 1000]);\n\n-- Use LATERAL JOIN for dependent subqueries\n-- BAD: Correlated subquery\nSELECT \n  c.customer_id,\n  (SELECT MAX(order_date) FROM orders WHERE customer_id = c.customer_id) AS last_order\nFROM customers c;\n\n-- GOOD: LATERAL JOIN\nSELECT c.customer_id, o.last_order\nFROM customers c\nLEFT JOIN LATERAL (\n  SELECT MAX(order_date) AS last_order\n  FROM orders\n  WHERE customer_id = c.customer_id\n) o ON true;\n\n-- Partition pruning for large tables\nCREATE TABLE sales (\n  sale_id SERIAL,\n  sale_date DATE,\n  amount DECIMAL\n) PARTITION BY RANGE (sale_date);\n\nCREATE TABLE sales_2024_q1 PARTITION OF sales\n  FOR VALUES FROM ('2024-01-01') TO ('2024-04-01');\n\n-- Query automatically prunes partitions\nSELECT * FROM sales\nWHERE sale_date BETWEEN '2024-01-01' AND '2024-01-31';\n-- Only scans sales_2024_q1 partition\n\n-- Use materialized views for expensive queries\nCREATE MATERIALIZED VIEW customer_summary AS\nSELECT \n  customer_id,\n  COUNT(*) AS order_count,\n  SUM(total_amount) AS total_spent,\n  MAX(order_date) AS last_order\nFROM orders\nGROUP BY customer_id;\n\nCREATE INDEX ON customer_summary (customer_id);\n\n-- Refresh materialized view\nREFRESH MATERIALIZED VIEW CONCURRENTLY customer_summary;\n\n-- Use COPY for bulk inserts (much faster than INSERT)\nCOPY products (product_name, price, category)\nFROM '/tmp/products.csv'\nWITH (FORMAT CSV, HEADER);\n\n-- Optimize text search with indexes\nCREATE INDEX idx_products_description_gin ON products \n  USING GIN (to_tsvector('english', description));\n\nSELECT * FROM products\nWHERE to_tsvector('english', description) @@ to_tsquery('laptop & gaming');\n\n-- Monitor slow queries\nSELECT \n  calls,\n  total_exec_time,\n  mean_exec_time,\n  query\nFROM pg_stat_statements\nORDER BY mean_exec_time DESC\nLIMIT 10;"
    },
    "mysql": {
      "description": "MySQL query optimization techniques and EXPLAIN analysis",
      "code": "-- Analyze query execution\nEXPLAIN SELECT * FROM orders WHERE order_date >= '2024-01-01';\n\n-- Extended EXPLAIN with more details\nEXPLAIN FORMAT=JSON\nSELECT o.order_id, c.customer_name\nFROM orders o\nJOIN customers c ON o.customer_id = c.customer_id\nWHERE o.order_date >= DATE_SUB(CURDATE(), INTERVAL 30 DAY);\n\n-- Analyze table to update statistics\nANALYZE TABLE orders;\nANALYZE TABLE customers, products, order_items;\n\n-- Optimize table (reclaim space, update indexes)\nOPTIMIZE TABLE orders;\n\n-- BAD: Function on indexed column\nSELECT * FROM orders\nWHERE DATE(order_timestamp) = '2024-01-01';\n\n-- GOOD: Range comparison\nSELECT * FROM orders\nWHERE order_timestamp >= '2024-01-01 00:00:00'\n  AND order_timestamp < '2024-01-02 00:00:00';\n\n-- Use covering index to avoid table lookups\nCREATE INDEX idx_orders_customer_date ON orders(customer_id, order_date, order_total);\n\nSELECT customer_id, order_date, order_total\nFROM orders\nWHERE customer_id = 123;  -- Uses covering index, no table access\n\n-- Optimize JOIN with proper index\nCREATE INDEX idx_orders_customer ON orders(customer_id);\nCREATE INDEX idx_customers_id ON customers(customer_id);\n\nSELECT o.order_id, c.customer_name\nFROM orders o\nFORCE INDEX (idx_orders_customer)\nJOIN customers c ON o.customer_id = c.customer_id;\n\n-- Use index hints when optimizer chooses poorly\nSELECT * FROM products\nUSE INDEX (idx_category)\nWHERE category_id = 5;\n\n-- Batch updates instead of row-by-row\n-- BAD: Multiple single-row updates\n-- UPDATE products SET stock = stock - 1 WHERE product_id = 1;\n-- UPDATE products SET stock = stock - 1 WHERE product_id = 2;\n\n-- GOOD: Single batch update\nUPDATE products\nSET stock = stock - 1\nWHERE product_id IN (1, 2, 3, 4, 5);\n\n-- Limit results for pagination\nSELECT product_id, product_name, price\nFROM products\nORDER BY product_id\nLIMIT 20 OFFSET 0;  -- Page 1\n\n-- Better pagination with keyset (no OFFSET)\nSELECT product_id, product_name, price\nFROM products\nWHERE product_id > 1000  -- Last seen ID\nORDER BY product_id\nLIMIT 20;\n\n-- Use INSERT IGNORE or REPLACE for upserts\nINSERT INTO product_inventory (product_id, quantity)\nVALUES (1, 100), (2, 200), (3, 300)\nON DUPLICATE KEY UPDATE\n  quantity = VALUES(quantity),\n  last_updated = NOW();\n\n-- Monitor query performance\nSELECT \n  digest_text,\n  count_star AS execution_count,\n  avg_timer_wait / 1000000000000 AS avg_seconds,\n  sum_timer_wait / 1000000000000 AS total_seconds\nFROM performance_schema.events_statements_summary_by_digest\nORDER BY sum_timer_wait DESC\nLIMIT 10;\n\n-- Check index usage\nSELECT \n  object_schema,\n  object_name,\n  index_name,\n  count_star,\n  count_read,\n  count_write\nFROM performance_schema.table_io_waits_summary_by_index_usage\nWHERE object_schema = 'your_database'\nORDER BY count_read DESC;"
    }
  }
}
