{
  "id": "api-versioning",
  "name": "Versioning Pattern",
  "category": "API",
  "description": "Defines strategies for API evolution without breaking existing clients",
  "when_to_use": "Public APIs\nFrequent evolution\nMultiple clients\nBackward compatibility",
  "benefits": "Backward compatibility\nClient flexibility\nSmooth upgrades\nDeprecation handling",
  "drawbacks": "Multiple versions to maintain\nClient confusion\nTesting complexity\nDeprecation overhead",
  "use_cases": "Public APIs\nSaaS platforms\nMicroservices evolution\nThird-party integrations",
  "complexity": "Medium",
  "tags": [
    "api",
    "versioning",
    "evolution",
    "backward-compatibility"
  ],
  "examples": {
    "typescript": {
      "language": "typescript",
      "code": "// API Versioning: evolve APIs without breaking clients\n\ninterface VersionInfo {\n  version: string;\n  status: \"active\" | \"deprecated\" | \"sunset\";\n  releaseDate: Date;\n  sunsetDate?: Date;\n  migrations: MigrationPath[];\n}\n\ninterface MigrationPath {\n  fromVersion: string;\n  toVersion: string;\n  guide: string;\n  breakingChanges: BreakingChange[];\n}\n\ninterface BreakingChange {\n  type: \"field-removed\" | \"field-renamed\" | \"type-changed\" | \"endpoint-moved\" | \"auth-changed\";\n  description: string;\n  migrationGuide: string;\n}\n\ninterface VersioningConfig {\n  defaultVersion: string;\n  supportedVersions: string[];\n  headerName: string;\n  deprecationPeriodDays: number;\n}\n\nclass APIVersioningManager {\n  private versions: Map<string, VersionInfo> = new Map();\n  private config: VersioningConfig;\n  private router: VersionRouter;\n  private deprecationNotifier: DeprecationNotifier;\n\n  constructor(config: VersioningConfig) {\n    this.config = config;\n    this.router = new VersionRouter();\n    this.deprecationNotifier = new DeprecationNotifier();\n  }\n\n  registerVersion(version: string, info: Omit<VersionInfo, \"version\">): void {\n    const versionInfo: VersionInfo = { ...info, version };\n    this.versions.set(version, versionInfo);\n\n    if (info.status === \"active\") {\n      this.router.registerVersion(version);\n    }\n\n    console.log(`API version ${version} registered as ${info.status}`);\n  }\n\n  deprecateVersion(version: string, sunsetDate?: Date): void {\n    const versionInfo = this.versions.get(version);\n    if (!versionInfo) {\n      throw new Error(`Version ${version} not found`);\n    }\n\n    versionInfo.status = \"deprecated\";\n    versionInfo.sunsetDate = sunsetDate || new Date(Date.now() + this.config.deprecationPeriodDays * 86400000);\n\n    this.deprecationNotifier.notifyDeprecation(version, versionInfo.sunsetDate);\n  }\n\n  async handleRequest(\n    request: VersionedRequest,\n    handler: RequestHandler\n  ): Promise<VersionedResponse> {\n    const requestedVersion = this.extractVersion(request);\n\n    if (!this.isVersionSupported(requestedVersion)) {\n      return this.handleUnsupportedVersion(request);\n    }\n\n    const versionInfo = this.versions.get(requestedVersion)!;\n\n    if (versionInfo.status === \"deprecated\") {\n      this.deprecationNotifier.addDeprecationHeader(request, versionInfo);\n    }\n\n    const routedRequest = this.router.route(request, requestedVersion);\n    const response = await handler.handle(routedRequest);\n    const responseWithVersion = this.addVersionInfo(response, requestedVersion);\n\n    if (versionInfo.status === \"sunset\") {\n      return this.handleSunsetVersion(requestedVersion);\n    }\n\n    return responseWithVersion;\n  }\n\n  private extractVersion(request: VersionedRequest): string {\n    const headerVersion = request.headers[this.config.headerName];\n    if (headerVersion) return headerVersion;\n\n    const pathVersion = this.extractFromPath(request.path);\n    if (pathVersion) return pathVersion;\n\n    const queryVersion = request.query[\"version\"];\n    if (queryVersion) return queryVersion;\n\n    return this.config.defaultVersion;\n  }\n\n  private extractFromPath(path: string): string | null {\n    const match = path.match(/\\/v(\\d+)/);\n    return match ? `v${match[1]}` : null;\n  }\n\n  private isVersionSupported(version: string): boolean {\n    return this.config.supportedVersions.includes(version);\n  }\n\n  private async handleUnsupportedVersion(request: VersionedRequest): Promise<VersionedResponse> {\n    const supportedVersions = this.config.supportedVersions.filter(v => {\n      const info = this.versions.get(v);\n      return info && info.status !== \"sunset\";\n    });\n\n    const latestVersion = supportedVersions[supportedVersions.length - 1];\n\n    return {\n      status: 400,\n      body: {\n        error: \"Unsupported API version\",\n        requestedVersion: this.extractVersion(request),\n        supportedVersions,\n        latestVersion,\n        migrationGuide: `Migrate from ${this.extractVersion(request)} to ${latestVersion}`\n      },\n      headers: {\n        \"X-API-Versions-Available\": supportedVersions.join(\",\")\n      }\n    };\n  }\n\n  private addVersionInfo(response: VersionedResponse, version: string): VersionedResponse {\n    return {\n      ...response,\n      headers: {\n        ...response.headers,\n        \"X-API-Version\": version\n      }\n    };\n  }\n\n  private async handleSunsetVersion(version: string): Promise<VersionedResponse> {\n    return {\n      status: 410,\n      body: {\n        error: \"API version sunset\",\n        message: `Version ${version} has been sunset`\n      }\n    };\n  }\n\n  getVersionStatus(): VersionStatus[] {\n    return Array.from(this.versions.values()).map(info => ({\n      version: info.version,\n      status: info.status,\n      releaseDate: info.releaseDate,\n      sunsetDate: info.sunsetDate,\n      daysUntilSunset: info.sunsetDate\n        ? Math.ceil((info.sunsetDate.getTime() - Date.now()) / 86400000)\n        : null\n    }));\n  }\n}\n\nclass VersionRouter {\n  private registeredVersions: Set<string> = new Set();\n\n  registerVersion(version: string): void {\n    this.registeredVersions.add(version);\n  }\n\n  unregisterVersion(version: string): void {\n    this.registeredVersions.delete(version);\n  }\n\n  route(request: VersionedRequest, version: string): VersionedRequest {\n    return request;\n  }\n}\n\nclass DeprecationNotifier {\n  notifyDeprecation(version: string, sunsetDate: Date): void {\n    console.log(`Version ${version} deprecated, sunset at ${sunsetDate}`);\n  }\n\n  addDeprecationHeader(request: VersionedRequest, versionInfo: VersionInfo): void {\n    request.headers[\"Deprecation\"] = \"true\";\n    request.headers[\"Sunset\"] = versionInfo.sunsetDate!.toUTCString();\n  }\n}\n\ninterface VersionedRequest {\n  path: string;\n  method: string;\n  headers: Record<string, string>;\n  query: Record<string, string>;\n  body?: any;\n}\n\ninterface VersionedResponse {\n  status: number;\n  body?: any;\n  headers?: Record<string, string>;\n}\n\ninterface RequestHandler {\n  handle(request: VersionedRequest): Promise<VersionedResponse>;\n}\n\ninterface VersionStatus {\n  version: string;\n  status: string;\n  releaseDate: Date;\n  sunsetDate?: Date;\n  daysUntilSunset: number | null;\n}"
    }
  }
}
