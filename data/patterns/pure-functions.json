{
  "id": "pure-functions",
  "name": "Pure Functions Pattern",
  "category": "Functional",
  "description": "Functions with no side effects and deterministic output based only on inputs",
  "when_to_use": "Testing, caching, parallel processing, reasoning about code, functional programming",
  "benefits": "Testable, cacheable, parallelizable, predictable, composable",
  "drawbacks": "State management complexity, performance overhead, I/O limitations",
  "use_cases": "Data transformations, calculations, validation, business logic",
  "complexity": "Low",
  "tags": ["functional", "pure", "deterministic", "testable", "cacheable"],
  "examples": {
    "kotlin": {
      "language": "kotlin",
      "code": "// Pure function - same input always produces same output\nfun calculateTax(income: Double, taxRate: Double): Double {\n    return income * taxRate\n}\n\n// Usage\nval tax1 = calculateTax(50000.0, 0.25) // Always 12500.0\nval tax2 = calculateTax(50000.0, 0.25) // Always 12500.0\n\n// Impure function (side effects)\nfun saveToDatabase(user: User): Boolean {\n    return database.save(user) // Side effect: modifies external state\n}\n\n// Pure version\nfun validateUser(user: User): ValidationResult {\n    return if (user.email.contains(\"@\")) Valid else Invalid\n}\n\n// Pure data transformation\nfun processUsers(users: List<User>): List<ProcessedUser> {\n    return users.map { user ->\n        ProcessedUser(\n            id = user.id,\n            displayName = \"${user.firstName} ${user.lastName}\",\n            isAdult = user.age >= 18,\n            emailDomain = user.email.substringAfter(\"@\")\n        )\n    }\n}\n\n// Pure validation functions\ndata class ValidationResult(val isValid: Boolean, val errors: List<String>)\n\ndata class UserInput(\n    val name: String,\n    val email: String,\n    val age: Int\n)\n\nfun validateName(name: String): ValidationResult {\n    val errors = mutableListOf<String>()\n    if (name.isBlank()) errors.add(\"Name cannot be blank\")\n    if (name.length < 2) errors.add(\"Name must be at least 2 characters\")\n    return ValidationResult(errors.isEmpty(), errors)\n}\n\nfun validateEmail(email: String): ValidationResult {\n    val errors = mutableListOf<String>()\n    if (!email.contains(\"@\")) errors.add(\"Email must contain @\")\n    if (!email.contains(\".\")) errors.add(\"Email must contain domain\")\n    return ValidationResult(errors.isEmpty(), errors)\n}\n\nfun validateAge(age: Int): ValidationResult {\n    val errors = mutableListOf<String>()\n    if (age < 0) errors.add(\"Age cannot be negative\")\n    if (age > 150) errors.add(\"Age seems unrealistic\")\n    return ValidationResult(errors.isEmpty(), errors)\n}\n\nfun validateUserInput(input: UserInput): ValidationResult {\n    val nameResult = validateName(input.name)\n    val emailResult = validateEmail(input.email)\n    val ageResult = validateAge(input.age)\n    \n    val allErrors = nameResult.errors + emailResult.errors + ageResult.errors\n    val isValid = nameResult.isValid && emailResult.isValid && ageResult.isValid\n    \n    return ValidationResult(isValid, allErrors)\n}\n\n// Pure mathematical functions\nfun fibonacci(n: Int): Int {\n    return when {\n        n < 0 -> throw IllegalArgumentException(\"Negative numbers not allowed\")\n        n == 0 -> 0\n        n == 1 -> 1\n        else -> fibonacci(n - 1) + fibonacci(n - 2)\n    }\n}\n\nfun factorial(n: Int): Long {\n    require(n >= 0) { \"Negative numbers not allowed\" }\n    return if (n <= 1) 1 else n * factorial(n - 1)\n}\n\n// Pure collection operations\nfun <T> List<T>.customFilter(predicate: (T) -> Boolean): List<T> {\n    val result = mutableListOf<T>()\n    for (item in this) {\n        if (predicate(item)) {\n            result.add(item)\n        }\n    }\n    return result\n}\n\nfun <T, R> List<T>.customMap(transform: (T) -> R): List<R> {\n    val result = mutableListOf<R>()\n    for (item in this) {\n        result.add(transform(item))\n    }\n    return result\n}\n\n// Pure sorting\nfun <T : Comparable<T>> List<T>.pureSort(): List<T> {\n    return this.sorted()\n}\n\n// Usage examples\nval numbers = listOf(1, 2, 3, 4, 5, 6)\nval evenNumbers = numbers.customFilter { it % 2 == 0 } // [2, 4, 6]\nval doubled = numbers.customMap { it * 2 } // [2, 4, 6, 8, 10, 12]\nval sorted = listOf(3, 1, 4, 1, 5).pureSort() // [1, 1, 3, 4, 5]\n\n// Pure random (using seed for determinism)\nfun randomInt(seed: Long, min: Int, max: Int): Int {\n    val random = java.util.Random(seed)\n    return random.nextInt(max - min + 1) + min\n}\n\n// Same seed always produces same result\nval r1 = randomInt(12345, 1, 100) // Always same value\nval r2 = randomInt(12345, 1, 100) // Same as r1"
    }
  }
}
