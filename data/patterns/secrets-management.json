{
  "id": "secrets-management",
  "name": "Secrets Management Pattern",
  "category": "Security",
  "description": "Centralizes secure storage and management of credentials, keys, and secrets with encryption and rotation",
  "when_to_use": "Any application with credentials\nSOC2/PCI-DSS compliance\nSensitive data protection\nCredential rotation requirements",
  "benefits": "Centralized storage\nEncryption at rest and transit\nAudit logging\nAutomatic rotation",
  "drawbacks": "Dependency on vault\nKey management complexity\nAccess control complexity\nCost",
  "use_cases": "Database credentials\nAPI keys\nTLS certificates\nService account credentials",
  "complexity": "Medium",
  "tags": [
    "security",
    "secrets",
    "credential-management",
    "vault"
  ],
  "examples": {
    "typescript": {
      "language": "typescript",
      "code": "// Secrets Management: centralized secure credential storage\n\ninterface Secret {\n  id: string;\n  name: string;\n  value: string;\n  version: number;\n  createdAt: Date;\n  expiresAt?: Date;\n  metadata: Record<string, string>;\n}\n\ninterface SecretManagerConfig {\n  vaultUrl: string;\n  authMethod: \"aws-iam\" | \"azure-ad\" | \"gcp-sa\" | \"token\";\n  encryptionKey: string;\n}\n\nclass SecretsManager {\n  private cache: Map<string, Secret> = new Map();\n  private config: SecretManagerConfig;\n\n  constructor(config: SecretManagerConfig) {\n    this.config = config;\n  }\n\n  async getSecret(name: string, version?: number): Promise<string> {\n    const cacheKey = `${name}:${version ?? \"latest\"}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) {\n      return cached.value;\n    }\n\n    const secret = await this.fetchFromVault(name, version);\n    this.cache.set(cacheKey, secret);\n    return secret.value;\n  }\n\n  async setSecret(name: string, value: string, metadata?: Record<string, string>): Promise<Secret> {\n    const secret: Secret = {\n      id: crypto.randomUUID(),\n      name,\n      value: this.encrypt(value),\n      version: await this.getLatestVersion(name) + 1,\n      createdAt: new Date(),\n      metadata: metadata ?? {}\n    };\n\n    await this.storeInVault(secret);\n    this.cache.set(`${name}:latest`, secret);\n    return secret;\n  }\n\n  async rotateSecret(name: string): Promise<Secret> {\n    const currentValue = await this.getSecret(name);\n    const newValue = this.generateNewSecret();\n    return this.setSecret(name, newValue, { rotated: \"true\" });\n  }\n\n  async revokeSecret(name: string): Promise<void> {\n    await this.deleteFromVault(name);\n    this.cache.clear();\n  }\n\n  private async fetchFromVault(name: string, version?: number): Promise<Secret> {\n    return {\n      id: \"\",\n      name,\n      value: \"\",\n      version: 1,\n      createdAt: new Date(),\n      metadata: {}\n    };\n  }\n\n  private async storeInVault(secret: Secret): Promise<void> {}\n  private async deleteFromVault(name: string): Promise<void> {}\n  private async getLatestVersion(name: string): Promise<number> { return 0; }\n\n  private encrypt(value: string): string {\n    return `encrypted(${value})`;\n  }\n\n  private generateNewSecret(): string {\n    return crypto.randomUUID();\n  }\n}"
    }
  },
  "relationships": [
    {
      "target_pattern_id": "encryption",
      "type": "uses",
      "description": "Secrets management relies on encryption for protection"
    },
    {
      "target_pattern_id": "audit-logging",
      "type": "complements",
      "description": "Secrets management integrates with audit logging"
    }
  ]
}
