{
  "id": "circular-buffer",
  "name": "Circular Buffer",
  "category": "Embedded Systems",
  "description": "Fixed-size buffer that wraps around when full, providing efficient FIFO storage with constant-time operations for embedded systems with limited memory",
  "when_to_use": "Streaming data processing\nInterrupt-driven data collection\nProducer-consumer scenarios\nLimited memory environments\nReal-time data buffering\nUART/SPI communication buffers",
  "benefits": "Constant time complexity O(1)\nFixed memory usage\nNo dynamic allocation\nThread-safe with proper implementation\nEfficient for embedded systems",
  "drawbacks": "Fixed size limitation\nData loss on overflow\nComplexity with multiple producers/consumers\nPointer management required",
  "use_cases": "Serial communication buffers\nAudio/video streaming\nSensor data collection\nEvent logging\nNetwork packet buffering\nReal-time data acquisition",
  "complexity": "Medium",
  "tags": ["embedded", "data-structure", "fifo", "ring-buffer", "memory-efficient", "real-time"],
  "examples": {
    "c": {
      "language": "c",
      "code": "#define BUFFER_SIZE 256\n\ntypedef struct {\n    uint8_t buffer[BUFFER_SIZE];\n    volatile uint16_t head;\n    volatile uint16_t tail;\n    volatile uint16_t count;\n} CircularBuffer;\n\nvoid circular_buffer_init(CircularBuffer* cb) {\n    cb->head = 0;\n    cb->tail = 0;\n    cb->count = 0;\n}\n\nbool circular_buffer_put(CircularBuffer* cb, uint8_t data) {\n    if (cb->count >= BUFFER_SIZE) {\n        return false; // Buffer full\n    }\n    \n    cb->buffer[cb->head] = data;\n    cb->head = (cb->head + 1) % BUFFER_SIZE;\n    __disable_irq(); // Critical section\n    cb->count++;\n    __enable_irq();\n    return true;\n}\n\nbool circular_buffer_get(CircularBuffer* cb, uint8_t* data) {\n    if (cb->count == 0) {\n        return false; // Buffer empty\n    }\n    \n    *data = cb->buffer[cb->tail];\n    cb->tail = (cb->tail + 1) % BUFFER_SIZE;\n    __disable_irq(); // Critical section\n    cb->count--;\n    __enable_irq();\n    return true;\n}\n\nuint16_t circular_buffer_count(CircularBuffer* cb) {\n    return cb->count;\n}\n\nbool circular_buffer_is_empty(CircularBuffer* cb) {\n    return cb->count == 0;\n}\n\nbool circular_buffer_is_full(CircularBuffer* cb) {\n    return cb->count >= BUFFER_SIZE;\n}\n\n// Usage example\nCircularBuffer rx_buffer;\ncircular_buffer_init(&rx_buffer);\n\n// In UART interrupt\nvoid UART_IRQHandler(void) {\n    uint8_t data = UART->DR;\n    circular_buffer_put(&rx_buffer, data);\n}\n\n// In main loop\nuint8_t data;\nif (circular_buffer_get(&rx_buffer, &data)) {\n    process_received_data(data);\n}"
    },
    "typescript": {
      "language": "typescript",
      "code": "class CircularBuffer<T> {\n    private buffer: T[];\n    private head: number = 0;\n    private tail: number = 0;\n    private count: number = 0;\n    \n    constructor(private capacity: number) {\n        this.buffer = new Array(capacity);\n    }\n    \n    put(item: T): boolean {\n        if (this.count >= this.capacity) {\n            return false; // Buffer full\n        }\n        \n        this.buffer[this.head] = item;\n        this.head = (this.head + 1) % this.capacity;\n        this.count++;\n        return true;\n    }\n    \n    get(): T | null {\n        if (this.count === 0) {\n            return null; // Buffer empty\n        }\n        \n        const item = this.buffer[this.tail];\n        this.tail = (this.tail + 1) % this.capacity;\n        this.count--;\n        return item;\n    }\n    \n    peek(): T | null {\n        if (this.count === 0) {\n            return null;\n        }\n        return this.buffer[this.tail];\n    }\n    \n    size(): number {\n        return this.count;\n    }\n    \n    isEmpty(): boolean {\n        return this.count === 0;\n    }\n    \n    isFull(): boolean {\n        return this.count >= this.capacity;\n    }\n    \n    clear(): void {\n        this.head = 0;\n        this.tail = 0;\n        this.count = 0;\n    }\n}\n\n// Usage example\nconst buffer = new CircularBuffer<number>(10);\n\n// Producer\nbuffer.put(1);\nbuffer.put(2);\nbuffer.put(3);\n\n// Consumer\nconsole.log(buffer.get()); // 1\nconsole.log(buffer.get()); // 2\nconsole.log(buffer.size()); // 1\n\n// Check status\nconsole.log(buffer.isEmpty()); // false\nconsole.log(buffer.isFull()); // false"
    }
  }
}
