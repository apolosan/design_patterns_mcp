{
  "id": "servant",
  "name": "Servant",
  "category": "Behavioral",
  "description": "Define common functionality for a group of classes",
  "when_to_use": "Common operations\nGroup behavior\nAvoid code duplication\nExtensibility",
  "benefits": "Code reuse\nConsistent behavior\nEasy maintenance\nExtensibility",
  "drawbacks": "Tight coupling\nInterface complexity\nTesting challenges",
  "use_cases": "Shape operations\nFile processing\nData validation\nBusiness rules",
  "complexity": "Medium",
  "tags": ["behavioral", "servant", "common-functionality", "group-operations"],
  "examples": {
    "typescript": {
      "language": "typescript",
      "code": "// Servant Pattern\n// Defines common functionality for a group of classes\n\n// Servant interface - defines operations that can be performed on elements\ninterface ShapeServant {\n  calculateArea(shape: Shape): number;\n  calculatePerimeter(shape: Shape): number;\n  draw(shape: Shape): void;\n}\n\n// Element interface - what the servant operates on\ninterface Shape {\n  accept(servant: ShapeServant): void;\n}\n\n// Concrete shapes\nclass Circle implements Shape {\n  constructor(public radius: number) {}\n\n  accept(servant: ShapeServant): void {\n    servant.calculateArea(this);\n    servant.calculatePerimeter(this);\n    servant.draw(this);\n  }\n}\n\nclass Rectangle implements Shape {\n  constructor(public width: number, public height: number) {}\n\n  accept(servant: ShapeServant): void {\n    servant.calculateArea(this);\n    servant.calculatePerimeter(this);\n    servant.draw(this);\n  }\n}\n\nclass Triangle implements Shape {\n  constructor(public base: number, public height: number) {}\n\n  accept(servant: ShapeServant): void {\n    servant.calculateArea(this);\n    servant.calculatePerimeter(this);\n    servant.draw(this);\n  }\n}\n\n// Concrete servant - implements common operations\nclass ShapeOperationsServant implements ShapeServant {\n  calculateArea(shape: Shape): number {\n    if (shape instanceof Circle) {\n      return Math.PI * shape.radius * shape.radius;\n    } else if (shape instanceof Rectangle) {\n      return shape.width * shape.height;\n    } else if (shape instanceof Triangle) {\n      return (shape.base * shape.height) / 2;\n    }\n    return 0;\n  }\n\n  calculatePerimeter(shape: Shape): number {\n    if (shape instanceof Circle) {\n      return 2 * Math.PI * shape.radius;\n    } else if (shape instanceof Rectangle) {\n      return 2 * (shape.width + shape.height);\n    } else if (shape instanceof Triangle) {\n      // Assuming equilateral triangle for simplicity\n      return 3 * shape.base;\n    }\n    return 0;\n  }\n\n  draw(shape: Shape): void {\n    if (shape instanceof Circle) {\n      console.log(`Drawing circle with radius ${shape.radius}`);\n    } else if (shape instanceof Rectangle) {\n      console.log(`Drawing rectangle ${shape.width}x${shape.height}`);\n    } else if (shape instanceof Triangle) {\n      console.log(`Drawing triangle with base ${shape.base} and height ${shape.height}`);\n    }\n  }\n}\n\n// Usage\nconst servant = new ShapeOperationsServant();\nconst shapes: Shape[] = [\n  new Circle(5),\n  new Rectangle(4, 6),\n  new Triangle(3, 4)\n];\n\n// Apply servant operations to all shapes\nshapes.forEach(shape => shape.accept(servant));\n\n// Output:\n// Drawing circle with radius 5\n// Drawing rectangle 4x6\n// Drawing triangle with base 3 and height 4\n\n// Advanced example: File processing servant\ninterface FileProcessor {\n  process(file: File): void;\n  validate(file: File): boolean;\n  transform(file: File): File;\n}\n\ninterface File {\n  name: string;\n  content: string;\n  accept(processor: FileProcessor): void;\n}\n\nclass TextFile implements File {\n  constructor(public name: string, public content: string) {}\n\n  accept(processor: FileProcessor): void {\n    if (processor.validate(this)) {\n      const transformed = processor.transform(this);\n      processor.process(transformed);\n    }\n  }\n}\n\nclass JsonFile implements File {\n  constructor(public name: string, public content: string) {}\n\n  accept(processor: FileProcessor): void {\n    if (processor.validate(this)) {\n      const transformed = processor.transform(this);\n      processor.process(transformed);\n    }\n  }\n}\n\nclass FileOperationsServant implements FileProcessor {\n  process(file: File): void {\n    console.log(`Processing file: ${file.name}`);\n    // Common processing logic\n  }\n\n  validate(file: File): boolean {\n    // Common validation logic\n    return file.content.length > 0;\n  }\n\n  transform(file: File): File {\n    // Common transformation logic\n    return {\n      ...file,\n      content: file.content.toUpperCase()\n    };\n  }\n}\n\n// Usage\nconst fileProcessor = new FileOperationsServant();\nconst files: File[] = [\n  new TextFile('document.txt', 'hello world'),\n  new JsonFile('config.json', '{\"setting\": \"value\"}')\n];\n\nfiles.forEach(file => file.accept(fileProcessor));\n\n// Business rules servant example\ninterface BusinessRule {\n  apply(entity: any): void;\n  validate(entity: any): boolean;\n}\n\ninterface Entity {\n  accept(rule: BusinessRule): void;\n}\n\nclass Order implements Entity {\n  constructor(\n    public id: string,\n    public amount: number,\n    public customerId: string\n  ) {}\n\n  accept(rule: BusinessRule): void {\n    if (rule.validate(this)) {\n      rule.apply(this);\n    }\n  }\n}\n\nclass Product implements Entity {\n  constructor(\n    public id: string,\n    public price: number,\n    public category: string\n  ) {}\n\n  accept(rule: BusinessRule): void {\n    if (rule.validate(this)) {\n      rule.apply(this);\n    }\n  }\n}\n\nclass BusinessRulesServant implements BusinessRule {\n  apply(entity: any): void {\n    if (entity instanceof Order) {\n      // Apply order-specific rules\n      if (entity.amount > 1000) {\n        entity.discount = 0.1; // 10% discount for large orders\n      }\n    } else if (entity instanceof Product) {\n      // Apply product-specific rules\n      if (entity.category === 'premium') {\n        entity.markup = 1.5; // 50% markup for premium products\n      }\n    }\n  }\n\n  validate(entity: any): boolean {\n    // Common validation logic\n    return entity.id && entity.id.length > 0;\n  }\n}\n\n// Usage\nconst businessRules = new BusinessRulesServant();\nconst entities: Entity[] = [\n  new Order('order-1', 1500, 'customer-1'),\n  new Product('product-1', 100, 'premium')\n];\n\nentities.forEach(entity => entity.accept(businessRules));\n\n// Benefits of Servant Pattern:\n// 1. Centralizes common operations\n// 2. Easy to add new operations\n// 3. Consistent behavior across similar objects\n// 4. Reduces code duplication\n// 5. Easy to test and maintain"
    }
  }
}
