{
  "id": "sql-window-functions",
  "name": "Window Functions Pattern",
  "category": "Data Query",
  "description": "Performs calculations across a set of rows related to the current row using OVER clause. Unlike GROUP BY which collapses rows, window functions preserve individual rows while adding calculated values. Supports ranking, running totals, moving averages, and row comparisons without self-joins.",
  "when_to_use": "[\"Calculate running totals or cumulative sums\",\"Rank or number rows within partitions\",\"Calculate moving averages\",\"Compare current row with previous/next rows\",\"Perform analytics without losing row detail\",\"Avoid complex self-joins\"]",
  "benefits": "[\"Preserves all rows (unlike GROUP BY)\",\"Eliminates need for self-joins\",\"Enables complex analytics in single query\",\"Better performance than correlated subqueries\",\"Supports partitioning and ordering\",\"Clean, readable syntax\"]",
  "drawbacks": "[\"Can be memory-intensive for large datasets\",\"May impact performance without proper indexing\",\"Complex syntax for beginners\",\"Not all databases support all window functions\"]",
  "use_cases": "[\"Sales running totals and YoY comparisons\",\"Ranking products, customers, employees\",\"Calculating moving averages (stock prices)\",\"Finding gaps and islands in sequences\",\"Page views and session analytics\",\"Salary percentile calculations\"]",
  "complexity": "Medium",
  "tags": ["sql", "window-functions", "over-clause", "row-number", "rank", "lead", "lag", "running-total"],
  "examples": {
    "tsql": {
      "description": "T-SQL window functions including ROW_NUMBER, RANK, DENSE_RANK, LAG, LEAD, and aggregates",
      "code": "-- ROW_NUMBER: Assign unique sequential number\nSELECT \n  CustomerID,\n  OrderDate,\n  TotalAmount,\n  ROW_NUMBER() OVER (PARTITION BY CustomerID ORDER BY OrderDate DESC) AS OrderSequence\nFROM Orders;\n\n-- RANK and DENSE_RANK: Ranking with different tie handling\nSELECT \n  ProductName,\n  Price,\n  Category,\n  RANK() OVER (ORDER BY Price DESC) AS PriceRank,\n  DENSE_RANK() OVER (PARTITION BY Category ORDER BY Price DESC) AS CategoryRank,\n  NTILE(4) OVER (ORDER BY Price DESC) AS PriceQuartile\nFROM Products;\n\n-- Running totals with SUM window function\nSELECT \n  OrderDate,\n  CustomerID,\n  OrderAmount,\n  SUM(OrderAmount) OVER (PARTITION BY CustomerID ORDER BY OrderDate) AS RunningTotal,\n  SUM(OrderAmount) OVER (PARTITION BY CustomerID) AS CustomerTotal,\n  SUM(OrderAmount) OVER () AS GrandTotal\nFROM Orders\nORDER BY CustomerID, OrderDate;\n\n-- LAG and LEAD: Access previous/next row values\nSELECT \n  OrderDate,\n  SalesAmount,\n  LAG(SalesAmount, 1, 0) OVER (ORDER BY OrderDate) AS PreviousDaySales,\n  LEAD(SalesAmount, 1, 0) OVER (ORDER BY OrderDate) AS NextDaySales,\n  SalesAmount - LAG(SalesAmount, 1, 0) OVER (ORDER BY OrderDate) AS DayOverDayChange,\n  ((SalesAmount - LAG(SalesAmount, 1, 0) OVER (ORDER BY OrderDate)) / \n    NULLIF(LAG(SalesAmount, 1, 0) OVER (ORDER BY OrderDate), 0)) * 100 AS PercentChange\nFROM DailySales;\n\n-- Moving average with ROWS BETWEEN\nSELECT \n  Date,\n  StockPrice,\n  AVG(StockPrice) OVER (\n    ORDER BY Date\n    ROWS BETWEEN 6 PRECEDING AND CURRENT ROW\n  ) AS SevenDayMovingAvg,\n  AVG(StockPrice) OVER (\n    ORDER BY Date\n    ROWS BETWEEN 29 PRECEDING AND CURRENT ROW\n  ) AS ThirtyDayMovingAvg\nFROM StockPrices;\n\n-- First and last values in partition\nSELECT \n  EmployeeID,\n  Department,\n  Salary,\n  FIRST_VALUE(Salary) OVER (PARTITION BY Department ORDER BY Salary DESC) AS HighestSalary,\n  LAST_VALUE(Salary) OVER (\n    PARTITION BY Department \n    ORDER BY Salary DESC\n    ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING\n  ) AS LowestSalary,\n  Salary - FIRST_VALUE(Salary) OVER (\n    PARTITION BY Department ORDER BY Salary DESC\n  ) AS SalaryGapFromTop\nFROM Employees;\n\n-- Top N per group using window functions\nWITH RankedOrders AS (\n  SELECT \n    CustomerID,\n    OrderID,\n    OrderDate,\n    TotalAmount,\n    ROW_NUMBER() OVER (PARTITION BY CustomerID ORDER BY TotalAmount DESC) AS OrderRank\n  FROM Orders\n)\nSELECT CustomerID, OrderID, OrderDate, TotalAmount\nFROM RankedOrders\nWHERE OrderRank <= 3;\n\n-- Percentile calculations\nSELECT \n  ProductID,\n  Price,\n  PERCENT_RANK() OVER (ORDER BY Price) AS PercentRank,\n  CUME_DIST() OVER (ORDER BY Price) AS CumulativeDistribution,\n  PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY Price) OVER () AS MedianPrice\nFROM Products;"
    },
    "postgresql": {
      "description": "PostgreSQL window functions with advanced features",
      "code": "-- Basic window functions\nSELECT \n  employee_id,\n  department,\n  salary,\n  AVG(salary) OVER (PARTITION BY department) AS dept_avg_salary,\n  salary - AVG(salary) OVER (PARTITION BY department) AS salary_diff_from_avg,\n  RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS dept_salary_rank\nFROM employees;\n\n-- LAG/LEAD for time-series analysis\nSELECT \n  date,\n  revenue,\n  LAG(revenue, 1) OVER (ORDER BY date) AS prev_day_revenue,\n  LEAD(revenue, 1) OVER (ORDER BY date) AS next_day_revenue,\n  revenue - LAG(revenue, 7) OVER (ORDER BY date) AS week_over_week_change,\n  revenue - LAG(revenue, 365) OVER (ORDER BY date) AS year_over_year_change\nFROM daily_sales;\n\n-- RANGE vs ROWS frame specification\nSELECT \n  order_date,\n  order_amount,\n  -- ROWS: Physical rows\n  SUM(order_amount) OVER (\n    ORDER BY order_date\n    ROWS BETWEEN 2 PRECEDING AND CURRENT ROW\n  ) AS sum_last_3_rows,\n  -- RANGE: Logical range (includes ties)\n  SUM(order_amount) OVER (\n    ORDER BY order_date\n    RANGE BETWEEN INTERVAL '7 days' PRECEDING AND CURRENT ROW\n  ) AS sum_last_7_days\nFROM orders;\n\n-- FILTER clause with window functions\nSELECT \n  product_id,\n  category,\n  sales_amount,\n  SUM(sales_amount) OVER (PARTITION BY category) AS total_category_sales,\n  SUM(sales_amount) FILTER (WHERE is_promotional) OVER (PARTITION BY category) AS promo_sales,\n  COUNT(*) FILTER (WHERE sales_amount > 1000) OVER (PARTITION BY category) AS high_value_count\nFROM product_sales;\n\n-- Finding gaps in sequences\nWITH numbered_records AS (\n  SELECT \n    id,\n    date,\n    ROW_NUMBER() OVER (ORDER BY date) AS rn,\n    date - (ROW_NUMBER() OVER (ORDER BY date))::INTEGER AS group_id\n  FROM events\n)\nSELECT \n  MIN(date) AS gap_start,\n  MAX(date) AS gap_end,\n  MAX(date) - MIN(date) AS gap_days\nFROM numbered_records\nGROUP BY group_id\nHAVING COUNT(*) > 1;\n\n-- NTILE for quantile analysis\nSELECT \n  customer_id,\n  total_purchases,\n  NTILE(10) OVER (ORDER BY total_purchases) AS decile,\n  NTILE(100) OVER (ORDER BY total_purchases) AS percentile,\n  CASE NTILE(4) OVER (ORDER BY total_purchases)\n    WHEN 1 THEN 'Bottom 25%'\n    WHEN 2 THEN '25-50%'\n    WHEN 3 THEN '50-75%'\n    WHEN 4 THEN 'Top 25%'\n  END AS quartile_label\nFROM customer_lifetime_value;\n\n-- Mode (most frequent value) using window functions\nWITH value_counts AS (\n  SELECT \n    category,\n    value,\n    COUNT(*) AS frequency,\n    ROW_NUMBER() OVER (PARTITION BY category ORDER BY COUNT(*) DESC) AS rank\n  FROM data_table\n  GROUP BY category, value\n)\nSELECT category, value AS mode_value, frequency\nFROM value_counts\nWHERE rank = 1;"
    },
    "mysql": {
      "description": "MySQL 8.0+ window functions",
      "code": "-- Basic window functions (MySQL 8.0+)\nSELECT \n  product_id,\n  product_name,\n  category,\n  price,\n  AVG(price) OVER (PARTITION BY category) AS category_avg_price,\n  price - AVG(price) OVER (PARTITION BY category) AS price_deviation,\n  ROW_NUMBER() OVER (PARTITION BY category ORDER BY price DESC) AS price_rank_in_category\nFROM products;\n\n-- Running totals and cumulative sums\nSELECT \n  order_date,\n  order_id,\n  order_amount,\n  SUM(order_amount) OVER (ORDER BY order_date, order_id) AS running_total,\n  AVG(order_amount) OVER (\n    ORDER BY order_date\n    ROWS BETWEEN 6 PRECEDING AND CURRENT ROW\n  ) AS seven_day_avg\nFROM orders\nORDER BY order_date, order_id;\n\n-- Ranking functions\nSELECT \n  student_id,\n  student_name,\n  score,\n  RANK() OVER (ORDER BY score DESC) AS rank,\n  DENSE_RANK() OVER (ORDER BY score DESC) AS dense_rank,\n  PERCENT_RANK() OVER (ORDER BY score DESC) AS percent_rank,\n  CUME_DIST() OVER (ORDER BY score DESC) AS cumulative_distribution\nFROM exam_scores;\n\n-- LAG and LEAD for comparisons\nSELECT \n  date,\n  page_views,\n  LAG(page_views, 1) OVER (ORDER BY date) AS prev_day_views,\n  LEAD(page_views, 1) OVER (ORDER BY date) AS next_day_views,\n  page_views - LAG(page_views, 1) OVER (ORDER BY date) AS daily_change,\n  ROUND(\n    ((page_views - LAG(page_views, 1) OVER (ORDER BY date)) / \n     NULLIF(LAG(page_views, 1) OVER (ORDER BY date), 0)) * 100,\n    2\n  ) AS percent_change\nFROM website_analytics;\n\n-- Top N per group\nWITH ranked_products AS (\n  SELECT \n    category_id,\n    product_id,\n    product_name,\n    sales_count,\n    ROW_NUMBER() OVER (PARTITION BY category_id ORDER BY sales_count DESC) AS sales_rank\n  FROM product_sales\n)\nSELECT \n  category_id,\n  product_id,\n  product_name,\n  sales_count\nFROM ranked_products\nWHERE sales_rank <= 5;\n\n-- NTILE for quartiles/deciles\nSELECT \n  employee_id,\n  salary,\n  NTILE(4) OVER (ORDER BY salary) AS salary_quartile,\n  CASE NTILE(4) OVER (ORDER BY salary)\n    WHEN 1 THEN 'Q1 - Lowest 25%'\n    WHEN 2 THEN 'Q2 - Lower Middle 25%'\n    WHEN 3 THEN 'Q3 - Upper Middle 25%'\n    WHEN 4 THEN 'Q4 - Highest 25%'\n  END AS quartile_description\nFROM employees;\n\n-- Named window for reusability\nSELECT \n  order_id,\n  customer_id,\n  order_date,\n  order_amount,\n  SUM(order_amount) OVER w AS running_total,\n  AVG(order_amount) OVER w AS running_avg,\n  COUNT(*) OVER w AS order_count\nFROM orders\nWINDOW w AS (PARTITION BY customer_id ORDER BY order_date)\nORDER BY customer_id, order_date;"
    }
  }
}
