{
  "id": "messaging-design-pattern",
  "name": "Messaging Design Pattern (MDP)",
  "category": "Concurrency",
  "description": "Allows the interchange of information between components and applications",
  "when_to_use": "Distributed systems\nLoose coupling\nAsynchronous communication\nScalability",
  "benefits": "Loose coupling\nAsynchronous processing\nScalability\nReliability",
  "drawbacks": "Message ordering\nError handling\nDebugging complexity\nLatency",
  "use_cases": "Microservices\nEvent-driven systems\nMessage queues\nAPI integration",
  "complexity": "Medium",
  "tags": ["concurrency", "messaging", "distributed-systems", "asynchronous", "event-driven"],
  "examples": {
    "typescript": {
      "language": "typescript",
      "code": "// Messaging Design Pattern (MDP)\n// Allows interchange of information between components and applications\n\n// Message interface\ninterface Message {\n  id: string;\n  type: string;\n  payload: any;\n  timestamp: Date;\n  correlationId?: string;\n  headers?: Record<string, string>;\n}\n\n// Message bus - central hub for message routing\nclass MessageBus {\n  private subscribers: Map<string, Set<MessageHandler>> = new Map();\n  private middleware: Middleware[] = [];\n\n  // Subscribe to message types\n  subscribe(messageType: string, handler: MessageHandler): void {\n    if (!this.subscribers.has(messageType)) {\n      this.subscribers.set(messageType, new Set());\n    }\n    this.subscribers.get(messageType)!.add(handler);\n  }\n\n  // Unsubscribe from message types\n  unsubscribe(messageType: string, handler: MessageHandler): void {\n    const handlers = this.subscribers.get(messageType);\n    if (handlers) {\n      handlers.delete(handler);\n    }\n  }\n\n  // Publish message to all subscribers\n  async publish(message: Message): Promise<void> {\n    console.log(`Publishing message: ${message.type}`);\n\n    // Apply middleware\n    let processedMessage = message;\n    for (const middleware of this.middleware) {\n      processedMessage = await middleware.process(processedMessage);\n    }\n\n    // Route to subscribers\n    const handlers = this.subscribers.get(message.type);\n    if (handlers) {\n      const promises = Array.from(handlers).map(handler =>\n        handler.handle(processedMessage)\n      );\n      await Promise.allSettled(promises);\n    }\n  }\n\n  // Add middleware to processing pipeline\n  use(middleware: Middleware): void {\n    this.middleware.push(middleware);\n  }\n}\n\n// Message handler interface\ninterface MessageHandler {\n  handle(message: Message): Promise<void>;\n}\n\n// Middleware interface\ninterface Middleware {\n  process(message: Message): Promise<Message>;\n}\n\n// Concrete message types\nclass UserCreatedMessage implements Message {\n  id: string;\n  type: string = 'user.created';\n  payload: any;\n  timestamp: Date;\n  correlationId?: string;\n\n  constructor(userId: string, userData: any) {\n    this.id = `msg_${Date.now()}_${Math.random()}`;\n    this.payload = { userId, ...userData };\n    this.timestamp = new Date();\n  }\n}\n\nclass OrderPlacedMessage implements Message {\n  id: string;\n  type: string = 'order.placed';\n  payload: any;\n  timestamp: Date;\n  correlationId?: string;\n\n  constructor(orderId: string, orderData: any) {\n    this.id = `msg_${Date.now()}_${Math.random()}`;\n    this.payload = { orderId, ...orderData };\n    this.timestamp = new Date();\n  }\n}\n\n// Message handlers\nclass EmailNotificationHandler implements MessageHandler {\n  async handle(message: Message): Promise<void> {\n    if (message.type === 'user.created') {\n      const { userId, email } = message.payload;\n      console.log(`Sending welcome email to ${email}`);\n      await this.sendEmail(email, 'Welcome!', 'Thank you for joining us!');\n    }\n  }\n\n  private async sendEmail(to: string, subject: string, body: string): Promise<void> {\n    // Email sending logic\n    console.log(`Email sent to ${to}: ${subject}`);\n  }\n}\n\nclass InventoryUpdateHandler implements MessageHandler {\n  async handle(message: Message): Promise<void> {\n    if (message.type === 'order.placed') {\n      const { orderId, items } = message.payload;\n      console.log(`Updating inventory for order ${orderId}`);\n      for (const item of items) {\n        await this.updateStock(item.productId, -item.quantity);\n      }\n    }\n  }\n\n  private async updateStock(productId: string, change: number): Promise<void> {\n    // Inventory update logic\n    console.log(`Stock updated for ${productId}: ${change}`);\n  }\n}\n\nclass AnalyticsHandler implements MessageHandler {\n  async handle(message: Message): Promise<void> {\n    // Track all events for analytics\n    console.log(`Analytics: ${message.type} event recorded`);\n    await this.recordEvent(message);\n  }\n\n  private async recordEvent(message: Message): Promise<void> {\n    // Analytics recording logic\n  }\n}\n\n// Middleware implementations\nclass LoggingMiddleware implements Middleware {\n  async process(message: Message): Promise<Message> {\n    console.log(`[LOG] Processing message: ${message.type} at ${message.timestamp}`);\n    return message;\n  }\n}\n\nclass ValidationMiddleware implements Middleware {\n  async process(message: Message): Promise<Message> {\n    if (!message.id || !message.type || !message.payload) {\n      throw new Error('Invalid message format');\n    }\n    return message;\n  }\n}\n\nclass RetryMiddleware implements Middleware {\n  private maxRetries: number = 3;\n\n  async process(message: Message): Promise<Message> {\n    message.headers = message.headers || {};\n    message.headers.retryCount = (message.headers.retryCount || 0) + 1;\n    return message;\n  }\n}\n\n// Usage example\nasync function demonstrateMessagingPattern() {\n  const messageBus = new MessageBus();\n\n  // Add middleware\n  messageBus.use(new LoggingMiddleware());\n  messageBus.use(new ValidationMiddleware());\n  messageBus.use(new RetryMiddleware());\n\n  // Subscribe handlers\n  messageBus.subscribe('user.created', new EmailNotificationHandler());\n  messageBus.subscribe('user.created', new AnalyticsHandler());\n  messageBus.subscribe('order.placed', new InventoryUpdateHandler());\n  messageBus.subscribe('order.placed', new AnalyticsHandler());\n\n  // Publish messages\n  await messageBus.publish(new UserCreatedMessage('user-123', {\n    email: 'john@example.com',\n    name: 'John Doe'\n  }));\n\n  await messageBus.publish(new OrderPlacedMessage('order-456', {\n    items: [\n      { productId: 'prod-1', quantity: 2 },\n      { productId: 'prod-2', quantity: 1 }\n    ]\n  }));\n}\n\n// Advanced example: Request-Reply pattern\nclass RequestReplyBus extends MessageBus {\n  private pendingRequests: Map<string, { resolve: Function; reject: Function }> = new Map();\n\n  async request<T>(message: Message, timeout: number = 5000): Promise<T> {\n    return new Promise((resolve, reject) => {\n      // Set up timeout\n      const timeoutId = setTimeout(() => {\n        this.pendingRequests.delete(message.id);\n        reject(new Error('Request timeout'));\n      }, timeout);\n\n      // Store resolver\n      this.pendingRequests.set(message.id, {\n        resolve: (value: T) => {\n          clearTimeout(timeoutId);\n          this.pendingRequests.delete(message.id);\n          resolve(value);\n        },\n        reject: (error: Error) => {\n          clearTimeout(timeoutId);\n          this.pendingRequests.delete(message.id);\n          reject(error);\n        }\n      });\n\n      // Publish request\n      this.publish(message);\n    });\n  }\n\n  async reply(requestMessage: Message, response: any): Promise<void> {\n    const replyMessage: Message = {\n      id: `reply_${Date.now()}_${Math.random()}`,\n      type: `${requestMessage.type}.response`,\n      payload: response,\n      timestamp: new Date(),\n      correlationId: requestMessage.id\n    };\n\n    await this.publish(replyMessage);\n  }\n}\n\n// Request handler that can send replies\nclass CalculationHandler implements MessageHandler {\n  constructor(private replyBus: RequestReplyBus) {}\n\n  async handle(message: Message): Promise<void> {\n    if (message.type === 'calculate.sum') {\n      const { a, b } = message.payload;\n      const result = a + b;\n      await this.replyBus.reply(message, { result });\n    }\n  }\n}\n\n// Benefits of Messaging Design Pattern:\n// 1. Loose coupling between components\n// 2. Asynchronous communication\n// 3. Scalability through message queuing\n// 4. Reliability with guaranteed delivery\n// 5. Flexibility in message routing and processing"
    }
  }
}
