{
  "id": "operator-overloading",
  "name": "Operator Overloading Pattern",
  "category": "Structural",
  "description": "Custom operators for domain-specific operations to improve readability",
  "when_to_use": "Mathematical types, collections, DSLs, domain-specific languages",
  "benefits": "Expressive syntax, type safety, readability, domain modeling",
  "drawbacks": "Abuse potential, learning curve, debugging complexity, operator precedence",
  "use_cases": "Vectors, matrices, custom collections, DSLs, mathematical types",
  "complexity": "Medium",
  "tags": ["kotlin", "operator", "dsl", "domain-specific", "mathematical"],
  "examples": {
    "kotlin": {
      "language": "kotlin",
      "code": "data class Vector2D(val x: Double, val y: Double) {\n    operator fun plus(other: Vector2D) = Vector2D(x + other.x, y + other.y)\n    operator fun minus(other: Vector2D) = Vector2D(x - other.x, y - other.y)\n    operator fun times(scalar: Double) = Vector2D(x * scalar, y * scalar)\n    operator fun div(scalar: Double) = Vector2D(x / scalar, y / scalar)\n    operator fun unaryMinus() = Vector2D(-x, -y)\n    \n    // Dot product\n    operator fun times(other: Vector2D) = x * other.x + y * other.y\n    \n    override fun toString() = \"($x, $y)\"\n}\n\n// Usage\nval v1 = Vector2D(1.0, 2.0)\nval v2 = Vector2D(3.0, 4.0)\nval result = (v1 + v2) * 2.0 - v2 / 2.0\nval dotProduct = v1 * v2\n\n// Matrix operations\ndata class Matrix(val rows: List<List<Double>>) {\n    operator fun plus(other: Matrix): Matrix {\n        require(rows.size == other.rows.size && rows[0].size == other.rows[0].size)\n        return Matrix(rows.mapIndexed { i, row ->\n            row.mapIndexed { j, value -> value + other.rows[i][j] }\n        })\n    }\n    \n    operator fun times(other: Matrix): Matrix {\n        // Matrix multiplication implementation\n        val result = MutableList(rows.size) { MutableList(other.rows[0].size) { 0.0 } }\n        for (i in rows.indices) {\n            for (j in other.rows[0].indices) {\n                for (k in other.rows.indices) {\n                    result[i][j] += rows[i][k] * other.rows[k][j]\n                }\n            }\n        }\n        return Matrix(result)\n    }\n}\n\n// Custom collection with operators\nclass MoneyBag(private val amounts: MutableMap<Currency, Double> = mutableMapOf()) {\n    \n    operator fun plus(money: Money): MoneyBag {\n        val newAmounts = amounts.toMutableMap()\n        newAmounts[money.currency] = (newAmounts[money.currency] ?: 0.0) + money.amount\n        return MoneyBag(newAmounts)\n        \n    }\n    \n    operator fun plus(other: MoneyBag): MoneyBag {\n        val newAmounts = amounts.toMutableMap()\n        other.amounts.forEach { (currency, amount) ->\n            newAmounts[currency] = (newAmounts[currency] ?: 0.0) + amount\n        }\n        return MoneyBag(newAmounts)\n    }\n    \n    operator fun get(currency: Currency): Double {\n        return amounts[currency] ?: 0.0\n    }\n    \n    override fun toString(): String {\n        return amounts.entries.joinToString { \"${it.value} ${it.key}\" }\n    }\n}\n\ndata class Money(val amount: Double, val currency: Currency)\ndata class Currency(val code: String)\n\n// Usage\nval bag = MoneyBag()\nval updatedBag = bag + Money(100.0, Currency(\"USD\")) + Money(50.0, Currency(\"EUR\"))\nval usdAmount = updatedBag[Currency(\"USD\")] // 100.0\n\n// Range and contains\nclass DateRange(val start: LocalDate, val end: LocalDate) {\n    operator fun contains(date: LocalDate): Boolean {\n        return date >= start && date <= end\n    }\n    \n    operator fun iterator(): Iterator<LocalDate> {\n        return object : Iterator<LocalDate> {\n            var current = start\n            override fun hasNext() = current <= end\n            override fun next() = current.also { current = it.plusDays(1) }\n        }\n    }\n}\n\n// Usage\nval vacation = DateRange(LocalDate.of(2024, 7, 1), LocalDate.of(2024, 7, 15))\nval today = LocalDate.now()\nif (today in vacation) {\n    println(\"Enjoy your vacation!\")\n}\n\nfor (date in vacation) {\n    println(\"Vacation day: $date\")\n}\n\n// Function invocation operator\nclass Calculator {\n    operator fun invoke(expression: String): Double {\n        // Parse and calculate expression\n        return evaluate(expression)\n    }\n}\n\nval calc = Calculator()\nval result = calc(\"2 + 3 * 4\") // 14.0"
    }
  }
}
