{
  "id": "repository-pattern",
  "name": "Repository Pattern",
  "category": "Architectural",
  "description": "Encapsulates data access logic and provides a uniform interface",
  "when_to_use": "Data access abstraction\nMultiple data sources\nTesting isolation",
  "benefits": "Data source abstraction\nTestability\nCentralized queries\nConsistency",
  "drawbacks": "Additional abstraction layer\nPotential over-engineering\nQuery limitations",
  "use_cases": "Domain-driven design\nUnit testing\nMultiple databases",
  "complexity": "Medium",
  "tags": [
    "data-access",
    "abstraction",
    "testing"
  ],
  "examples": {
    "typescript": {
      "language": "typescript",
      "code": "// Repository: abstract data access logic\n\n// Domain Entity\ninterface User {\n  id: string;\n  email: string;\n  name: string;\n}\n\n// Repository Interface (port)\ninterface IUserRepository {\n  findById(id: string): Promise<User | null>;\n  findByEmail(email: string): Promise<User | null>;\n  save(user: User): Promise<void>;\n  delete(id: string): Promise<void>;\n}\n\n// Concrete Implementation\nclass UserRepository implements IUserRepository {\n  private db: any; // database connection\n  \n  async findById(id: string): Promise<User | null> {\n    // SQL: SELECT * FROM users WHERE id = ?\n    return this.db.query('SELECT * FROM users WHERE id = ?', [id]);\n  }\n  \n  async findByEmail(email: string): Promise<User | null> {\n    return this.db.query('SELECT * FROM users WHERE email = ?', [email]);\n  }\n  \n  async save(user: User): Promise<void> {\n    // SQL: INSERT or UPDATE\n    await this.db.query(\n      'INSERT INTO users (id, email, name) VALUES (?, ?, ?) ON CONFLICT (id) DO UPDATE',\n      [user.id, user.email, user.name]\n    );\n  }\n  \n  async delete(id: string): Promise<void> {\n    await this.db.query('DELETE FROM users WHERE id = ?', [id]);\n  }\n}\n\n// Business Logic uses repository (not direct DB)\nclass UserService {\n  constructor(private userRepo: IUserRepository) {}\n  \n  async getUser(id: string): Promise<User> {\n    const user = await this.userRepo.findById(id);\n    if (!user) throw new Error('User not found');\n    return user;\n  }\n}\n\n// Usage: swap implementations easily\nconst repo = new UserRepository();\nconst service = new UserService(repo);"
    }
  }
}