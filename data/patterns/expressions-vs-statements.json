{
  "id": "expressions-vs-statements",
  "name": "Expressions vs Statements Pattern",
  "category": "Functional",
  "description": "Using expressions for functional programming, immutability, and composability",
  "when_to_use": "Functional programming, conditional logic, assignments, side-effect free code",
  "benefits": "Immutability, composability, side-effect free, functional programming",
  "drawbacks": "Learning curve, performance for complex expressions, debugging",
  "use_cases": "Conditional logic, assignments, functional composition, pure functions",
  "complexity": "Low",
  "tags": ["functional", "kotlin", "expressions", "immutability", "composable"],
  "examples": {
    "kotlin": {
      "language": "kotlin",
      "code": "// Statement (imperative, side effects)\nvar result: String\nif (condition) {\n    result = \"true\"\n} else {\n    result = \"false\"\n}\n\n// Expression (functional, immutable)\nval result = if (condition) \"true\" else \"false\"\n\n// Try expression\nval config = try {\n    loadConfigFromFile()\n} catch (e: IOException) {\n    defaultConfig\n}\n\n// When expression\nval message = when (status) {\n    HttpStatus.OK -> \"Success\"\n    HttpStatus.ERROR -> \"Error occurred\"\n    HttpStatus.UNAUTHORIZED -> \"Access denied\"\n    else -> \"Unknown status: $status\"\n}\n\n// Expression in function\nfun getUserStatus(user: User): String = when {\n    user.isBanned -> \"Banned\"\n    user.isActive -> \"Active\"\n    user.lastLogin.isBefore(now().minusDays(30)) -> \"Inactive\"\n    else -> \"Pending\"\n}\n\n// Elvis operator expression\nval displayName = user.name ?: \"Unknown User\"\n\n// Safe call expression\nval email = user.contact?.email ?: \"no-email@example.com\"\n\n// Collection processing with expressions\nval processedUsers = users\n    .filter { it.age >= 18 }\n    .map { it.copy(name = it.name.uppercase()) }\n    .sortedBy { it.name }\n    .take(10)\n\n// Expression in data class\nsealed class Result<T>\ndata class Success<T>(val data: T) : Result<T>()\ndata class Error(val message: String) : Result<T>()\n\nfun <T> Result<T>.getOrDefault(default: T): T = when (this) {\n    is Success -> data\n    is Error -> default\n}\n\n// Expression in builder pattern\nclass QueryBuilder {\n    private var select = \"*\"\n    private var from = \"\"\n    private var where = \"\"\n    \n    fun select(fields: String) = apply { this.select = fields }\n    fun from(table: String) = apply { this.from = table }\n    fun where(condition: String) = apply { this.where = condition }\n    \n    fun build() = \"SELECT $select FROM $from WHERE $where\".trim()\n}\n\nval query = QueryBuilder()\n    .select(\"name, email\")\n    .from(\"users\")\n    .where(\"active = 1\")\n    .build()\n\n// Expression in validation\nfun validateEmail(email: String): ValidationResult =\n    if (email.contains(\"@\")) {\n        if (email.contains(\".\")) Valid else Invalid(\"Missing domain\")\n    } else {\n        Invalid(\"Missing @ symbol\")\n    }\n\n// Expression in state management\nsealed class UiState\ndata class Loading(val message: String = \"Loading...\") : UiState()\ndata class Success<T>(val data: T) : UiState()\ndata class Error(val error: Throwable) : UiState()\n\nfun updateUi(state: UiState, event: UiEvent): UiState = when (state) {\n    is Loading -> when (event) {\n        is DataLoaded -> Success(event.data)\n        is LoadError -> Error(event.error)\n        else -> state\n    }\n    is Success -> when (event) {\n        is RefreshRequested -> Loading(\"Refreshing...\")\n        else -> state\n    }\n    is Error -> when (event) {\n        is RetryRequested -> Loading()\n        else -> state\n    }\n}\n\n// Expression in DSL\nfun html(block: () -> String): String = \"<html>${block()}</html>\"\n\nfun body(block: () -> String): String = \"<body>${block()}</body>\"\n\nfun h1(text: String): String = \"<h1>$text</h1>\"\n\nval page = html {\n    body {\n        h1(\"Welcome\")\n    }\n}"
    }
  }
}
