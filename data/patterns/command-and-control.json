{
  "id": "command-and-control",
  "name": "Command and Control Pattern",
  "category": "Edge Computing",
  "description": "Implements reliable delivery of commands to IoT devices with retry and acknowledgment",
  "when_to_use": "Remote device management\nFirmware updates\nDevice configuration\nActivation/deactivation",
  "benefits": "Reliable delivery\nConfirmation\nOffline queuing\nAudit trail",
  "drawbacks": "Queue management\nLatency\nResource usage\nComplex state machine",
  "use_cases": "Remote device management\nFirmware updates\nDevice configuration\nActivation/deactivation",
  "complexity": "Medium",
  "tags": [
    "iot",
    "command",
    "control",
    "reliability"
  ],
  "examples": {
    "typescript": {
      "language": "typescript",
      "code": "// Command and Control: reliable device command delivery\n\ninterface Command {\n  id: string;\n  deviceId: string;\n  type: \"config\" | \"firmware\" | \"action\" | \"query\";\n  payload: Record<string, any>;\n  priority: \"low\" | \"normal\" | \"high\" | \"critical\";\n  createdAt: Date;\n  expiresAt?: Date;\n}\n\ninterface CommandDelivery {\n  commandId: string;\n  deviceId: string;\n  status: \"pending\" | \"delivered\" | \"acknowledged\" | \"failed\" | \"expired\";\n  attempts: number;\n  lastAttempt?: Date;\n  deliveryTime?: Date;\n  result?: CommandResult;\n}\n\ninterface CommandResult {\n  success: boolean;\n  output?: any;\n  error?: string;\n  timestamp: Date;\n}\n\nclass CommandService {\n  private commandQueue: PriorityCommandQueue;\n  private deliveryTracker: DeliveryTracker;\n  private deviceConnector: DeviceConnector;\n  private acknowledgementManager: AcknowledgementManager;\n\n  constructor(\n    commandQueue: PriorityCommandQueue,\n    deliveryTracker: DeliveryTracker,\n    deviceConnector: DeviceConnector,\n    acknowledgementManager: AcknowledgementManager\n  ) {\n    this.commandQueue = commandQueue;\n    this.deliveryTracker = deliveryTracker;\n    this.deviceConnector = deviceConnector;\n    this.acknowledgementManager = acknowledgementManager;\n  }\n\n  async sendCommand(\n    deviceId: string,\n    type: Command[\"type\"],\n    payload: Record<string, any>,\n    priority: Command[\"priority\"] = \"normal\",\n    expiryMs?: number\n  ): Promise<string> {\n    const command: Command = {\n      id: crypto.randomUUID(),\n      deviceId,\n      type,\n      payload,\n      priority,\n      createdAt: new Date(),\n      expiresAt: expiryMs ? new Date(Date.now() + expiryMs) : undefined\n    };\n\n    await this.commandQueue.enqueue(command, priority);\n    await this.deliveryTracker.track(command);\n\n    this.processCommands(deviceId);\n\n    return command.id;\n  }\n\n  private async processCommands(deviceId: string): Promise<void> {\n    while (true) {\n      const command = await this.commandQueue.dequeue(deviceId);\n      if (!command) break;\n\n      const delivery = await this.deliveryTracker.get(command.id);\n      if (delivery.attempts >= this.getMaxRetries(command.priority)) {\n        await this.handleFailure(command, \"Max retries exceeded\");\n        continue;\n      }\n\n      const success = await this.attemptDelivery(command);\n      if (success) {\n        await this.deliveryTracker.update(command.id, { status: \"delivered\" });\n      } else {\n        await this.scheduleRetry(command);\n      }\n    }\n  }\n\n  private async attemptDelivery(command: Command): Promise<boolean> {\n    try {\n      await this.deviceConnector.send(command.deviceId, command);\n      return true;\n    } catch (error).error(`Delivery {\n      console failed for command ${command.id}:`, error);\n      return false;\n    }\n  }\n\n  async acknowledge(commandId: string, result: CommandResult): Promise<void> {\n    const delivery = await this.deliveryTracker.get(commandId);\n    if (!delivery) {\n      throw new Error(\"Command not found\");\n    }\n\n    await this.deliveryTracker.update(commandId, {\n      status: \"acknowledged\",\n      result,\n      deliveryTime: new Date()\n    });\n\n    await this.acknowledgementManager.process(commandId, result);\n  }\n\n  async queryCommandStatus(commandId: string): Promise<CommandDelivery | null> {\n    return this.deliveryTracker.get(commandId);\n  }\n\n  async cancelCommand(commandId: string): Promise<CancellationResult> {\n    const delivery = await this.deliveryTracker.get(commandId);\n    if (!delivery) {\n      return { success: false, error: \"Command not found\" };\n    }\n\n    if (delivery.status === \"acknowledged\") {\n      return { success: false, error: \"Command already acknowledged\" };\n    }\n\n    await this.commandQueue.remove(commandId);\n    await this.deliveryTracker.update(commandId, { status: \"failed\" });\n\n    return { success: true, commandId };\n  }\n\n  private async handleFailure(command: Command, reason: string): Promise<void> {\n    await this.deliveryTracker.update(command.id, {\n      status: \"failed\",\n      result: { success: false, error: reason, timestamp: new Date() }\n    });\n  }\n\n  private async scheduleRetry(command: Command): Promise<void> {\n    const delivery = await this.deliveryTracker.get(command.id);\n    const backoffMs = this.calculateBackoff(delivery.attempts);\n\n    setTimeout(async () => {\n      await this.deliveryTracker.incrementAttempts(command.id);\n      await this.processCommands(command.deviceId);\n    }, backoffMs);\n  }\n\n  private calculateBackoff(attempts: number): number {\n    return Math.min(1000 * Math.pow(2, attempts), 60000);\n  }\n\n  private getMaxRetries(priority: Command[\"priority\"]): number {\n    switch (priority) {\n      case \"critical\": return 10;\n      case \"high\": return 5;\n      case \"normal\": return 3;\n      case \"low\": return 1;\n      default: return 3;\n    }\n  }\n\n  getPendingCommands(deviceId: string): Command[] {\n    return this.commandQueue.getPending(deviceId);\n  }\n}\n\nclass PriorityCommandQueue {\n  private queues: Map<string, Command[]> = new Map();\n\n  async enqueue(command: Command, priority: Command[\"priority\"]): Promise<void> {\n    const deviceQueue = this.queues.get(command.deviceId) || [];\n    deviceQueue.push(command);\n    this.queues.set(command.deviceId, deviceQueue);\n  }\n\n  async dequeue(deviceId: string): Promise<Command | null> {\n    const deviceQueue = this.queues.get(deviceId);\n    return deviceQueue?.shift() || null;\n  }\n\n  async remove(commandId: string): Promise<void> {}\n\n  getPending(deviceId: string): Command[] {\n    return this.queues.get(deviceId) || [];\n  }\n}\n\nclass DeliveryTracker {\n  private deliveries: Map<string, CommandDelivery> = new Map();\n\n  async track(command: Command): Promise<void> {\n    this.deliveries.set(command.id, {\n      commandId: command.id,\n      deviceId: command.deviceId,\n      status: \"pending\",\n      attempts: 0\n    });\n  }\n\n  async get(commandId: string): Promise<CommandDelivery | null> {\n    return this.deliveries.get(commandId) || null;\n  }\n\n  async update(commandId: string, updates: Partial<CommandDelivery>): Promise<void> {\n    const delivery = this.deliveries.get(commandId);\n    if (delivery) {\n      Object.assign(delivery, updates);\n    }\n  }\n\n  async incrementAttempts(commandId: string): Promise<void> {\n    const delivery = this.deliveries.get(commandId);\n    if (delivery) {\n      delivery.attempts++;\n      delivery.lastAttempt = new Date();\n    }\n  }\n}\n\ninterface DeviceConnector {\n  send(deviceId: string, command: Command): Promise<void>;\n}\n\ninterface AcknowledgementManager {\n  process(commandId: string, result: CommandResult): Promise<void>;\n}\n\ninterface CancellationResult {\n  success: boolean;\n  commandId?: string;\n  error?: string;\n}"
    }
  },
  "relationships": [
    {
      "target_pattern_id": "device-shadow",
      "type": "uses",
      "description": "Command and control often updates device shadow"
    },
    {
      "target_pattern_id": "retry-pattern",
      "type": "uses",
      "description": "Command delivery uses retry pattern for reliability"
    }
  ]
}
