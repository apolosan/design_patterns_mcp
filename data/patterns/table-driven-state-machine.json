{
  "id": "table-driven-state-machine",
  "name": "Table-Driven State Machine",
  "category": "Embedded Systems",
  "description": "Implements state machines using data tables for transitions and actions, separating logic from data for easier maintenance and modification",
  "when_to_use": "Complex state machines with many states and transitions\nSystems requiring runtime reconfiguration\nEmbedded systems with limited code space\nWhen state logic needs to be easily modifiable without code changes",
  "benefits": "Separation of logic and data\nEasier to modify and extend\nReduced code duplication\nBetter testability\nCompact representation",
  "drawbacks": "Table maintenance complexity\nDebugging can be harder\nMemory overhead for tables\nLimited expressiveness compared to code",
  "use_cases": "Protocol parsers\nDevice state management\nUser interface workflows\nCommunication state machines\nProcess control systems",
  "complexity": "Medium",
  "tags": ["embedded", "state-machine", "table-driven", "data-driven", "configurable"],
  "examples": {
    "c": {
      "language": "c",
      "code": "typedef enum {\n    STATE_INIT,\n    STATE_READY,\n    STATE_BUSY,\n    STATE_ERROR\n} State;\n\ntypedef enum {\n    EVENT_START,\n    EVENT_PROCESS,\n    EVENT_COMPLETE,\n    EVENT_FAIL\n} Event;\n\ntypedef void (*ActionFunc)(void);\n\ntypedef struct {\n    State next_state;\n    ActionFunc action;\n} Transition;\n\n// State transition table\nTransition state_table[4][4] = {\n    // EVENT_START, EVENT_PROCESS, EVENT_COMPLETE, EVENT_FAIL\n    { {STATE_READY, init_action}, {STATE_INIT, NULL}, {STATE_INIT, NULL}, {STATE_INIT, NULL} }, // STATE_INIT\n    { {STATE_READY, NULL}, {STATE_BUSY, start_process}, {STATE_READY, NULL}, {STATE_READY, NULL} }, // STATE_READY\n    { {STATE_BUSY, NULL}, {STATE_BUSY, NULL}, {STATE_READY, complete_process}, {STATE_ERROR, handle_error} }, // STATE_BUSY\n    { {STATE_INIT, reset_system}, {STATE_ERROR, NULL}, {STATE_ERROR, NULL}, {STATE_ERROR, NULL} }  // STATE_ERROR\n};\n\nState current_state = STATE_INIT;\n\nvoid process_event(Event event) {\n    Transition transition = state_table[current_state][event];\n    if (transition.action != NULL) {\n        transition.action();\n    }\n    current_state = transition.next_state;\n}\n\n// Action functions\nvoid init_action(void) { printf(\"Initializing...\\n\"); }\nvoid start_process(void) { printf(\"Starting process\\n\"); }\nvoid complete_process(void) { printf(\"Process completed\\n\"); }\nvoid handle_error(void) { printf(\"Error occurred\\n\"); }\nvoid reset_system(void) { printf(\"Resetting system\\n\"); }"
    },
    "typescript": {
      "language": "typescript",
      "code": "enum DeviceState {\n    INIT = 0,\n    READY = 1,\n    BUSY = 2,\n    ERROR = 3\n}\n\nenum DeviceEvent {\n    START = 0,\n    PROCESS = 1,\n    COMPLETE = 2,\n    FAIL = 3\n}\n\ntype ActionFunction = () => void;\n\ninterface Transition {\n    nextState: DeviceState;\n    action?: ActionFunction;\n}\n\n// State transition table\nconst stateTable: Transition[][] = [\n    // [START, PROCESS, COMPLETE, FAIL]\n    [\n        { nextState: DeviceState.READY, action: () => console.log('Initializing...') },\n        { nextState: DeviceState.INIT },\n        { nextState: DeviceState.INIT },\n        { nextState: DeviceState.INIT }\n    ], // INIT\n    [\n        { nextState: DeviceState.READY },\n        { nextState: DeviceState.BUSY, action: () => console.log('Starting process') },\n        { nextState: DeviceState.READY },\n        { nextState: DeviceState.READY }\n    ], // READY\n    [\n        { nextState: DeviceState.BUSY },\n        { nextState: DeviceState.BUSY },\n        { nextState: DeviceState.READY, action: () => console.log('Process completed') },\n        { nextState: DeviceState.ERROR, action: () => console.log('Error occurred') }\n    ], // BUSY\n    [\n        { nextState: DeviceState.INIT, action: () => console.log('Resetting system') },\n        { nextState: DeviceState.ERROR },\n        { nextState: DeviceState.ERROR },\n        { nextState: DeviceState.ERROR }\n    ]  // ERROR\n];\n\nclass TableDrivenStateMachine {\n    private currentState: DeviceState = DeviceState.INIT;\n    \n    processEvent(event: DeviceEvent): void {\n        const transition = stateTable[this.currentState][event];\n        if (transition.action) {\n            transition.action();\n        }\n        this.currentState = transition.nextState;\n    }\n    \n    getCurrentState(): DeviceState {\n        return this.currentState;\n    }\n}\n\n// Usage\nconst fsm = new TableDrivenStateMachine();\nfsm.processEvent(DeviceEvent.START);  // Initializes and moves to READY\nfsm.processEvent(DeviceEvent.PROCESS); // Starts process and moves to BUSY\nfsm.processEvent(DeviceEvent.COMPLETE); // Completes and moves to READY"
    }
  }
}
