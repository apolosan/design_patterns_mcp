{
  "id": "parallel-lists-pattern",
  "name": "Parallel Lists Pattern",
  "category": "Functional",
  "description": "Processes lists in parallel while preserving order and handling errors gracefully",
  "when_to_use": "Batch processing\nParallel IO\nScatter-gather patterns\nConcurrent operations",
  "benefits": "Parallel processing\nOrder preservation\nError aggregation\nComposability",
  "drawbacks": "Resource usage\nOverhead for small lists\nMemory consumption\nCoordination complexity",
  "use_cases": "Batch API calls\nParallel file processing\nConcurrent data fetching\nMap-reduce operations",
  "complexity": "Medium",
  "tags": [
    "functional",
    "parallel",
    "lists",
    "concurrency"
  ],
  "examples": {
    "typescript": {
      "language": "typescript",
      "code": "// Parallel Lists: parallel list processing with order preservation\n\ninterface ParallelResult<T, E> {\n  results: T[];\n  errors: E[];\n  completedAt: Date;\n}\n\ninterface ParallelConfig {\n  concurrency: number;\n  timeout: number;\n  retryAttempts: number;\n  retryDelay: number;\n}\n\nclass ParallelLists {\n  private config: ParallelConfig;\n\n  constructor(config: Partial<ParallelConfig> = {}) {\n    this.config = {\n      concurrency: config.concurrency ?? 10,\n      timeout: config.timeout ?? 30000,\n      retryAttempts: config.retryAttempts ?? 3,\n      retryDelay: config.retryDelay ?? 1000,\n    };\n  }\n\n  async mapParallel<T, U, E>(\n    items: T[],\n    mapper: (item: T, index: number) => Promise<U>,\n    errorHandler?: (error: E, item: T, index: number) => E\n  ): Promise<ParallelResult<U, E>> {\n    const results: U[] = new Array(items.length);\n    const errors: E[] = new Array(items.length);\n    const startTime = Date.now();\n\n    const chunks = this.chunkArray(items, this.config.concurrency);\n\n    for (const chunk of chunks) {\n      const chunkResults = await Promise.all(\n        chunk.map(async (item, chunkIndex) => {\n          const globalIndex = this.getGlobalIndex(chunks, chunk, chunkIndex);\n          try {\n            const result = await this.withTimeout(\n              mapper(item, globalIndex),\n              this.config.timeout\n            );\n            return { success: true, index: globalIndex, value: result };\n          } catch (error) {\n            const errorValue = errorHandler\n              ? errorHandler(error as E, item, globalIndex)\n              : (error as E);\n            return { success: false, index: globalIndex, error: errorValue };\n          }\n        })\n      );\n\n      for (const result of chunkResults) {\n        if (result.success) {\n          results[result.index] = result.value!;\n        } else {\n          errors[result.index] = result.error!;\n        }\n      }\n    }\n\n    return {\n      results: results.filter((_, i) => errors[i] === undefined),\n      errors: errors.filter(e => e !== undefined),\n      completedAt: new Date()\n    };\n  }\n\n  async mapParallelWithRetry<T, U, E>(\n    items: T[],\n    mapper: (item: T, index: number) => Promise<U>,\n    errorHandler?: (error: E, item: T, index: number) => E\n  ): Promise<ParallelResult<U, E>> {\n    const results: U[] = new Array(items.length);\n    const errors: E[] = new Array(items.length);\n\n    const processItem = async (item: T, index: number): Promise<U | E> => {\n      for (let attempt = 0; attempt < this.config.retryAttempts; attempt++) {\n        try {\n          return await mapper(item, index);\n        } catch (error) {\n          if (attempt === this.config.retryAttempts - 1) {\n            return errorHandler\n              ? errorHandler(error as E, item, index)\n              : (error as E);\n          }\n          await this.sleep(this.config.retryDelay * Math.pow(2, attempt));\n        }\n      }\n      throw new Error(\"Should not reach here\");\n    };\n\n    return this.mapParallel(items, processItem, errorHandler);\n  }\n\n  async scatterGather<T, R, E>(\n    items: T[],\n    gatherer: (results: T[]) => Promise<R>,\n    mapper: (item: T) => Promise<R>\n  ): Promise<R> {\n    const results = await this.mapParallel(items, mapper);\n    return gatherer(results.results);\n  }\n\n  async reduceParallel<T, U, E>(\n    items: T[],\n    reducer: (accumulator: U, current: T, index: number) => Promise<U>,\n    initialValue: U,\n    errorHandler?: (error: E, accumulator: U, item: T, index: number) => U\n  ): Promise<ParallelResult<U, E>> {\n    let accumulator = initialValue;\n    const errors: E[] = [];\n\n    for (let i = 0; i < items.length; i++) {\n      try {\n        accumulator = await this.withTimeout(\n          reducer(accumulator, items[i], i),\n          this.config.timeout\n        );\n      } catch (error) {\n        if (errorHandler) {\n          accumulator = errorHandler(error as E, accumulator, items[i], i);\n        } else {\n          errors.push(error as E);\n        }\n      }\n    }\n\n    return {\n      results: [accumulator],\n      errors,\n      completedAt: new Date()\n    };\n  }\n\n  private chunkArray<T>(array: T[], chunkSize: number): T[][] {\n    const chunks: T[][] = [];\n    for (let i = 0; i < array.length; i += chunkSize) {\n      chunks.push(array.slice(i, i + chunkSize));\n    }\n    return chunks;\n  }\n\n  private getGlobalIndex<T>(chunks: T[][], chunk: T[], chunkIndex: number): number {\n    let index = 0;\n    for (const c of chunks) {\n      if (c === chunk) break;\n      index += c.length;\n    }\n    return index + chunkIndex;\n  }\n\n  private async withTimeout<T>(promise: Promise<T>, timeout: number): Promise<T> {\n    return Promise.race([\n      promise,\n      new Promise<T>((_, reject) =>\n        setTimeout(() => reject(new Error(\"Timeout\")), timeout)\n      )\n    ]);\n  }\n\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n}\n\n// Example: parallel API calls\nasync function fetchUserData(userIds: string[]): Promise<UserData[]> {\n  const parallel = new ParallelLists({ concurrency: 5, timeout: 10000 });\n\n  const result = await parallel.mapParallel(\n    userIds,\n    async (userId, index) => {\n      const response = await fetch(`/api/users/${userId}`);\n      if (!response.ok) throw new Error(`Failed to fetch user ${userId}`);\n      return response.json();\n    }\n  );\n\n  if (result.errors.length > 0) {\n    console.error(`Failed to fetch ${result.errors.length} users`);\n  }\n\n  return result.results;\n}\n\n// Example: parallel file processing\nasync function processFiles(files: string[]): Promise<ProcessedFile[]> {\n  const parallel = new ParallelLists({ concurrency: 3 });\n\n  return parallel.mapParallel(\n    files,\n    async (file) => {\n      const content = await readFile(file);\n      return {\n        path: file,\n        size: content.length,\n        checksum: computeChecksum(content)\n      };\n    }\n  );\n}\n\ninterface UserData {\n  id: string;\n  name: string;\n  email: string;\n}\n\ninterface ProcessedFile {\n  path: string;\n  size: number;\n  checksum: string;\n}"
    }
  },
  "relationships": [
    {
      "target_pattern_id": "promise-all",
      "type": "uses",
      "description": "Parallel lists uses Promise.all for concurrency"
    },
    {
      "target_pattern_id": "result-type",
      "type": "complements",
      "description": "Parallel results can be wrapped in Result type"
    }
  ]
}
