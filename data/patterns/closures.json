{
  "id": "closures",
  "name": "Closures Pattern",
  "category": "Functional",
  "description": "Functions that capture and modify their environment, maintaining state between invocations",
  "when_to_use": "Encapsulation, callbacks, stateful operations, event handlers, builders",
  "benefits": "Encapsulation, flexibility, state management, composability",
  "drawbacks": "Memory leaks, debugging complexity, performance overhead",
  "use_cases": "Event handlers, builders, state machines, memoization, DSLs",
  "complexity": "Medium",
  "tags": ["functional", "kotlin", "closure", "stateful", "encapsulation"],
  "examples": {
    "kotlin": {
      "language": "kotlin",
      "code": "// Basic closure - capturing external variables\nfun createCounter(): () -> Int {\n    var count = 0\n    return { ++count } // Closure captures 'count'\n}\n\nval counter = createCounter()\nprintln(counter()) // 1\nprintln(counter()) // 2\nprintln(counter()) // 3\n\n// Multiple closures sharing state\nfun createStack(): Pair<() -> Unit, () -> Int?> {\n    val stack = mutableListOf<Int>()\n    \n    val push = { value: Int -> stack.add(value) }\n    val pop = { stack.removeLastOrNull() }\n    \n    return Pair(push, pop)\n}\n\nval (push, pop) = createStack()\npush(1)\npush(2)\npush(3)\nprintln(pop()) // 3\nprintln(pop()) // 2\n\n// Closure in event handling\nclass EventEmitter {\n    private val listeners = mutableListOf<(String) -> Unit>()\n    \n    fun onEvent(handler: (String) -> Unit) {\n        listeners.add(handler)\n    }\n    \n    fun emit(event: String) {\n        listeners.forEach { it(event) }\n    }\n}\n\nval emitter = EventEmitter()\nvar eventCount = 0\n\nemitter.onEvent { event ->\n    eventCount++\n    println(\"Event $eventCount: $event\")\n}\n\nemitter.emit(\"click\")\nemitter.emit(\"hover\")\n\n// Closure in builder pattern\nclass HtmlBuilder {\n    private val elements = mutableListOf<String>()\n    \n    fun div(block: HtmlBuilder.() -> Unit) {\n        val childBuilder = HtmlBuilder()\n        childBuilder.block() // 'this' is captured\n        elements.add(\"<div>${childBuilder.build()}</div>\")\n    }\n    \n    fun p(text: String) {\n        elements.add(\"<p>$text</p>\")\n    }\n    \n    fun build() = elements.joinToString(\"\")\n}\n\nfun html(block: HtmlBuilder.() -> Unit): String {\n    val builder = HtmlBuilder()\n    builder.block()\n    return builder.build()\n}\n\nval page = html {\n    div {\n        p(\"Hello\")\n        p(\"World\")\n    }\n}\n\n// Closure with memoization\nfun <A, R> memoize(function: (A) -> R): (A) -> R {\n    val cache = mutableMapOf<A, R>()\n    return { input ->\n        cache.getOrPut(input) { function(input) }\n    }\n}\n\nval expensiveCalculation = memoize { n: Int ->\n    println(\"Calculating fibonacci for $n\")\n    fibonacci(n)\n}\n\nprintln(expensiveCalculation(10)) // Calculates\nprintln(expensiveCalculation(10)) // Uses cache\nprintln(expensiveCalculation(5))  // Calculates\n\n// Closure in state machine\nsealed class State\nobject Idle : State()\ndata class Running(val task: String) : State()\ndata class Error(val message: String) : State()\n\nfun createStateMachine(): (String) -> State {\n    var currentState: State = Idle\n    \n    return { command ->\n        currentState = when (command) {\n            \"start\" -> when (currentState) {\n                is Idle -> Running(\"default task\")\n                else -> Error(\"Already running\")\n            }\n            \"stop\" -> when (currentState) {\n                is Running -> Idle\n                else -> Error(\"Not running\")\n            }\n            \"error\" -> Error(\"Simulated error\")\n            else -> Error(\"Unknown command\")\n        }\n        currentState\n    }\n}\n\nval stateMachine = createStateMachine()\nprintln(stateMachine(\"start\"))  // Running(default task)\nprintln(stateMachine(\"start\"))  // Error(Already running)\nprintln(stateMachine(\"stop\"))   // Idle\n\n// Closure capturing 'this' reference\nclass Calculator {\n    private var memory = 0.0\n    \n    fun add(value: Double) {\n        memory += value\n    }\n    \n    fun createOperation(): (Double) -> Double {\n        return { input -> \n            memory += input\n            memory\n        }\n    }\n}\n\nval calc = Calculator()\ncalc.add(10.0)\nval operation = calc.createOperation()\nprintln(operation(5.0)) // 15.0\nprintln(operation(3.0)) // 18.0\n\n// Closure with cleanup\nfun withResource(block: (Resource) -> Unit) {\n    val resource = Resource()\n    try {\n        block(resource)\n    } finally {\n        resource.close()\n    }\n}\n\nclass Resource {\n    private var isOpen = true\n    \n    fun use() {\n        if (!isOpen) throw IllegalStateException(\"Resource closed\")\n        println(\"Using resource\")\n    }\n    \n    fun close() {\n        if (isOpen) {\n            println(\"Closing resource\")\n            isOpen = false\n        }\n    }\n}\n\n// Usage\nwithResource { res ->\n    res.use()\n    // Resource automatically closed even if exception occurs\n}"
    }
  }
}
