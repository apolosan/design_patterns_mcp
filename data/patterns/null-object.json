{
  "id": "null-object",
  "name": "Null Object",
  "category": "Behavioral",
  "description": "Avoid null references by providing a default object",
  "when_to_use": "Defensive programming\nAvoid null checks\nConsistent behavior\nAPI design",
  "benefits": "No null checks\nConsistent behavior\nDefensive programming\nCleaner code",
  "drawbacks": "Hidden behavior\nTesting complexity\nMemory overhead",
  "use_cases": "Optional dependencies\nDefault behaviors\nError handling\nAPI design",
  "complexity": "Low",
  "tags": ["behavioral", "null-object", "defensive-programming", "default-behavior"],
  "examples": {
    "typescript": {
      "language": "typescript",
      "code": "// Null Object Pattern\n// Provides default behavior instead of null references\n\n// Abstract logger interface\ninterface Logger {\n  info(message: string): void;\n  error(message: string): void;\n  warn(message: string): void;\n}\n\n// Concrete logger implementation\nclass ConsoleLogger implements Logger {\n  info(message: string): void {\n    console.log(`[INFO] ${message}`);\n  }\n\n  error(message: string): void {\n    console.error(`[ERROR] ${message}`);\n  }\n\n  warn(message: string): void {\n    console.warn(`[WARN] ${message}`);\n  }\n}\n\n// Null Object - provides default behavior\nclass NullLogger implements Logger {\n  info(message: string): void {\n    // Do nothing - silent operation\n  }\n\n  error(message: string): void {\n    // Do nothing - silent operation\n  }\n\n  warn(message: string): void {\n    // Do nothing - silent operation\n  }\n}\n\n// Factory to create loggers\nclass LoggerFactory {\n  private static nullLogger = new NullLogger();\n\n  static create(enabled: boolean): Logger {\n    return enabled ? new ConsoleLogger() : this.nullLogger;\n  }\n\n  static createForEnvironment(): Logger {\n    const isProduction = process.env.NODE_ENV === 'production';\n    return this.create(!isProduction);\n  }\n}\n\n// Service that uses logger\nclass UserService {\n  constructor(private logger: Logger) {}\n\n  async createUser(userData: any) {\n    this.logger.info('Creating user...');\n\n    try {\n      // Simulate user creation\n      const user = await this.saveToDatabase(userData);\n      this.logger.info(`User created with ID: ${user.id}`);\n      return user;\n    } catch (error) {\n      this.logger.error(`Failed to create user: ${error.message}`);\n      throw error;\n    }\n  }\n\n  private async saveToDatabase(userData: any) {\n    // Simulate database operation\n    return { id: '123', ...userData };\n  }\n}\n\n// Usage examples\n\n// 1. Explicit null object\nclass Application {\n  private logger: Logger;\n  private userService: UserService;\n\n  constructor() {\n    // Use null object when logging is disabled\n    this.logger = LoggerFactory.create(false);\n    this.userService = new UserService(this.logger);\n  }\n}\n\n// 2. Environment-based configuration\nconst appLogger = LoggerFactory.createForEnvironment();\nconst appUserService = new UserService(appLogger);\n\n// 3. Optional dependency injection\nconst optionalLogger = process.env.LOGGING_ENABLED === 'true'\n  ? new ConsoleLogger()\n  : new NullLogger();\n\nconst serviceWithOptionalLogger = new UserService(optionalLogger);\n\n// Benefits of Null Object Pattern:\n// 1. No null checks needed - logger.info() always works\n// 2. Consistent behavior - no conditional logic\n// 3. Defensive programming - handles missing dependencies gracefully\n// 4. Cleaner code - no if (logger) checks\n\n// Advanced example with configuration\ninterface PaymentProcessor {\n  process(amount: number): Promise<string>;\n}\n\nclass StripeProcessor implements PaymentProcessor {\n  async process(amount: number): Promise<string> {\n    // Real payment processing\n    return `stripe_tx_${Date.now()}`;\n  }\n}\n\nclass NullPaymentProcessor implements PaymentProcessor {\n  async process(amount: number): Promise<string> {\n    // Return fake transaction ID for testing\n    return `null_tx_${Date.now()}`;\n  }\n}\n\nclass PaymentService {\n  constructor(private processor: PaymentProcessor) {}\n\n  async charge(amount: number): Promise<string> {\n    return this.processor.process(amount);\n  }\n}\n\n// Factory for payment processors\nconst PaymentProcessorFactory = {\n  create(testMode: boolean): PaymentProcessor {\n    return testMode ? new NullPaymentProcessor() : new StripeProcessor();\n  }\n};\n\n// Usage in tests\nconst testPaymentService = new PaymentService(\n  PaymentProcessorFactory.create(true) // Use null object for testing\n);\n\nconst realPaymentService = new PaymentService(\n  PaymentProcessorFactory.create(false) // Use real processor for production\n);"
    }
  }
}
