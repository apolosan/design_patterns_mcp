{
  "id": "sql-json-data-handling",
  "name": "JSON Data Handling Pattern",
  "category": "Data Query",
  "description": "Stores, queries, and manipulates JSON data within relational databases. Modern SQL databases provide native JSON functions for parsing, querying, and modifying JSON documents, enabling hybrid relational-document data models. Essential for flexible schemas, API integrations, and semi-structured data.",
  "when_to_use": "[\"Store semi-structured or variable-schema data\",\"Handle API responses in database\",\"Flexible attribute storage (EAV alternative)\",\"Audit logs and event data\",\"User preferences and settings\",\"Integrate with NoSQL-style data\"]",
  "benefits": "[\"Flexible schema without ALTER TABLE\",\"Reduces need for many-to-many tables\",\"Native indexing on JSON paths\",\"Query and update nested data\",\"Better than serialized text/XML\",\"Maintains ACID compliance\"]",
  "drawbacks": "[\"Can impact query performance\",\"Less efficient than normalized tables\",\"JSON validation overhead\",\"Harder to maintain data integrity\",\"Index strategy more complex\"]",
  "use_cases": "[\"Product catalogs with variable attributes\",\"User profiles and preferences\",\"Event and audit logging\",\"API data storage\",\"Configuration and metadata\",\"Multi-tenant application data\"]",
  "complexity": "Medium",
  "tags": ["sql", "json", "semi-structured", "document-store", "nosql", "flexible-schema"],
  "examples": {
    "tsql": {
      "description": "SQL Server JSON functions including ISJSON, JSON_VALUE, JSON_QUERY, OPENJSON, FOR JSON",
      "code": "-- Validate JSON\nSELECT \n  OrderID,\n  Metadata,\n  ISJSON(Metadata) AS IsValidJSON\nFROM Orders;\n\n-- Extract scalar values with JSON_VALUE\nSELECT \n  ProductID,\n  ProductName,\n  Attributes,\n  JSON_VALUE(Attributes, '$.color') AS Color,\n  JSON_VALUE(Attributes, '$.size') AS Size,\n  JSON_VALUE(Attributes, '$.weight') AS Weight,\n  CAST(JSON_VALUE(Attributes, '$.price') AS DECIMAL(10,2)) AS Price\nFROM Products\nWHERE JSON_VALUE(Attributes, '$.category') = 'Electronics';\n\n-- Extract JSON object or array with JSON_QUERY\nSELECT \n  UserID,\n  Preferences,\n  JSON_QUERY(Preferences, '$.notifications') AS NotificationSettings,\n  JSON_QUERY(Preferences, '$.tags') AS UserTags\nFROM UserProfiles;\n\n-- Parse JSON into table with OPENJSON\nDECLARE @json NVARCHAR(MAX) = N'[\n  {\"name\": \"John\", \"age\": 30, \"city\": \"Seattle\"},\n  {\"name\": \"Jane\", \"age\": 25, \"city\": \"Portland\"}\n]';\n\nSELECT *\nFROM OPENJSON(@json)\nWITH (\n  name NVARCHAR(50) '$.name',\n  age INT '$.age',\n  city NVARCHAR(50) '$.city'\n);\n\n-- Nested JSON parsing\nDECLARE @order NVARCHAR(MAX) = N'{\n  \"orderId\": 123,\n  \"customer\": {\"name\": \"John Doe\", \"email\": \"john@example.com\"},\n  \"items\": [\n    {\"product\": \"Laptop\", \"quantity\": 1, \"price\": 999.99},\n    {\"product\": \"Mouse\", \"quantity\": 2, \"price\": 29.99}\n  ]\n}';\n\nSELECT \n  JSON_VALUE(@order, '$.orderId') AS OrderID,\n  JSON_VALUE(@order, '$.customer.name') AS CustomerName,\n  JSON_VALUE(@order, '$.customer.email') AS CustomerEmail;\n\nSELECT product, quantity, price\nFROM OPENJSON(@order, '$.items')\nWITH (\n  product NVARCHAR(50),\n  quantity INT,\n  price DECIMAL(10,2)\n);\n\n-- Generate JSON output with FOR JSON\nSELECT \n  CustomerID,\n  CustomerName,\n  Email\nFROM Customers\nWHERE Country = 'USA'\nFOR JSON PATH;\n\n-- FOR JSON with nested structure\nSELECT \n  c.CustomerID,\n  c.CustomerName,\n  c.Email,\n  (\n    SELECT \n      o.OrderID,\n      o.OrderDate,\n      o.TotalAmount\n    FROM Orders o\n    WHERE o.CustomerID = c.CustomerID\n    FOR JSON PATH\n  ) AS Orders\nFROM Customers c\nFOR JSON PATH;\n\n-- JSON_MODIFY to update JSON\nUPDATE Products\nSET Attributes = JSON_MODIFY(\n  Attributes,\n  '$.price',\n  CAST(JSON_VALUE(Attributes, '$.price') AS DECIMAL(10,2)) * 1.1\n)\nWHERE JSON_VALUE(Attributes, '$.category') = 'Electronics';\n\n-- Add new property to JSON\nUPDATE UserProfiles\nSET Preferences = JSON_MODIFY(\n  ISNULL(Preferences, '{}'),\n  '$.lastUpdated',\n  CONVERT(VARCHAR(25), GETDATE(), 127)\n)\nWHERE UserID = 123;\n\n-- Create computed column for JSON path\nALTER TABLE Products\nADD ProductColor AS JSON_VALUE(Attributes, '$.color');\n\nCREATE INDEX IX_Products_Color ON Products(ProductColor);"
    },
    "postgresql": {
      "description": "PostgreSQL JSON/JSONB functions with powerful querying and indexing",
      "code": "-- JSON vs JSONB (use JSONB for better performance)\nCREATE TABLE products (\n  id SERIAL PRIMARY KEY,\n  name VARCHAR(100),\n  attributes JSONB  -- Binary JSON, supports indexing\n);\n\n-- Extract values with -> and ->>\n-- -> returns JSON, ->> returns text\nSELECT \n  id,\n  name,\n  attributes->>'color' AS color,  -- Text output\n  attributes->'price' AS price_json,  -- JSON output\n  (attributes->>'price')::DECIMAL AS price_numeric\nFROM products\nWHERE attributes->>'category' = 'Electronics';\n\n-- Nested JSON navigation\nSELECT \n  id,\n  attributes->'specs'->>'cpu' AS cpu,\n  attributes->'specs'->>'ram' AS ram,\n  attributes#>>'{specs,storage}' AS storage  -- Alternative syntax\nFROM products;\n\n-- JSON array operations\nSELECT \n  id,\n  name,\n  attributes->'tags' AS all_tags,\n  attributes->'tags'->0 AS first_tag,  -- Array indexing\n  jsonb_array_length(attributes->'tags') AS tag_count\nFROM products;\n\n-- Check JSON containment with @>\nSELECT * FROM products\nWHERE attributes @> '{\"category\": \"Electronics\", \"brand\": \"Apple\"}';\n\n-- Check if JSON key exists\nSELECT * FROM products\nWHERE attributes ? 'warranty'\n  AND attributes ?& ARRAY['color', 'size'];  -- Has all keys\n\n-- Expand JSON array to rows\nSELECT \n  id,\n  jsonb_array_elements_text(attributes->'tags') AS tag\nFROM products;\n\n-- Parse JSON with jsonb_to_record\nSELECT *\nFROM jsonb_to_record('{\"name\":\"John\",\"age\":30,\"city\":\"Seattle\"}'::JSONB)\n  AS x(name TEXT, age INT, city TEXT);\n\n-- Build JSON objects and arrays\nSELECT \n  customer_id,\n  jsonb_build_object(\n    'name', customer_name,\n    'email', email,\n    'total_orders', COUNT(order_id),\n    'total_spent', SUM(order_total)\n  ) AS customer_summary\nFROM customers c\nLEFT JOIN orders o ON c.customer_id = o.customer_id\nGROUP BY c.customer_id, c.customer_name, c.email;\n\n-- Aggregate into JSON\nSELECT \n  category,\n  jsonb_agg(jsonb_build_object(\n    'id', product_id,\n    'name', product_name,\n    'price', price\n  )) AS products\nFROM products\nGROUP BY category;\n\n-- Update JSONB with jsonb_set\nUPDATE products\nSET attributes = jsonb_set(\n  attributes,\n  '{price}',\n  to_jsonb((attributes->>'price')::DECIMAL * 1.1)\n)\nWHERE attributes->>'category' = 'Electronics';\n\n-- Merge JSON objects\nUPDATE user_profiles\nSET preferences = preferences || '{\"theme\": \"dark\", \"notifications\": true}'::JSONB\nWHERE user_id = 123;\n\n-- Remove JSON key\nUPDATE products\nSET attributes = attributes - 'temporary_field'\nWHERE attributes ? 'temporary_field';\n\n-- GIN index for JSONB (fast containment queries)\nCREATE INDEX idx_products_attributes ON products USING GIN (attributes);\n\n-- Index specific JSON path\nCREATE INDEX idx_products_category ON products ((attributes->>'category'));\n\n-- Full-text search on JSON\nCREATE INDEX idx_products_description_fts ON products\n  USING GIN (to_tsvector('english', attributes->>'description'));\n\nSELECT *\nFROM products\nWHERE to_tsvector('english', attributes->>'description') @@ to_tsquery('laptop & gaming');"
    },
    "mysql": {
      "description": "MySQL 5.7+ JSON functions for storing and querying JSON data",
      "code": "-- Create table with JSON column\nCREATE TABLE products (\n  id INT AUTO_INCREMENT PRIMARY KEY,\n  name VARCHAR(100),\n  attributes JSON\n);\n\n-- Extract JSON values\nSELECT \n  id,\n  name,\n  JSON_EXTRACT(attributes, '$.color') AS color,\n  attributes->>'$.price' AS price,  -- Shorthand syntax\n  attributes->'$.specs' AS specs\nFROM products;\n\n-- Query JSON with WHERE\nSELECT *\nFROM products\nWHERE JSON_EXTRACT(attributes, '$.category') = 'Electronics'\n  AND JSON_EXTRACT(attributes, '$.price') > 500;\n\n-- Check if JSON path exists\nSELECT *\nFROM products\nWHERE JSON_CONTAINS_PATH(attributes, 'one', '$.warranty', '$.guarantee');\n\n-- Check if JSON contains value\nSELECT *\nFROM products\nWHERE JSON_CONTAINS(attributes, '\"Electronics\"', '$.category');\n\n-- JSON array functions\nSELECT \n  id,\n  JSON_LENGTH(attributes->'$.tags') AS tag_count,\n  JSON_EXTRACT(attributes, '$.tags[0]') AS first_tag,\n  JSON_SEARCH(attributes, 'one', 'premium', NULL, '$.tags[*]') AS premium_tag_path\nFROM products;\n\n-- Expand JSON array to table\nSELECT \n  p.id,\n  p.name,\n  jt.tag\nFROM products p\nCROSS JOIN JSON_TABLE(\n  p.attributes,\n  '$.tags[*]' COLUMNS(\n    tag VARCHAR(50) PATH '$'\n  )\n) AS jt;\n\n-- Parse complex JSON with JSON_TABLE\nSELECT *\nFROM JSON_TABLE(\n  '[\n    {\"name\": \"John\", \"age\": 30, \"city\": \"Seattle\"},\n    {\"name\": \"Jane\", \"age\": 25, \"city\": \"Portland\"}\n  ]',\n  '$[*]' COLUMNS(\n    name VARCHAR(50) PATH '$.name',\n    age INT PATH '$.age',\n    city VARCHAR(50) PATH '$.city'\n  )\n) AS people;\n\n-- Update JSON values\nUPDATE products\nSET attributes = JSON_SET(\n  attributes,\n  '$.price',\n  JSON_EXTRACT(attributes, '$.price') * 1.1\n)\nWHERE JSON_EXTRACT(attributes, '$.category') = 'Electronics';\n\n-- Insert new key into JSON\nUPDATE products\nSET attributes = JSON_INSERT(\n  attributes,\n  '$.lastUpdated',\n  NOW()\n)\nWHERE id = 123;\n\n-- Replace existing key\nUPDATE products\nSET attributes = JSON_REPLACE(\n  attributes,\n  '$.status',\n  'active'\n)\nWHERE JSON_EXTRACT(attributes, '$.status') = 'pending';\n\n-- Remove JSON key\nUPDATE products\nSET attributes = JSON_REMOVE(attributes, '$.temporary')\nWHERE JSON_CONTAINS_PATH(attributes, 'one', '$.temporary');\n\n-- Merge JSON objects\nUPDATE user_preferences\nSET settings = JSON_MERGE_PATCH(\n  settings,\n  '{\"theme\": \"dark\", \"notifications\": true}'\n)\nWHERE user_id = 123;\n\n-- Generate JSON output\nSELECT JSON_OBJECT(\n  'id', customer_id,\n  'name', customer_name,\n  'email', email,\n  'orders', (\n    SELECT JSON_ARRAYAGG(\n      JSON_OBJECT(\n        'orderId', order_id,\n        'date', order_date,\n        'total', order_total\n      )\n    )\n    FROM orders\n    WHERE orders.customer_id = customers.customer_id\n  )\n) AS customer_json\nFROM customers\nWHERE customer_id = 123;\n\n-- Virtual generated column for JSON path\nALTER TABLE products\nADD COLUMN product_color VARCHAR(50) \n  GENERATED ALWAYS AS (JSON_UNQUOTE(JSON_EXTRACT(attributes, '$.color'))) STORED;\n\nCREATE INDEX idx_product_color ON products(product_color);\n\n-- Multi-valued index (MySQL 8.0.17+)\nCREATE INDEX idx_product_tags ON products(\n  (CAST(attributes->'$.tags' AS CHAR(255) ARRAY))\n);"
    }
  }
}
