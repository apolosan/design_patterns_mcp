{
  "id": "tokenization",
  "name": "Tokenization Pattern",
  "category": "Blockchain",
  "description": "Represents real-world assets as blockchain tokens enabling fractional ownership and programmability",
  "when_to_use": "Real estate tokenization\nArt and collectibles\nSecurities (with compliance)\nLoyalty points",
  "benefits": "Fractional ownership\nLiquidity\nProgrammability\nTransparency\nGlobal access",
  "drawbacks": "Regulatory complexity\nCustody concerns\nValuation challenges\nLegal integration",
  "use_cases": "Real estate\nArt investment\nSecurities tokenization\nSupply chain",
  "complexity": "High",
  "tags": [
    "blockchain",
    "tokenization",
    "nft",
    "digital-assets"
  ],
  "examples": {
    "typescript": {
      "language": "typescript",
      "code": "// Tokenization: represent real-world assets on blockchain\n\ninterface TokenizedAsset {\n  id: string;\n  assetType: \"real-estate\" | \"art\" | \"securities\" | \"commodity\" | \"utility\";\n  metadata: AssetMetadata;\n  totalSupply: number;\n  decimals: number;\n  ownership: TokenOwnership[];\n  compliance: ComplianceInfo;\n}\n\ninterface AssetMetadata {\n  name: string;\n  description: string;\n  imageUrl: string;\n  attributes: Record<string, any>;\n  valuation: Valuation;\n}\n\ninterface TokenOwnership {\n  holder: string;\n  balance: number;\n  lockedUntil?: Date;\n}\n\ninterface ComplianceInfo {\n  jurisdiction: string;\n  kycRequired: boolean;\n  transferRestrictions: string[];\n  expirationDate?: Date;\n}\n\nclass AssetTokenizationService {\n  private tokens: Map<string, TokenizedAsset> = new Map();\n  private registry: TokenRegistry;\n  private complianceService: ComplianceService;\n  private blockchain: BlockchainClient;\n\n  constructor(registry: TokenRegistry, complianceService: ComplianceService, blockchain: BlockchainClient) {\n    this.registry = registry;\n    this.complianceService = complianceService;\n    this.blockchain = blockchain;\n  }\n\n  async tokenizeAsset(\n    assetType: TokenizedAsset[\"assetType\"],\n    metadata: AssetMetadata,\n    totalSupply: number,\n    decimals: number = 0,\n    compliance: ComplianceInfo\n  ): Promise<string> {\n    const assetId = crypto.randomUUID();\n\n    const token: TokenizedAsset = {\n      id: assetId,\n      assetType,\n      metadata,\n      totalSupply,\n      decimals,\n      ownership: [],\n      compliance\n    };\n\n    await this.registry.register(assetId, token);\n\n    await this.blockchain.deployToken({\n      name: metadata.name,\n      symbol: this.generateSymbol(metadata.name),\n      totalSupply,\n      decimals\n    });\n\n    this.tokens.set(assetId, token);\n\n    return assetId;\n  }\n\n  async issueTokens(assetId: string, recipient: string, amount: number): Promise<IssueResult> {\n    const asset = this.tokens.get(assetId);\n    if (!asset) {\n      return { success: false, error: \"Asset not found\" };\n    }\n\n    const isCompliant = await this.complianceService.verifyCompliance(recipient, asset.compliance);\n    if (!isCompliant) {\n      return { success: false, error: \"Recipient not compliant\" };\n    }\n\n    await this.blockchain.mint(assetId, recipient, amount);\n\n    asset.ownership.push({\n      holder: recipient,\n      balance: (asset.ownership.find(o => o.holder === recipient)?.balance || 0) + amount\n    });\n\n    return { success: true, assetId, recipient, amount };\n  }\n\n  async transfer(\n    assetId: string,\n    from: string,\n    to: string,\n    amount: number\n  ): Promise<TransferResult> {\n    const asset = this.tokens.get(assetId);\n    if (!asset) {\n      return { success: false, error: \"Asset not found\" };\n    }\n\n    const isCompliant = await this.complianceService.verifyCompliance(to, asset.compliance);\n    if (!isCompliant) {\n      return { success: false, error: \"Recipient not compliant\" };\n    }\n\n    await this.blockchain.transfer(assetId, from, to, amount);\n\n    return { success: true, assetId, from, to, amount };\n  }\n\n  async fractionalize(\n    assetId: string,\n    fractions: number\n  ): Promise<FractionalizationResult> {\n    const asset = this.tokens.get(assetId);\n    if (!asset) {\n      return { success: false, error: \"Asset not found\" };\n    }\n\n    const fractionValue = asset.metadata.valuation.totalValue / fractions;\n\n    await this.blockchain.mint(assetId, \"\", fractions);\n\n    return {\n      success: true,\n      assetId,\n      totalFractions: fractions,\n      valuePerFraction: fractionValue\n    };\n  }\n\n  async redeem(\n    assetId: string,\n    holder: string,\n    fractionAmount: number\n  ): Promise<RedemptionResult> {\n    const asset = this.tokens.get(assetId);\n    if (!asset) {\n      return { success: false, error: \"Asset not found\" };\n    }\n\n    const holderOwnership = asset.ownership.find(o => o.holder === holder);\n    if (!holderOwnership || holderOwnership.balance < fractionAmount) {\n      return { success: false, error: \"Insufficient balance\" };\n    }\n\n    await this.blockchain.burn(assetId, holder, fractionAmount);\n\n    const redemptionValue = (asset.metadata.valuation.totalValue / asset.totalSupply) * fractionAmount;\n\n    return {\n      success: true,\n      assetId,\n      redeemedAmount: fractionAmount,\n      redemptionValue\n    };\n  }\n\n  private generateSymbol(name: string): string {\n    return name.substring(0, 4).toUpperCase() + \"T\";\n  }\n\n  getAsset(assetId: string): TokenizedAsset | undefined {\n    return this.tokens.get(assetId);\n  }\n\n  getOwnership(assetId: string): TokenOwnership[] {\n    return this.tokens.get(assetId)?.ownership || [];\n  }\n}\n\ninterface TokenRegistry {\n  register(id: string, token: TokenizedAsset): Promise<void>;\n  get(id: string): Promise<TokenizedAsset | null>;\n}\n\ninterface ComplianceService {\n  verifyCompliance(holder: string, compliance: ComplianceInfo): Promise<boolean>;\n}\n\ninterface BlockchainClient {\n  deployToken(config: any): Promise<void>;\n  mint(assetId: string, to: string, amount: number): Promise<void>;\n  transfer(assetId: string, from: string, to: string, amount: number): Promise<void>;\n  burn(assetId: string, from: string, amount: number): Promise<void>;\n}\n\ninterface IssueResult {\n  success: boolean;\n  assetId?: string;\n  recipient?: string;\n  amount?: number;\n  error?: string;\n}\n\ninterface TransferResult {\n  success: boolean;\n  assetId?: string;\n  from?: string;\n  to?: string;\n  amount?: number;\n  error?: string;\n}\n\ninterface FractionalizationResult {\n  success: boolean;\n  assetId?: string;\n  totalFractions?: number;\n  valuePerFraction?: number;\n  error?: string;\n}\n\ninterface RedemptionResult {\n  success: boolean;\n  assetId?: string;\n  redeemedAmount?: number;\n  redemptionValue?: number;\n  error?: string;\n}\n\ninterface Valuation {\n  totalValue: number;\n  currency: string;\n  valuationDate: Date;\n  valuationMethod: string;\n}"
    }
  },
  "relationships": [
    {
      "target_pattern_id": "smart-contract-pattern",
      "type": "uses",
      "description": "Tokenization is typically implemented as smart contract"
    },
    {
      "target_pattern_id": "multi-signature",
      "type": "complements",
      "description": "Multi-sig can govern tokenized asset management"
    }
  ]
}
