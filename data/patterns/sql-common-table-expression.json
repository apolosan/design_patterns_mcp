{
  "id": "sql-common-table-expression",
  "name": "Common Table Expression (CTE) Pattern",
  "category": "Data Query",
  "description": "Defines temporary named result sets using WITH clause that can be referenced within SELECT, INSERT, UPDATE, or DELETE statements. CTEs improve query readability, enable recursive queries, and help break complex queries into manageable logical steps. Particularly powerful for hierarchical data traversal.",
  "when_to_use": "[\"Simplify complex queries with multiple subqueries\",\"Improve query readability and maintainability\",\"Process hierarchical or recursive data\",\"Reuse same subquery multiple times\",\"Create step-by-step query logic\",\"Replace derived tables for better clarity\"]",
  "benefits": "[\"Greatly improves code readability\",\"Can be referenced multiple times in query\",\"Enables recursive queries for hierarchical data\",\"Easier to debug than nested subqueries\",\"Supports forward references between CTEs\",\"Better performance than multiple subqueries in some cases\"]",
  "drawbacks": "[\"May not be materialized (re-executed each time)\",\"Can impact performance if not optimized\",\"Recursive CTEs need termination conditions\",\"Not all databases optimize CTEs equally\"]",
  "use_cases": "[\"Organizational hierarchies (manager-employee)\",\"Bill of materials (BOM) structures\",\"File system directory traversal\",\"Social network graph traversal\",\"Breaking complex reports into steps\",\"Recursive calculations (Fibonacci, factorials)\"]",
  "complexity": "Medium",
  "tags": ["sql", "cte", "with-clause", "recursive", "hierarchical-data", "query-organization", "readability"],
  "examples": {
    "tsql": {
      "description": "T-SQL CTEs including recursive CTEs for hierarchical data",
      "code": "-- Simple CTE for better readability\nWITH CustomerOrders AS (\n  SELECT \n    CustomerID,\n    COUNT(*) AS OrderCount,\n    SUM(TotalAmount) AS TotalSpent\n  FROM Orders\n  WHERE OrderDate >= '2024-01-01'\n  GROUP BY CustomerID\n)\nSELECT \n  c.CustomerID,\n  c.CustomerName,\n  co.OrderCount,\n  co.TotalSpent,\n  co.TotalSpent / co.OrderCount AS AvgOrderValue\nFROM Customers c\nINNER JOIN CustomerOrders co ON c.CustomerID = co.CustomerID\nWHERE co.OrderCount >= 5\nORDER BY co.TotalSpent DESC;\n\n-- Multiple CTEs (comma-separated)\nWITH \nActiveCustomers AS (\n  SELECT CustomerID, CustomerName, Region\n  FROM Customers\n  WHERE IsActive = 1\n),\nRecentOrders AS (\n  SELECT CustomerID, OrderDate, TotalAmount\n  FROM Orders\n  WHERE OrderDate >= DATEADD(MONTH, -3, GETDATE())\n),\nCustomerStats AS (\n  SELECT \n    CustomerID,\n    COUNT(*) AS OrderCount,\n    MAX(OrderDate) AS LastOrderDate,\n    SUM(TotalAmount) AS Revenue\n  FROM RecentOrders\n  GROUP BY CustomerID\n)\nSELECT \n  ac.CustomerID,\n  ac.CustomerName,\n  ac.Region,\n  cs.OrderCount,\n  cs.LastOrderDate,\n  cs.Revenue\nFROM ActiveCustomers ac\nLEFT JOIN CustomerStats cs ON ac.CustomerID = cs.CustomerID;\n\n-- Recursive CTE for organizational hierarchy\nWITH EmployeeHierarchy AS (\n  -- Anchor member: Top-level employees (no manager)\n  SELECT \n    EmployeeID,\n    EmployeeName,\n    ManagerID,\n    JobTitle,\n    1 AS Level,\n    CAST(EmployeeName AS NVARCHAR(MAX)) AS HierarchyPath\n  FROM Employees\n  WHERE ManagerID IS NULL\n  \n  UNION ALL\n  \n  -- Recursive member: Employees with managers\n  SELECT \n    e.EmployeeID,\n    e.EmployeeName,\n    e.ManagerID,\n    e.JobTitle,\n    eh.Level + 1,\n    eh.HierarchyPath + ' > ' + e.EmployeeName\n  FROM Employees e\n  INNER JOIN EmployeeHierarchy eh ON e.ManagerID = eh.EmployeeID\n)\nSELECT \n  EmployeeID,\n  REPLICATE('  ', Level - 1) + EmployeeName AS EmployeeName,\n  JobTitle,\n  Level,\n  HierarchyPath\nFROM EmployeeHierarchy\nORDER BY HierarchyPath;\n\n-- Recursive CTE for Bill of Materials (BOM)\nWITH BOM AS (\n  -- Anchor: Top-level product\n  SELECT \n    ProductID,\n    ComponentID,\n    ComponentName,\n    Quantity,\n    1 AS Level,\n    CAST(ComponentName AS NVARCHAR(MAX)) AS BOMPath\n  FROM ProductComponents\n  WHERE ProductID = 100  -- Top-level product\n  \n  UNION ALL\n  \n  -- Recursive: Sub-components\n  SELECT \n    pc.ProductID,\n    pc.ComponentID,\n    pc.ComponentName,\n    pc.Quantity * bom.Quantity AS Quantity,\n    bom.Level + 1,\n    bom.BOMPath + ' > ' + pc.ComponentName\n  FROM ProductComponents pc\n  INNER JOIN BOM bom ON pc.ProductID = bom.ComponentID\n  WHERE bom.Level < 10  -- Prevent infinite recursion\n)\nSELECT \n  Level,\n  ComponentID,\n  REPLICATE('  ', Level - 1) + ComponentName AS Component,\n  Quantity,\n  BOMPath\nFROM BOM\nORDER BY BOMPath;\n\n-- CTE with UPDATE\nWITH InactiveCustomers AS (\n  SELECT CustomerID\n  FROM Customers\n  WHERE CustomerID NOT IN (\n    SELECT DISTINCT CustomerID\n    FROM Orders\n    WHERE OrderDate >= DATEADD(YEAR, -1, GETDATE())\n  )\n)\nUPDATE c\nSET IsActive = 0, InactiveSince = GETDATE()\nFROM Customers c\nINNER JOIN InactiveCustomers ic ON c.CustomerID = ic.CustomerID;"
    },
    "postgresql": {
      "description": "PostgreSQL CTEs with advanced features and MATERIALIZED option",
      "code": "-- Basic CTE\nWITH recent_orders AS (\n  SELECT order_id, customer_id, order_date, total\n  FROM orders\n  WHERE order_date >= CURRENT_DATE - INTERVAL '30 days'\n)\nSELECT \n  c.customer_id,\n  c.name,\n  COUNT(ro.order_id) AS order_count,\n  SUM(ro.total) AS total_spent\nFROM customers c\nLEFT JOIN recent_orders ro ON c.customer_id = ro.customer_id\nGROUP BY c.customer_id, c.name;\n\n-- MATERIALIZED CTE (forces materialization)\nWITH MATERIALIZED expensive_computation AS (\n  SELECT \n    product_id,\n    category,\n    AVG(price) OVER (PARTITION BY category) AS category_avg,\n    COUNT(*) OVER (PARTITION BY category) AS category_count\n  FROM products\n  WHERE is_active = true\n)\nSELECT * \nFROM expensive_computation\nWHERE price > category_avg;\n\n-- Recursive CTE for graph traversal\nWITH RECURSIVE category_tree AS (\n  -- Base case: root categories\n  SELECT \n    category_id,\n    category_name,\n    parent_category_id,\n    1 AS depth,\n    ARRAY[category_id] AS path,\n    category_name::TEXT AS full_path\n  FROM categories\n  WHERE parent_category_id IS NULL\n  \n  UNION ALL\n  \n  -- Recursive case: child categories\n  SELECT \n    c.category_id,\n    c.category_name,\n    c.parent_category_id,\n    ct.depth + 1,\n    ct.path || c.category_id,\n    ct.full_path || ' > ' || c.category_name\n  FROM categories c\n  INNER JOIN category_tree ct ON c.parent_category_id = ct.category_id\n  WHERE c.category_id != ALL(ct.path)  -- Prevent cycles\n)\nSELECT \n  category_id,\n  REPEAT('  ', depth - 1) || category_name AS indented_name,\n  depth,\n  full_path\nFROM category_tree\nORDER BY full_path;\n\n-- CTE with INSERT (Data Modification CTE)\nWITH inserted_customers AS (\n  INSERT INTO customers (name, email, created_at)\n  VALUES \n    ('John Doe', 'john@example.com', NOW()),\n    ('Jane Smith', 'jane@example.com', NOW())\n  RETURNING customer_id, name, email\n)\nINSERT INTO customer_notifications (customer_id, message)\nSELECT \n  customer_id,\n  'Welcome ' || name || '! Thanks for signing up.'\nFROM inserted_customers;\n\n-- Recursive CTE for Fibonacci sequence\nWITH RECURSIVE fibonacci(n, fib_n, fib_n_plus_1) AS (\n  SELECT 1, 0::BIGINT, 1::BIGINT\n  UNION ALL\n  SELECT n + 1, fib_n_plus_1, fib_n + fib_n_plus_1\n  FROM fibonacci\n  WHERE n < 20\n)\nSELECT n, fib_n AS fibonacci_number\nFROM fibonacci;"
    },
    "mysql": {
      "description": "MySQL 8.0+ CTEs including recursive CTEs",
      "code": "-- Basic CTE (MySQL 8.0+)\nWITH customer_totals AS (\n  SELECT \n    customer_id,\n    COUNT(*) AS order_count,\n    SUM(order_total) AS total_spent,\n    MAX(order_date) AS last_order\n  FROM orders\n  WHERE order_date >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR)\n  GROUP BY customer_id\n)\nSELECT \n  c.customer_id,\n  c.name,\n  ct.order_count,\n  ct.total_spent,\n  ct.last_order,\n  DATEDIFF(CURDATE(), ct.last_order) AS days_since_order\nFROM customers c\nINNER JOIN customer_totals ct ON c.customer_id = ct.customer_id\nWHERE ct.order_count >= 3;\n\n-- Multiple CTEs\nWITH \nactive_products AS (\n  SELECT product_id, product_name, price, category_id\n  FROM products\n  WHERE is_active = TRUE AND stock_quantity > 0\n),\ncategory_stats AS (\n  SELECT \n    category_id,\n    COUNT(*) AS product_count,\n    AVG(price) AS avg_price,\n    MIN(price) AS min_price,\n    MAX(price) AS max_price\n  FROM active_products\n  GROUP BY category_id\n)\nSELECT \n  c.category_name,\n  cs.product_count,\n  cs.avg_price,\n  cs.min_price,\n  cs.max_price\nFROM categories c\nINNER JOIN category_stats cs ON c.category_id = cs.category_id\nORDER BY cs.product_count DESC;\n\n-- Recursive CTE for employee hierarchy\nWITH RECURSIVE employee_hierarchy AS (\n  -- Anchor: CEO (no manager)\n  SELECT \n    employee_id,\n    name,\n    manager_id,\n    title,\n    1 AS level,\n    CAST(name AS CHAR(200)) AS path\n  FROM employees\n  WHERE manager_id IS NULL\n  \n  UNION ALL\n  \n  -- Recursive: Employees with managers\n  SELECT \n    e.employee_id,\n    e.name,\n    e.manager_id,\n    e.title,\n    eh.level + 1,\n    CONCAT(eh.path, ' > ', e.name)\n  FROM employees e\n  INNER JOIN employee_hierarchy eh ON e.manager_id = eh.employee_id\n)\nSELECT \n  employee_id,\n  CONCAT(REPEAT('  ', level - 1), name) AS employee_name,\n  title,\n  level,\n  path AS hierarchy_path\nFROM employee_hierarchy\nORDER BY path;\n\n-- Recursive CTE for number series\nWITH RECURSIVE numbers AS (\n  SELECT 1 AS n\n  UNION ALL\n  SELECT n + 1\n  FROM numbers\n  WHERE n < 100\n)\nSELECT n, n * n AS square, n * n * n AS cube\nFROM numbers;\n\n-- Recursive CTE for date series\nWITH RECURSIVE date_series AS (\n  SELECT DATE('2024-01-01') AS date\n  UNION ALL\n  SELECT DATE_ADD(date, INTERVAL 1 DAY)\n  FROM date_series\n  WHERE date < '2024-12-31'\n)\nSELECT \n  ds.date,\n  DAYNAME(ds.date) AS day_name,\n  COALESCE(SUM(o.order_total), 0) AS daily_revenue\nFROM date_series ds\nLEFT JOIN orders o ON DATE(o.order_date) = ds.date\nGROUP BY ds.date\nORDER BY ds.date;"
    }
  }
}
