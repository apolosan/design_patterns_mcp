{
  "id": "fixed-partitions",
  "name": "Fixed Partitions",
  "category": "Distributed Systems",
  "description": "A pattern for dividing data or workload into fixed, predetermined partitions",
  "when_to_use": "Data partitioning, load balancing, scalable storage systems",
  "benefits": "Predictable data location, efficient routing, horizontal scalability",
  "drawbacks": "Hot spots if partitioning key is skewed, rebalancing complexity",
  "use_cases": "Database sharding, distributed caches, message queues",
  "complexity": "Medium",
  "tags": ["distributed-systems", "partitioning", "scalability", "data-distribution"],
  "examples": {
    "typescript": {
      "language": "typescript",
      "code": "class FixedPartitions {\n  private partitions: Map<number, Partition> = new Map();\n  private partitionCount: number;\n  \n  constructor(partitionCount: number) {\n    this.partitionCount = partitionCount;\n    this.initializePartitions();\n  }\n  \n  private initializePartitions() {\n    for (let i = 0; i < this.partitionCount; i++) {\n      this.partitions.set(i, new Partition(i));\n    }\n  }\n  \n  getPartition(key: string): Partition {\n    const partitionId = this.getPartitionId(key);\n    return this.partitions.get(partitionId)!;\n  }\n  \n  private getPartitionId(key: string): number {\n    // Simple hash-based partitioning\n    let hash = 0;\n    for (let i = 0; i < key.length; i++) {\n      hash = ((hash << 5) - hash) + key.charCodeAt(i);\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    return Math.abs(hash) % this.partitionCount;\n  }\n  \n  getAllPartitions(): Partition[] {\n    return Array.from(this.partitions.values());\n  }\n  \n  async redistributeData(): Promise<void> {\n    // In a real system, this would move data between partitions\n    // when the partition count changes\n    console.log('Redistributing data across partitions...');\n  }\n}\n\nclass Partition {\n  private data: Map<string, any> = new Map();\n  \n  constructor(public readonly id: number) {}\n  \n  async put(key: string, value: any): Promise<void> {\n    this.data.set(key, value);\n    // In a real system, this would persist to disk/network\n  }\n  \n  async get(key: string): Promise<any> {\n    return this.data.get(key);\n  }\n  \n  async delete(key: string): Promise<void> {\n    this.data.delete(key);\n  }\n  \n  getSize(): number {\n    return this.data.size;\n  }\n  \n  getKeys(): string[] {\n    return Array.from(this.data.keys());\n  }\n}\n\n// Consistent hashing for better distribution\nclass ConsistentHashing {\n  private ring: Map<number, Partition> = new Map();\n  private sortedKeys: number[] = [];\n  \n  constructor(partitions: Partition[], virtualNodesPerPartition = 100) {\n    for (const partition of partitions) {\n      for (let i = 0; i < virtualNodesPerPartition; i++) {\n        const hash = this.hash(`${partition.id}-${i}`);\n        this.ring.set(hash, partition);\n      }\n    }\n    this.sortedKeys = Array.from(this.ring.keys()).sort((a, b) => a - b);\n  }\n  \n  getPartition(key: string): Partition {\n    const hash = this.hash(key);\n    const partitionKey = this.findNearestKey(hash);\n    return this.ring.get(partitionKey)!;\n  }\n  \n  private hash(key: string): number {\n    // Simple hash function\n    let hash = 0;\n    for (let i = 0; i < key.length; i++) {\n      hash = ((hash << 5) - hash) + key.charCodeAt(i);\n    }\n    return hash >>> 0; // Convert to unsigned 32-bit\n  }\n  \n  private findNearestKey(hash: number): number {\n    // Binary search for the nearest key\n    let low = 0;\n    let high = this.sortedKeys.length - 1;\n    \n    while (low <= high) {\n      const mid = Math.floor((low + high) / 2);\n      if (this.sortedKeys[mid] < hash) {\n        low = mid + 1;\n      } else {\n        high = mid - 1;\n      }\n    }\n    \n    // Wrap around if necessary\n    return low >= this.sortedKeys.length ? this.sortedKeys[0] : this.sortedKeys[low];\n  }\n}\n\n// Usage\nconst partitions = new FixedPartitions(4);\nconst key = 'user-123';\nconst partition = partitions.getPartition(key);\n\nconsole.log(`Key '${key}' goes to partition ${partition.id}`);\n\n// With consistent hashing\nconst consistentHashing = new ConsistentHashing(partitions.getAllPartitions());\nconst partition2 = consistentHashing.getPartition(key);\nconsole.log(`With consistent hashing, key '${key}' goes to partition ${partition2.id}`);"
    }
  }
}
