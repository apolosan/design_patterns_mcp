{
  "id": "quorum",
  "name": "Quorum",
  "category": "Distributed Systems",
  "description": "A pattern requiring a majority or minimum number of nodes to agree on an operation",
  "when_to_use": "Distributed consensus, data consistency, fault tolerance",
  "benefits": "Fault tolerance, data consistency, prevents split-brain scenarios",
  "drawbacks": "Latency increase, complexity, potential for unavailability",
  "use_cases": "Distributed databases, consensus algorithms, leader election",
  "complexity": "High",
  "tags": ["distributed-systems", "consensus", "fault-tolerance", "consistency"],
  "examples": {
    "typescript": {
      "language": "typescript",
      "code": "class Quorum {\n  private nodes: Node[];\n  private readQuorum: number;\n  private writeQuorum: number;\n  \n  constructor(nodes: Node[], totalNodes: number) {\n    this.nodes = nodes;\n    // For strong consistency: majority\n    this.readQuorum = Math.floor(totalNodes / 2) + 1;\n    this.writeQuorum = Math.floor(totalNodes / 2) + 1;\n  }\n  \n  async read(key: string): Promise<any> {\n    const responses = await this.queryNodes('read', { key });\n    const successfulResponses = responses.filter(r => r.success);\n    \n    if (successfulResponses.length < this.readQuorum) {\n      throw new Error('Read quorum not reached');\n    }\n    \n    // Return the most recent value\n    return this.resolveConflicts(successfulResponses.map(r => r.data));\n  }\n  \n  async write(key: string, value: any): Promise<void> {\n    const responses = await this.queryNodes('write', { key, value });\n    const successfulResponses = responses.filter(r => r.success);\n    \n    if (successfulResponses.length < this.writeQuorum) {\n      throw new Error('Write quorum not reached');\n    }\n  }\n  \n  private async queryNodes(operation: string, params: any): Promise<NodeResponse[]> {\n    const promises = this.nodes.map(node => \n      this.queryNode(node, operation, params)\n        .catch(() => ({ success: false, data: null })) // Handle failures\n    );\n    \n    return Promise.all(promises);\n  }\n  \n  private async queryNode(node: Node, operation: string, params: any): Promise<NodeResponse> {\n    // In a real system, this would be a network call\n    try {\n      const result = await node[operation](params);\n      return { success: true, data: result };\n    } catch (error) {\n      return { success: false, data: null };\n    }\n  }\n  \n  private resolveConflicts(values: any[]): any {\n    // Simple last-write-wins strategy\n    // In a real system, you'd use vector clocks or other conflict resolution\n    return values.reduce((latest, current) => \n      (current.timestamp > latest.timestamp) ? current : latest\n    );\n  }\n}\n\ninterface Node {\n  read(params: { key: string }): Promise<any>;\n  write(params: { key: string; value: any }): Promise<void>;\n}\n\ninterface NodeResponse {\n  success: boolean;\n  data: any;\n}\n\n// Paxos-inspired quorum for consensus\nclass PaxosQuorum {\n  private proposers: Proposer[];\n  private acceptors: Acceptor[];\n  private learners: Learner[];\n  \n  constructor(proposers: Proposer[], acceptors: Acceptor[], learners: Learner[]) {\n    this.proposers = proposers;\n    this.acceptors = acceptors;\n    this.learners = learners;\n  }\n  \n  async propose(value: any): Promise<any> {\n    const proposer = this.selectProposer();\n    return proposer.propose(value);\n  }\n  \n  private selectProposer(): Proposer {\n    // Simple round-robin selection\n    return this.proposers[Math.floor(Math.random() * this.proposers.length)];\n  }\n}\n\ninterface Proposer {\n  propose(value: any): Promise<any>;\n}\n\ninterface Acceptor {\n  prepare(proposalId: string): Promise<boolean>;\n  accept(proposalId: string, value: any): Promise<boolean>;\n}\n\ninterface Learner {\n  learn(value: any): void;\n}\n\n// Simple implementation of Paxos roles\nclass SimpleProposer implements Proposer {\n  private acceptors: Acceptor[];\n  private learners: Learner[];\n  private proposalId: number = 0;\n  \n  constructor(acceptors: Acceptor[], learners: Learner[]) {\n    this.acceptors = acceptors;\n    this.learners = learners;\n  }\n  \n  async propose(value: any): Promise<any> {\n    this.proposalId++;\n    \n    // Phase 1: Prepare\n    const promises = this.acceptors.map(acceptor => \n      acceptor.prepare(this.proposalId.toString())\n    );\n    const prepareResponses = await Promise.all(promises);\n    const majority = Math.floor(this.acceptors.length / 2) + 1;\n    \n    if (prepareResponses.filter(Boolean).length < majority) {\n      throw new Error('Prepare phase failed');\n    }\n    \n    // Phase 2: Accept\n    const acceptPromises = this.acceptors.map(acceptor => \n      acceptor.accept(this.proposalId.toString(), value)\n    );\n    const acceptResponses = await Promise.all(acceptPromises);\n    \n    if (acceptResponses.filter(Boolean).length < majority) {\n      throw new Error('Accept phase failed');\n    }\n    \n    // Notify learners\n    this.learners.forEach(learner => learner.learn(value));\n    \n    return value;\n  }\n}"
    }
  }
}
