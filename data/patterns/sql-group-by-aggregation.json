{
  "id": "sql-group-by-aggregation",
  "name": "GROUP BY Aggregation Pattern",
  "category": "Data Query",
  "description": "Aggregates data into groups using GROUP BY clause combined with aggregate functions (SUM, AVG, COUNT, MAX, MIN). This pattern transforms detailed data into summary statistics, enabling analytical queries and reporting at various granularity levels.",
  "when_to_use": "[\"Need summary statistics from detailed data\",\"Calculate totals, averages, or counts per category\",\"Generate reports with grouped data\",\"Analyze data at different granularity levels\",\"Combine with HAVING for filtered aggregates\"]",
  "benefits": "[\"Reduces data volume through aggregation\",\"Provides meaningful business metrics\",\"Enables multi-level analysis\",\"Improves query performance with proper indexing\",\"Supports complex analytical queries\"]",
  "drawbacks": "[\"Can be memory-intensive for large groups\",\"May require careful index design\",\"HAVING clause evaluated after grouping\",\"Complex grouping can impact readability\"]",
  "use_cases": "[\"Sales reporting by region or period\",\"Calculating customer lifetime value\",\"Inventory analysis by category\",\"Website analytics (page views, sessions)\",\"Financial summaries and KPIs\",\"Trend analysis over time periods\"]",
  "complexity": "Medium",
  "tags": ["sql", "aggregation", "group-by", "analytics", "reporting", "sum", "avg", "count"],
  "examples": {
    "tsql": {
      "description": "T-SQL GROUP BY with all aggregate functions and HAVING clause",
      "code": "-- Basic GROUP BY with COUNT\nSELECT Country, COUNT(*) AS CustomerCount\nFROM Customers\nGROUP BY Country\nORDER BY CustomerCount DESC;\n\n-- Multiple aggregations\nSELECT \n  ProductCategory,\n  COUNT(*) AS ProductCount,\n  AVG(Price) AS AvgPrice,\n  SUM(QuantityInStock) AS TotalStock,\n  MAX(Price) AS MaxPrice,\n  MIN(Price) AS MinPrice\nFROM Products\nGROUP BY ProductCategory;\n\n-- GROUP BY with HAVING (filter after aggregation)\nSELECT \n  CustomerID,\n  COUNT(OrderID) AS OrderCount,\n  SUM(TotalAmount) AS TotalSpent\nFROM Orders\nWHERE OrderDate >= '2024-01-01'\nGROUP BY CustomerID\nHAVING COUNT(OrderID) >= 5  -- Only customers with 5+ orders\n  AND SUM(TotalAmount) > 10000;  -- Spending over 10k\n\n-- Multi-level grouping\nSELECT \n  YEAR(OrderDate) AS OrderYear,\n  MONTH(OrderDate) AS OrderMonth,\n  Region,\n  SUM(TotalAmount) AS MonthlySales,\n  COUNT(DISTINCT CustomerID) AS UniqueCustomers\nFROM Orders\nGROUP BY YEAR(OrderDate), MONTH(OrderDate), Region\nORDER BY OrderYear, OrderMonth, Region;\n\n-- GROUP BY with ROLLUP (subtotals and grand total)\nSELECT \n  Country,\n  City,\n  SUM(SalesAmount) AS TotalSales\nFROM Sales\nGROUP BY ROLLUP(Country, City);\n\n-- GROUP BY with GROUPING SETS (custom aggregation combinations)\nSELECT \n  ProductCategory,\n  ProductSubcategory,\n  SUM(SalesAmount) AS TotalSales\nFROM Sales\nGROUP BY GROUPING SETS (\n  (ProductCategory, ProductSubcategory),\n  (ProductCategory),\n  ()\n);"
    },
    "postgresql": {
      "description": "PostgreSQL GROUP BY with advanced aggregation features",
      "code": "-- Basic aggregation\nSELECT \n  category,\n  COUNT(*) AS product_count,\n  AVG(price)::NUMERIC(10,2) AS avg_price\nFROM products\nGROUP BY category;\n\n-- String aggregation (PostgreSQL specific)\nSELECT \n  customer_id,\n  COUNT(order_id) AS order_count,\n  STRING_AGG(product_name, ', ' ORDER BY product_name) AS products_ordered\nFROM order_items\nGROUP BY customer_id;\n\n-- FILTER clause for conditional aggregation\nSELECT \n  product_category,\n  COUNT(*) AS total_products,\n  COUNT(*) FILTER (WHERE price > 100) AS premium_products,\n  AVG(price) FILTER (WHERE in_stock = true) AS avg_price_in_stock,\n  SUM(quantity) FILTER (WHERE warehouse_location = 'US') AS us_inventory\nFROM products\nGROUP BY product_category;\n\n-- Array aggregation\nSELECT \n  department_id,\n  ARRAY_AGG(employee_name ORDER BY hire_date) AS employees,\n  JSON_AGG(JSON_BUILD_OBJECT(\n    'name', employee_name,\n    'salary', salary\n  )) AS employee_details\nFROM employees\nGROUP BY department_id;\n\n-- Window functions vs GROUP BY\n-- GROUP BY approach\nSELECT \n  department,\n  AVG(salary) AS avg_salary\nFROM employees\nGROUP BY department;\n\n-- Window function approach (preserves detail rows)\nSELECT \n  employee_id,\n  employee_name,\n  department,\n  salary,\n  AVG(salary) OVER (PARTITION BY department) AS dept_avg_salary,\n  salary - AVG(salary) OVER (PARTITION BY department) AS salary_diff\nFROM employees;"
    },
    "mysql": {
      "description": "MySQL GROUP BY aggregation with optimization techniques",
      "code": "-- Basic GROUP BY\nSELECT \n  category_id,\n  COUNT(*) AS product_count,\n  AVG(price) AS avg_price,\n  SUM(quantity_sold) AS total_sold\nFROM products\nGROUP BY category_id;\n\n-- GROUP BY with calculated fields\nSELECT \n  YEAR(order_date) AS order_year,\n  QUARTER(order_date) AS order_quarter,\n  COUNT(DISTINCT customer_id) AS unique_customers,\n  COUNT(order_id) AS total_orders,\n  SUM(order_total) AS revenue\nFROM orders\nGROUP BY YEAR(order_date), QUARTER(order_date)\nORDER BY order_year DESC, order_quarter DESC;\n\n-- GROUP BY with WITH ROLLUP\nSELECT \n  region,\n  product_category,\n  SUM(sales_amount) AS total_sales\nFROM sales\nGROUP BY region, product_category WITH ROLLUP;\n\n-- Conditional aggregation using CASE\nSELECT \n  customer_id,\n  COUNT(*) AS total_orders,\n  SUM(CASE WHEN order_status = 'completed' THEN 1 ELSE 0 END) AS completed_orders,\n  SUM(CASE WHEN order_status = 'cancelled' THEN 1 ELSE 0 END) AS cancelled_orders,\n  SUM(CASE WHEN order_status = 'completed' THEN order_total ELSE 0 END) AS completed_revenue\nFROM orders\nGROUP BY customer_id\nHAVING COUNT(*) > 10;\n\n-- Performance tip: Covering index for GROUP BY\n-- CREATE INDEX idx_orders_customer_date ON orders(customer_id, order_date, order_total);\nSELECT \n  customer_id,\n  COUNT(*) AS order_count,\n  MAX(order_date) AS last_order_date,\n  SUM(order_total) AS total_spent\nFROM orders\nGROUP BY customer_id;"
    }
  }
}
