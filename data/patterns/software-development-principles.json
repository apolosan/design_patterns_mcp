{
  "patterns": [
    {
      "id": "dry-principle",
      "name": "DRY (Don't Repeat Yourself)",
      "category": "Development Principles",
      "description": "Avoid code duplication to make maintenance easier. When business logic is repeated, consolidate it into reusable components. Focus on eliminating duplication at the business logic level rather than superficial similarities.",
      "when_to_use": "[\"Business logic is repeated across multiple locations\",\"Similar functionality exists in different parts of codebase\",\"Maintenance becomes difficult due to scattered changes\",\"Code reviews identify repeated patterns\"]",
      "benefits": "[\"Easier maintenance and updates\",\"Reduced bug introduction risk\",\"Improved code consistency\",\"Better separation of concerns\",\"Enhanced readability through abstraction\"]",
      "drawbacks": "[\"Over-abstraction can reduce clarity\",\"Premature consolidation may lock in wrong abstractions\",\"Requires careful judgment on what constitutes duplication\",\"May introduce unnecessary complexity for simple cases\"]",
      "use_cases": "[\"Data validation logic\",\"Error handling patterns\",\"Business rule calculations\",\"API response formatting\",\"Authentication and authorization checks\"]",
      "complexity": "Low",
      "tags": "[\"principle\",\"maintainability\",\"abstraction\",\"refactoring\",\"code-quality\"]",
      "examples": {
        "typescript": {
          "description": "DRY principle applied to user validation logic",
          "code": "// BEFORE: Repeated validation logic\nconst createUser = (userData) => {\n  if (!userData.name || userData.name.length < 2) {\n    throw new Error('Name must be at least 2 characters');\n  }\n  if (!userData.email || !userData.email.includes('@')) {\n    throw new Error('Valid email required');\n  }\n  // Create user logic...\n};\n\nconst updateUser = (userId, userData) => {\n  if (!userData.name || userData.name.length < 2) {\n    throw new Error('Name must be at least 2 characters');\n  }\n  if (!userData.email || !userData.email.includes('@')) {\n    throw new Error('Valid email required');\n  }\n  // Update user logic...\n};\n\n// AFTER: DRY - Extracted validation\nconst validateUserData = (userData) => {\n  if (!userData.name || userData.name.length < 2) {\n    throw new Error('Name must be at least 2 characters');\n  }\n  if (!userData.email || !userData.email.includes('@')) {\n    throw new Error('Valid email required');\n  }\n};\n\nconst createUser = (userData) => {\n  validateUserData(userData);\n  // Create user logic...\n};\n\nconst updateUser = (userId, userData) => {\n  validateUserData(userData);\n  // Update user logic...\n};"
        },
        "python": {
          "description": "DRY principle with database query abstraction",
          "code": "# BEFORE: Repeated database query patterns\ndef get_user_by_id(user_id):\n    conn = get_db_connection()\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT * FROM users WHERE id = ?\", (user_id,))\n    result = cursor.fetchone()\n    conn.close()\n    return result\n\ndef get_product_by_id(product_id):\n    conn = get_db_connection()\n    cursor = conn.cursor()\n    cursor.execute(\"SELECT * FROM products WHERE id = ?\", (product_id,))\n    result = cursor.fetchone()\n    conn.close()\n    return result\n\n# AFTER: DRY - Generic query function\ndef query_by_id(table_name, record_id):\n    conn = get_db_connection()\n    try:\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name} WHERE id = ?\", (record_id,))\n        return cursor.fetchone()\n    finally:\n        conn.close()\n\ndef get_user_by_id(user_id):\n    return query_by_id('users', user_id)\n\ndef get_product_by_id(product_id):\n    return query_by_id('products', product_id)"
        },
        "java": {
          "description": "DRY principle in Java with validation framework",
          "code": "// BEFORE: Repeated validation logic\npublic User createUser(UserData userData) {\n    if (userData.getName() == null || userData.getName().length() < 2) {\n        throw new ValidationException(\"Name must be at least 2 characters\");\n    }\n    if (userData.getEmail() == null || !userData.getEmail().contains(\"@\")) {\n        throw new ValidationException(\"Valid email required\");\n    }\n    // Create user logic...\n}\n\npublic User updateUser(Long userId, UserData userData) {\n    if (userData.getName() == null || userData.getName().length() < 2) {\n        throw new ValidationException(\"Name must be at least 2 characters\");\n    }\n    if (userData.getEmail() == null || !userData.getEmail().contains(\"@\")) {\n        throw new ValidationException(\"Valid email required\");\n    }\n    // Update user logic...\n}\n\n// AFTER: DRY - Extracted validation\n@FunctionalInterface\ninterface Validator<T> {\n    void validate(T data);\n}\n\npublic class UserValidator {\n    public static void validateUserData(UserData userData) {\n        if (userData.getName() == null || userData.getName().length() < 2) {\n            throw new ValidationException(\"Name must be at least 2 characters\");\n        }\n        if (userData.getEmail() == null || !userData.getEmail().contains(\"@\")) {\n            throw new ValidationException(\"Valid email required\");\n        }\n    }\n}\n\npublic User createUser(UserData userData) {\n    UserValidator.validateUserData(userData);\n    // Create user logic...\n}\n\npublic User updateUser(Long userId, UserData userData) {\n    UserValidator.validateUserData(userData);\n    // Update user logic...\n}"
        },
        "csharp": {
          "description": "DRY principle with LINQ and extension methods",
          "code": "// BEFORE: Repeated validation logic\npublic User CreateUser(UserData userData)\n{\n    if (string.IsNullOrEmpty(userData.Name) || userData.Name.Length < 2)\n        throw new ValidationException(\"Name must be at least 2 characters\");\n    if (string.IsNullOrEmpty(userData.Email) || !userData.Email.Contains(\"@\"))\n        throw new ValidationException(\"Valid email required\");\n    // Create user logic...\n}\n\npublic User UpdateUser(int userId, UserData userData)\n{\n    if (string.IsNullOrEmpty(userData.Name) || userData.Name.Length < 2)\n        throw new ValidationException(\"Name must be at least 2 characters\");\n    if (string.IsNullOrEmpty(userData.Email) || !userData.Email.Contains(\"@\"))\n        throw new ValidationException(\"Valid email required\");\n    // Update user logic...\n}\n\n// AFTER: DRY - Extension method for validation\npublic static class UserValidationExtensions\n{\n    public static void Validate(this UserData userData)\n    {\n        if (string.IsNullOrEmpty(userData.Name) || userData.Name.Length < 2)\n            throw new ValidationException(\"Name must be at least 2 characters\");\n        if (string.IsNullOrEmpty(userData.Email) || !userData.Email.Contains(\"@\"))\n            throw new ValidationException(\"Valid email required\");\n    }\n}\n\npublic User CreateUser(UserData userData)\n{\n    userData.Validate(); // DRY validation\n    // Create user logic...\n}\n\npublic User UpdateUser(int userId, UserData userData)\n{\n    userData.Validate(); // DRY validation\n    // Update user logic...\n}"
        }
      }
    },
    {
      "id": "kiss-principle",
      "name": "KISS (Keep It Simple, Stupid)",
      "category": "Development Principles",
      "description": "Prioritize simplicity in code design. Write straightforward code that does one thing well. Avoid over-engineering and unnecessary complexity. Simple solutions are easier to understand, test, and maintain.",
      "when_to_use": "[\"Multiple solutions exist for a problem\",\"Code becomes hard to understand\",\"Debugging takes too long\",\"New team members struggle with codebase\",\"Performance requirements are not extreme\"]",
      "benefits": "[\"Easier to understand and maintain\",\"Faster development and debugging\",\"Reduced bug likelihood\",\"Better team productivity\",\"Easier testing and verification\"]",
      "drawbacks": "[\"May not scale well for complex requirements\",\"Can lead to repeated code (balance with DRY)\",\"Subjective interpretation of 'simple'\",\"May require refactoring when requirements grow\"]",
      "use_cases": "[\"API endpoint design\",\"Data structure selection\",\"Algorithm choice\",\"Configuration management\",\"Error handling strategies\"]",
      "complexity": "Low",
      "tags": "[\"principle\",\"simplicity\",\"maintainability\",\"readability\",\"productivity\"]",
      "examples": {
        "typescript": {
          "description": "KISS principle: Simple user authentication",
          "code": "// OVER-COMPLEX: Unnecessary abstraction layers\nclass AuthenticationService {\n  constructor(private validator: InputValidator, private hasher: PasswordHasher, private tokenizer: TokenGenerator) {}\n  \n  async authenticate(credentials: Credentials): Promise<AuthResult> {\n    const validation = await this.validator.validate(credentials);\n    if (!validation.isValid) return { success: false, errors: validation.errors };\n    \n    const user = await this.findUser(credentials.username);\n    if (!user) return { success: false, errors: ['User not found'] };\n    \n    const hashValid = await this.hasher.verify(credentials.password, user.passwordHash);\n    if (!hashValid) return { success: false, errors: ['Invalid password'] };\n    \n    const token = await this.tokenizer.generate(user.id);\n    return { success: true, token, user };\n  }\n}\n\n// SIMPLE: Direct and clear\nconst authenticateUser = async (username: string, password: string) => {\n  const user = await db.users.findOne({ username });\n  if (!user) {\n    return { success: false, error: 'User not found' };\n  }\n  \n  const isValidPassword = await bcrypt.compare(password, user.passwordHash);\n  if (!isValidPassword) {\n    return { success: false, error: 'Invalid password' };\n  }\n  \n  const token = jwt.sign({ userId: user.id }, process.env.JWT_SECRET);\n  return { success: true, token, user: { id: user.id, username: user.username } };\n};"
        },
        "python": {
          "description": "KISS principle: Simple file processing",
          "code": "# OVER-COMPLEX: Abstract factory for file readers\nclass FileReaderFactory:\n    @staticmethod\n    def create_reader(file_type):\n        if file_type == 'json':\n            return JSONFileReader()\n        elif file_type == 'csv':\n            return CSVFileReader()\n        elif file_type == 'xml':\n            return XMLFileReader()\n        else:\n            raise ValueError(f\"Unsupported file type: {file_type}\")\n\n# Usage requires factory knowledge\nfactory = FileReaderFactory()\nreader = factory.create_reader('json')\ndata = reader.read('config.json')\n\n# SIMPLE: Direct file reading\ndef read_config(file_path):\n    \"\"\"Read configuration from JSON file\"\"\"\n    with open(file_path, 'r') as f:\n        return json.load(f)\n\n# Usage is straightforward\nconfig = read_config('config.json')"
        },
        "go": {
          "description": "KISS principle: Simple HTTP handler",
          "code": "// OVER-COMPLEX: Multiple layers of abstraction\ntype RequestHandler struct {\n    validator Validator\n    processor RequestProcessor\n    responder ResponseBuilder\n}\n\nfunc (h *RequestHandler) Handle(w http.ResponseWriter, r *http.Request) {\n    if err := h.validator.Validate(r); err != nil {\n        h.responder.Error(w, err)\n        return\n    }\n    \n    result, err := h.processor.Process(r)\n    if err != nil {\n        h.responder.Error(w, err)\n        return\n    }\n    \n    h.responder.Success(w, result)\n}\n\n// SIMPLE: Direct handler\nfunction handleUser(w http.ResponseWriter, r *http.Request) {\n    var user User\n    if err := json.NewDecoder(r.Body).Decode(&user); err != nil {\n        http.Error(w, \"Invalid JSON\", http.StatusBadRequest)\n        return\n    }\n    \n    if user.Name == \"\" || user.Email == \"\" {\n        http.Error(w, \"Name and email required\", http.StatusBadRequest)\n        return\n    }\n    \n    // Save user to database\n    userID, err := saveUser(user)\n    if err != nil {\n        http.Error(w, \"Failed to save user\", http.StatusInternalServerError)\n        return\n    }\n    \n    w.Header().Set(\"Content-Type\", \"application/json\")\n    json.NewEncoder(w).Encode(map[string]interface{}{\n        \"success\": true,\n        \"user_id\": userID,\n    })\n}"
        },
        "rust": {
          "description": "KISS principle: Simple configuration loading",
          "code": "// OVER-COMPLEX: Generic configuration loader with traits\ntrait ConfigLoader<T> {\n    fn load(&self, path: &Path) -> Result<T, ConfigError>;\n    fn validate(&self, config: &T) -> Result<(), ConfigError>;\n    fn merge(&self, base: T, override_: T) -> T;\n}\n\nstruct JsonConfigLoader;\nimpl ConfigLoader<AppConfig> for JsonConfigLoader {\n    // Complex implementation...\n}\n\n// Usage requires knowledge of loader types\nlet loader = JsonConfigLoader;\nlet config = loader.load(\"config.json\")?;\nloader.validate(&config)?;\n\n// SIMPLE: Direct JSON loading\nfn load_config(path: &str) -> Result<AppConfig, Box<dyn std::error::Error>> {\n    let content = std::fs::read_to_string(path)?;\n    let config: AppConfig = serde_json::from_str(&content)?;\n    Ok(config)\n}\n\n// Usage is straightforward\nlet config = load_config(\"config.json\")?;"
        }
      }
    },
    {
      "id": "yagni-principle",
      "name": "YAGNI (You Aren't Gonna Need It)",
      "category": "Development Principles",
      "description": "Avoid adding functionality or abstractions until they're actually needed. Don't over-engineer solutions based on future speculation. Focus on current requirements and refactor when needs arise.",
      "when_to_use": "[\"Considering features for future use\",\"Designing overly generic solutions\",\"Adding complexity for hypothetical scenarios\",\"Planning extensive abstractions upfront\"]",
      "benefits": "[\"Faster development and deployment\",\"Reduced complexity\",\"Easier maintenance\",\"Lower risk of unused code\",\"Focus on actual business needs\"]",
      "drawbacks": "[\"May require refactoring when needs change\",\"Can lead to technical debt if refactoring is delayed\",\"Requires discipline to avoid feature creep\",\"May miss opportunities for proactive design\"]",
      "use_cases": "[\"API design decisions\",\"Database schema planning\",\"Architecture component selection\",\"Library and framework choices\",\"Code structure planning\"]",
      "complexity": "Low",
      "tags": "[\"principle\",\"agile\",\"requirements\",\"planning\",\"simplicity\"]",
      "examples": {
        "typescript": {
          "description": "YAGNI: Avoid premature abstraction",
          "code": "// YAGNI VIOLATION: Generic repository for future entities\nclass GenericRepository<T> {\n  constructor(private tableName: string) {}\n  \n  async findAll(): Promise<T[]> {\n    // Generic implementation\n  }\n  \n  async findById(id: string): Promise<T> {\n    // Generic implementation\n  }\n  \n  async create(entity: T): Promise<T> {\n    // Generic implementation\n  }\n  \n  async update(id: string, entity: Partial<T>): Promise<T> {\n    // Generic implementation\n  }\n  \n  async delete(id: string): Promise<void> {\n    // Generic implementation\n  }\n}\n\n// Currently only need users\nconst userRepo = new GenericRepository<User>('users');\n\n// BETTER: Simple functions for current needs\nconst getUsers = () => db.users.findMany();\nconst getUserById = (id: string) => db.users.findUnique({ where: { id } });\nconst createUser = (userData) => db.users.create({ data: userData });\n\n// Add repository pattern only when multiple entities need similar operations"
        },
        "python": {
          "description": "YAGNI: Avoid over-engineering configuration",
          "code": "# YAGNI VIOLATION: Complex configuration system for future features\nclass ConfigurationManager:\n    def __init__(self):\n        self._config = {}\n        self._validators = {}\n        self._transformers = {}\n        self._listeners = []\n    \n    def set_validator(self, key, validator_func):\n        self._validators[key] = validator_func\n    \n    def add_transformer(self, key, transformer_func):\n        self._transformers[key] = transformer_func\n    \n    def add_change_listener(self, listener):\n        self._listeners.append(listener)\n    \n    def get(self, key, default=None):\n        return self._config.get(key, default)\n\n# SIMPLE: Dictionary for current config needs\nconfig = {\n    'database_url': os.getenv('DATABASE_URL'),\n    'debug': os.getenv('DEBUG', 'false').lower() == 'true',\n    'port': int(os.getenv('PORT', '8000'))\n}\n\n# Access directly\nif config['debug']:\n    print(\"Debug mode enabled\")\n\n# Add complexity only when actually needed"
        },
        "java": {
          "description": "YAGNI: Avoid premature interface design",
          "code": "// YAGNI VIOLATION: Interface for future payment methods\ninterface PaymentProcessor {\n    void processCreditCard(PaymentData data);\n    void processPayPal(PaymentData data);\n    void processBitcoin(PaymentData data);\n    void processApplePay(PaymentData data);\n    void processGooglePay(PaymentData data);\n    // Many more methods for future payment types...\n}\n\n// Currently only need credit cards\nclass CreditCardProcessor implements PaymentProcessor {\n    public void processCreditCard(PaymentData data) {\n        // Implementation\n    }\n    \n    // Empty implementations for future methods\n    public void processPayPal(PaymentData data) {}\n    public void processBitcoin(PaymentData data) {}\n    public void processApplePay(PaymentData data) {}\n    public void processGooglePay(PaymentData data) {}\n}\n\n// SIMPLE: Interface for current needs only\ninterface PaymentProcessor {\n    void processPayment(PaymentData data);\n}\n\nclass CreditCardProcessor implements PaymentProcessor {\n    public void processPayment(PaymentData data) {\n        // Credit card processing logic\n    }\n}\n\n// Add specific methods only when needed"
        },
        "csharp": {
          "description": "YAGNI: Avoid generic base classes",
          "code": "// YAGNI VIOLATION: Generic base class for future entity types\npublic abstract class BaseEntity<TId>\n{\n    public TId Id { get; set; }\n    public DateTime CreatedAt { get; set; }\n    public DateTime UpdatedAt { get; set; }\n    public string CreatedBy { get; set; }\n    public string UpdatedBy { get; set; }\n    public bool IsDeleted { get; set; }\n    public DateTime? DeletedAt { get; set; }\n    \n    // Generic methods for future auditing, soft deletes, etc.\n    public virtual void MarkAsDeleted(string deletedBy) { /* ... */ }\n    public virtual void Restore() { /* ... */ }\n    public virtual bool IsActive() { /* ... */ }\n}\n\n// Currently only need basic user entity\npublic class User : BaseEntity<int> { /* ... */ }\n\n// SIMPLE: Basic class for current needs\npublic class User\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public string Email { get; set; }\n    public DateTime CreatedAt { get; set; }\n}\n\n// Add base class features only when multiple entities need them"
        }
      }
    },
    {
      "id": "rule-of-three",
      "name": "Rule of Three",
      "category": "Development Principles",
      "description": "Refactor duplicated code only after seeing it repeated three times. This prevents premature abstraction while ensuring that genuine duplication is addressed. Wait for patterns to emerge before consolidating.",
      "when_to_use": "[\"Considering refactoring for code duplication\",\"Writing similar code for the second time\",\"Planning to extract common functionality\",\"Debating between duplication and abstraction\"]",
      "benefits": "[\"Avoids premature abstraction\",\"Ensures abstractions are justified\",\"Reduces unnecessary complexity\",\"Better judgment on consolidation timing\"]",
      "drawbacks": "[\"May lead to temporary duplication\",\"Requires discipline to refactor at the right time\",\"Subjective judgment on what constitutes 'similar'\",\"May miss consolidation opportunities\"]",
      "use_cases": "[\"Code review decisions\",\"Refactoring planning\",\"Abstraction timing\",\"Pattern recognition in legacy code\"]",
      "complexity": "Low",
      "tags": "[\"principle\",\"refactoring\",\"duplication\",\"timing\",\"judgment\"]",
      "examples": {
        "typescript": {
          "description": "Rule of Three: Wait for genuine duplication",
          "code": "// FIRST INSTANCE: Simple user creation\napp.post('/api/users', async (req, res) => {\n  try {\n    const user = await User.create(req.body);\n    res.json({ success: true, user });\n  } catch (error) {\n    res.status(400).json({ success: false, error: error.message });\n  }\n});\n\n// SECOND INSTANCE: Similar pattern for products\napp.post('/api/products', async (req, res) => {\n  try {\n    const product = await Product.create(req.body);\n    res.json({ success: true, product });\n  } catch (error) {\n    res.status(400).json({ success: false, error: error.message });\n  }\n});\n\n// THIRD INSTANCE: Now refactor (Rule of Three)\nconst handleCreate = async (Model, data, res) => {\n  try {\n    const entity = await Model.create(data);\n    res.json({ success: true, [Model.name.toLowerCase()]: entity });\n  } catch (error) {\n    res.status(400).json({ success: false, error: error.message });\n  }\n};\n\napp.post('/api/users', (req, res) => handleCreate(User, req.body, res));\napp.post('/api/products', (req, res) => handleCreate(Product, req.body, res));\napp.post('/api/orders', (req, res) => handleCreate(Order, req.body, res));"
        },
        "python": {
          "description": "Rule of Three in data processing",
          "code": "# FIRST: CSV processing\ndef process_csv_file(file_path):\n    data = []\n    with open(file_path, 'r') as f:\n        reader = csv.DictReader(f)\n        for row in reader:\n            # Clean and validate data\n            row['price'] = float(row['price'])\n            row['quantity'] = int(row['quantity'])\n            data.append(row)\n    return data\n\n# SECOND: JSON processing\ndef process_json_file(file_path):\n    with open(file_path, 'r') as f:\n        data = json.load(f)\n    # Clean and validate data\n    for item in data:\n        item['price'] = float(item['price'])\n        item['quantity'] = int(item['quantity'])\n    return data\n\n# THIRD: Excel processing - Now extract common logic\ndef clean_item_data(item):\n    \"\"\"Clean and validate item data\"\"\"\n    item['price'] = float(item['price'])\n    item['quantity'] = int(item['quantity'])\n    return item\n\ndef process_csv_file(file_path):\n    data = []\n    with open(file_path, 'r') as f:\n        reader = csv.DictReader(f)\n        for row in reader:\n            data.append(clean_item_data(row))\n    return data\n\ndef process_json_file(file_path):\n    with open(file_path, 'r') as f:\n        data = json.load(f)\n    return [clean_item_data(item) for item in data]"
        },
        "java": {
          "description": "Rule of Three: Database connection handling",
          "code": "// FIRST: User DAO\npublic class UserDao {\n    public User findById(Long id) {\n        Connection conn = null;\n        try {\n            conn = DriverManager.getConnection(DB_URL);\n            PreparedStatement stmt = conn.prepareStatement(\"SELECT * FROM users WHERE id = ?\");\n            stmt.setLong(1, id);\n            ResultSet rs = stmt.executeQuery();\n            return rs.next() ? mapToUser(rs) : null;\n        } catch (SQLException e) {\n            throw new RuntimeException(e);\n        } finally {\n            if (conn != null) {\n                try { conn.close(); } catch (SQLException e) { /* ignore */ }\n            }\n        }\n    }\n}\n\n// SECOND: Product DAO\npublic class ProductDao {\n    public Product findById(Long id) {\n        Connection conn = null;\n        try {\n            conn = DriverManager.getConnection(DB_URL);\n            PreparedStatement stmt = conn.prepareStatement(\"SELECT * FROM products WHERE id = ?\");\n            stmt.setLong(1, id);\n            ResultSet rs = stmt.executeQuery();\n            return rs.next() ? mapToProduct(rs) : null;\n        } catch (SQLException e) {\n            throw new RuntimeException(e);\n        } finally {\n            if (conn != null) {\n                try { conn.close(); } catch (SQLException e) { /* ignore */ }\n            }\n        }\n    }\n}\n\n// THIRD: Order DAO - Now extract common pattern\npublic abstract class BaseDao<T> {\n    protected T findById(String tableName, Long id, ResultSetMapper<T> mapper) {\n        Connection conn = null;\n        try {\n            conn = DriverManager.getConnection(DB_URL);\n            PreparedStatement stmt = conn.prepareStatement(\"SELECT * FROM \" + tableName + \" WHERE id = ?\");\n            stmt.setLong(1, id);\n            ResultSet rs = stmt.executeQuery();\n            return rs.next() ? mapper.map(rs) : null;\n        } catch (SQLException e) {\n            throw new RuntimeException(e);\n        } finally {\n            if (conn != null) {\n                try { conn.close(); } catch (SQLException e) { /* ignore */ }\n            }\n        }\n    }\n}\n\npublic class UserDao extends BaseDao<User> {\n    public User findById(Long id) {\n        return findById(\"users\", id, this::mapToUser);\n    }\n}"
        },
        "csharp": {
          "description": "Rule of Three: Validation patterns",
          "code": "// FIRST: Email validation\npublic class EmailValidator\n{\n    public ValidationResult Validate(string email)\n    {\n        if (string.IsNullOrEmpty(email))\n            return ValidationResult.Invalid(\"Email is required\");\n        \n        if (!email.Contains(\"@\"))\n            return ValidationResult.Invalid(\"Invalid email format\");\n        \n        return ValidationResult.Valid();\n    }\n}\n\n// SECOND: Phone validation\npublic class PhoneValidator\n{\n    public ValidationResult Validate(string phone)\n    {\n        if (string.IsNullOrEmpty(phone))\n            return ValidationResult.Invalid(\"Phone is required\");\n        \n        if (!Regex.IsMatch(phone, @\"^\\+?\\d{10,}$\"))\n            return ValidationResult.Invalid(\"Invalid phone format\");\n        \n        return ValidationResult.Valid();\n    }\n}\n\n// THIRD: Password validation - Now extract common pattern\npublic abstract class StringValidator\n{\n    protected abstract string FieldName { get; }\n    protected abstract bool IsValidFormat(string value);\n    \n    public ValidationResult Validate(string value)\n    {\n        if (string.IsNullOrEmpty(value))\n            return ValidationResult.Invalid($\"{FieldName} is required\");\n        \n        if (!IsValidFormat(value))\n            return ValidationResult.Invalid($\"Invalid {FieldName.ToLower()} format\");\n        \n        return ValidationResult.Valid();\n    }\n}\n\npublic class EmailValidator : StringValidator\n{\n    protected override string FieldName => \"Email\";\n    protected override bool IsValidFormat(string value) => value.Contains(\"@\");\n}\n\npublic class PhoneValidator : StringValidator\n{\n    protected override string FieldName => \"Phone\";\n    protected override bool IsValidFormat(string value) => Regex.IsMatch(value, @\"^\\+?\\d{10,}$\");\n}"
        }
      }
    },
    {
      "id": "solid-principles",
      "name": "SOLID Principles",
      "category": "Development Principles",
      "description": "Five fundamental principles for object-oriented design: Single Responsibility, Open-Closed, Liskov Substitution, Interface Segregation, and Dependency Inversion. These guide the creation of maintainable, extensible software systems.",
      "when_to_use": "[\"Designing class hierarchies\",\"Planning software architecture\",\"Refactoring legacy code\",\"Building large-scale applications\",\"Creating reusable components\"]",
      "benefits": "[\"Improved maintainability\",\"Enhanced testability\",\"Better code organization\",\"Reduced coupling\",\"Increased extensibility\"]",
      "drawbacks": "[\"Can lead to over-design\",\"Requires experience to apply correctly\",\"May increase number of classes\",\"Learning curve for newcomers\",\"Not always applicable to small projects\"]",
      "use_cases": "[\"Enterprise application design\",\"Framework development\",\"Large codebase organization\",\"API design\",\"Plugin system architecture\"]",
      "complexity": "High",
      "tags": "[\"principles\",\"object-oriented\",\"design\",\"architecture\",\"maintainability\"]",
      "examples": {
        "typescript": {
          "description": "SOLID Principles: All five applied to a notification system",
          "code": "// Single Responsibility: Each class has one reason to change\nclass EmailSender {\n  send(to: string, subject: string, body: string): void {\n    // Email sending logic only\n  }\n}\n\nclass UserRepository {\n  save(user: User): void {\n    // User persistence logic only\n  }\n}\n\n// Open-Closed: Open for extension, closed for modification\ninterface NotificationSender {\n  send(message: string): void;\n}\n\nclass EmailNotification implements NotificationSender {\n  send(message: string): void {\n    // Email implementation\n  }\n}\n\nclass SMSNotification implements NotificationSender {\n  send(message: string): void {\n    // SMS implementation\n  }\n}\n\n// Liskov Substitution: Subtypes are substitutable for base types\nclass Rectangle {\n  protected width: number;\n  protected height: number;\n  \n  setWidth(width: number): void {\n    this.width = width;\n  }\n  \n  setHeight(height: number): void {\n    this.height = height;\n  }\n  \n  getArea(): number {\n    return this.width * this.height;\n  }\n}\n\nclass Square extends Rectangle {\n  setWidth(width: number): void {\n    this.width = width;\n    this.height = width; // Maintain square properties\n  }\n  \n  setHeight(height: number): void {\n    this.width = height;\n    this.height = height;\n  }\n}\n\n// Interface Segregation: Clients depend only on methods they use\ninterface Readable {\n  read(): string;\n}\n\ninterface Writable {\n  write(data: string): void;\n}\n\ninterface Seekable {\n  seek(position: number): void;\n}\n\nclass File implements Readable, Writable, Seekable {\n  read(): string { /* ... */ }\n  write(data: string): void { /* ... */ }\n  seek(position: number): void { /* ... */ }\n}\n\nclass ReadOnlyFile implements Readable {\n  read(): string { /* ... */ }\n}\n\n// Dependency Inversion: Depend on abstractions, not concretions\ninterface Database {\n  save(data: any): void;\n}\n\nclass UserService {\n  constructor(private db: Database) {}\n  \n  saveUser(user: User): void {\n    this.db.save(user);\n  }\n}"
        },
        "python": {
          "description": "SOLID Principles in Python",
          "code": "# Single Responsibility Principle\nclass UserValidator:\n    def validate(self, user_data):\n        \"\"\"Only responsible for validation\"\"\"\n        if not user_data.get('name') or len(user_data['name']) < 2:\n            raise ValueError('Name must be at least 2 characters')\n        if not user_data.get('email') or '@' not in user_data['email']:\n            raise ValueError('Valid email required')\n\nclass UserRepository:\n    def save(self, user):\n        \"\"\"Only responsible for persistence\"\"\"\n        # Database save logic\n        pass\n\n# Open-Closed Principle\nclass Shape:\n    def area(self):\n        raise NotImplementedError\n\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    \n    def area(self):\n        return self.width * self.height\n\nclass Circle(Shape):\n    def __init__(self, radius):\n        self.radius = radius\n    \n    def area(self):\n        return 3.14 * self.radius * self.radius\n\n# Liskov Substitution Principle\nclass Bird:\n    def fly(self):\n        return \"Flying\"\n\nclass Sparrow(Bird):\n    def fly(self):\n        return \"Sparrow flying\"\n\nclass Ostrich(Bird):\n    def fly(self):\n        raise NotImplementedError(\"Ostriches can't fly\")\n\n# Interface Segregation Principle\nfrom abc import ABC, abstractmethod\n\nclass Workable(ABC):\n    @abstractmethod\n    def work(self):\n        pass\n\nclass Eatable(ABC):\n    @abstractmethod\n    def eat(self):\n        pass\n\nclass HumanWorker(Workable, Eatable):\n    def work(self):\n        return \"Working\"\n    \n    def eat(self):\n        return \"Eating\"\n\nclass RobotWorker(Workable):\n    def work(self):\n        return \"Working\"\n\n# Dependency Inversion Principle\nclass Database(ABC):\n    @abstractmethod\n    def save(self, data):\n        pass\n\nclass UserService:\n    def __init__(self, database: Database):\n        self.database = database\n    \n    def save_user(self, user):\n        self.database.save(user)"
        },
        "java": {
          "description": "SOLID Principles in Java enterprise application",
          "code": "// Single Responsibility Principle\npublic class UserValidator {\n    public void validate(User user) throws ValidationException {\n        // Only validation logic\n        if (user.getName() == null || user.getName().length() < 2) {\n            throw new ValidationException(\"Name too short\");\n        }\n    }\n}\n\npublic class UserRepository {\n    public void save(User user) {\n        // Only persistence logic\n        // JPA/Hibernate code here\n    }\n}\n\n// Open-Closed Principle\npublic interface PaymentProcessor {\n    void process(Payment payment);\n}\n\npublic class CreditCardProcessor implements PaymentProcessor {\n    public void process(Payment payment) {\n        // Credit card processing\n    }\n}\n\npublic class PayPalProcessor implements PaymentProcessor {\n    public void process(Payment payment) {\n        // PayPal processing\n    }\n}\n\n// Liskov Substitution Principle\npublic class Rectangle {\n    protected int width, height;\n    \n    public void setWidth(int width) { this.width = width; }\n    public void setHeight(int height) { this.height = height; }\n    public int getArea() { return width * height; }\n}\n\npublic class Square extends Rectangle {\n    @Override\n    public void setWidth(int width) {\n        this.width = width;\n        this.height = width;\n    }\n    \n    @Override\n    public void setHeight(int height) {\n        this.width = height;\n        this.height = height;\n    }\n}\n\n// Interface Segregation Principle\npublic interface Readable {\n    String read();\n}\n\npublic interface Writable {\n    void write(String data);\n}\n\npublic interface FileOperations extends Readable, Writable {\n    void delete();\n}\n\npublic class ReadOnlyFile implements Readable {\n    public String read() { /* implementation */ }\n}\n\n// Dependency Inversion Principle\npublic interface DataAccess {\n    void save(Object data);\n}\n\npublic class UserService {\n    private final DataAccess dataAccess;\n    \n    public UserService(DataAccess dataAccess) {\n        this.dataAccess = dataAccess;\n    }\n    \n    public void saveUser(User user) {\n        dataAccess.save(user);\n    }\n}"
        }
      }
    },
    {
      "id": "abstraction-encapsulation",
      "name": "Abstraction and Encapsulation",
      "category": "Development Principles",
      "description": "Abstraction hides complexity by providing simplified interfaces, while encapsulation bundles data and behavior together, controlling access to internal state. Together they create maintainable, modular code.",
      "when_to_use": "[\"Designing public APIs\",\"Managing complex internal logic\",\"Protecting data integrity\",\"Creating reusable components\",\"Building layered architectures\"]",
      "benefits": "[\"Reduced complexity for users\",\"Better data protection\",\"Improved maintainability\",\"Enhanced modularity\",\"Easier testing\"]",
      "drawbacks": "[\"Can add indirection overhead\",\"May hide important details\",\"Requires careful interface design\",\"Can lead to over-abstraction\",\"Performance considerations\"]",
      "use_cases": "[\"Library and framework design\",\"Data access layers\",\"Business logic encapsulation\",\"Configuration management\",\"External service integrations\"]",
      "complexity": "Medium",
      "tags": "[\"principle\",\"abstraction\",\"encapsulation\",\"modularity\",\"interfaces\"]",
      "examples": {
        "typescript": {
          "description": "Abstraction and Encapsulation in a payment system",
          "code": "// Abstraction: Hide payment processing complexity\ninterface PaymentProcessor {\n  process(amount: number, currency: string): Promise<PaymentResult>;\n}\n\n// Encapsulation: Bundle data and behavior, control access\nclass CreditCardProcessor implements PaymentProcessor {\n  private apiKey: string;\n  private baseUrl: string;\n  \n  constructor(config: { apiKey: string; baseUrl: string }) {\n    this.apiKey = config.apiKey;\n    this.baseUrl = config.baseUrl;\n  }\n  \n  async process(amount: number, currency: string): Promise<PaymentResult> {\n    // Complex payment logic hidden from users\n    const token = await this.authenticate();\n    const transaction = await this.createTransaction(amount, currency, token);\n    const result = await this.submitPayment(transaction);\n    \n    return {\n      success: result.status === 'approved',\n      transactionId: result.id,\n      amount,\n      currency\n    };\n  }\n  \n  // Private methods encapsulate internal implementation\n  private async authenticate(): Promise<string> {\n    // Authentication logic\n  }\n  \n  private async createTransaction(amount: number, currency: string, token: string) {\n    // Transaction creation logic\n  }\n  \n  private async submitPayment(transaction: any) {\n    // Payment submission logic\n  }\n}\n\n// Usage: Simple interface hides complexity\nconst processor = new CreditCardProcessor({\n  apiKey: 'secret',\n  baseUrl: 'https://api.payment.com'\n});\n\nconst result = await processor.process(99.99, 'USD');\n// No knowledge of authentication, tokens, or internal APIs needed"
        },
        "python": {
          "description": "Abstraction and Encapsulation in data processing",
          "code": "# Abstraction: Simple interface for complex data processing\nclass DataProcessor:\n    \"\"\"Abstract interface for data processing\"\"\"\n    def process(self, data):\n        raise NotImplementedError\n\n# Encapsulation: Hide implementation details\nclass CSVDataProcessor(DataProcessor):\n    def __init__(self, delimiter=',', encoding='utf-8'):\n        self._delimiter = delimiter\n        self._encoding = encoding\n        self._validators = []\n        self._transformers = []\n    \n    def add_validator(self, validator_func):\n        \"\"\"Public method to add validation\"\"\"\n        self._validators.append(validator_func)\n    \n    def add_transformer(self, transformer_func):\n        \"\"\"Public method to add transformation\"\"\"\n        self._transformers.append(transformer_func)\n    \n    def process(self, file_path):\n        \"\"\"Simple public interface\"\"\"\n        # Encapsulated complexity\n        raw_data = self._read_file(file_path)\n        validated_data = self._apply_validations(raw_data)\n        transformed_data = self._apply_transformations(validated_data)\n        return self._format_output(transformed_data)\n    \n    # Private methods encapsulate implementation\n    def _read_file(self, file_path):\n        with open(file_path, 'r', encoding=self._encoding) as f:\n            return list(csv.DictReader(f, delimiter=self._delimiter))\n    \n    def _apply_validations(self, data):\n        for item in data:\n            for validator in self._validators:\n                validator(item)\n        return data\n    \n    def _apply_transformations(self, data):\n        for item in data:\n            for transformer in self._transformers:\n                transformer(item)\n        return data\n    \n    def _format_output(self, data):\n        return {'processed_items': len(data), 'data': data}\n\n# Usage: Clean abstraction\nprocessor = CSVDataProcessor()\nprocessor.add_validator(lambda x: x.update({'price': float(x['price'])}))\nprocessor.add_transformer(lambda x: x.update({'total': x['price'] * int(x['quantity'])}))\n\nresult = processor.process('sales.csv')\n# Complex processing hidden behind simple interface"
        },
        "java": {
          "description": "Abstraction and Encapsulation in Java banking system",
          "code": "// Abstraction: Simple banking interface\npublic interface AccountService {\n    void deposit(BigDecimal amount);\n    void withdraw(BigDecimal amount);\n    BigDecimal getBalance();\n}\n\n// Encapsulation: Hide complex banking logic\npublic class SavingsAccount implements AccountService {\n    private BigDecimal balance;\n    private BigDecimal interestRate;\n    private List<Transaction> transactions;\n    private AccountValidator validator;\n    private FraudDetectionService fraudDetector;\n    \n    public SavingsAccount(BigDecimal initialBalance) {\n        this.balance = initialBalance;\n        this.interestRate = new BigDecimal(\"0.025\");\n        this.transactions = new ArrayList<>();\n        this.validator = new AccountValidator();\n        this.fraudDetector = new FraudDetectionService();\n    }\n    \n    public void deposit(BigDecimal amount) {\n        // Simple public interface\n        validator.validateDeposit(amount);\n        fraudDetector.checkTransaction(amount);\n        \n        // Encapsulated complexity\n        balance = balance.add(amount);\n        transactions.add(new Transaction(\"DEPOSIT\", amount));\n        applyInterestIfEligible();\n        updateAccountStatus();\n    }\n    \n    public void withdraw(BigDecimal amount) {\n        validator.validateWithdrawal(amount, balance);\n        fraudDetector.checkTransaction(amount.negate());\n        \n        balance = balance.subtract(amount);\n        transactions.add(new Transaction(\"WITHDRAWAL\", amount.negate()));\n    }\n    \n    public BigDecimal getBalance() {\n        return balance;\n    }\n    \n    // Private methods encapsulate internal logic\n    private void applyInterestIfEligible() {\n        // Complex interest calculation logic\n    }\n    \n    private void updateAccountStatus() {\n        // Account status update logic\n    }\n}\n\n// Usage: Clean abstraction hides all complexity\nAccountService account = new SavingsAccount(new BigDecimal(\"1000.00\"));\naccount.deposit(new BigDecimal(\"500.00\"));\nBigDecimal balance = account.getBalance(); // No knowledge of internal workings"
        },
        "csharp": {
          "description": "Abstraction and Encapsulation in C# e-commerce",
          "code": "// Abstraction: Simple shopping cart interface\npublic interface IShoppingCart\n{\n    void AddItem(Product product, int quantity);\n    void RemoveItem(Product product);\n    decimal GetTotal();\n    void Checkout();\n}\n\n// Encapsulation: Hide complex cart logic\npublic class ShoppingCart : IShoppingCart\n{\n    private readonly List<CartItem> _items;\n    private readonly IDiscountCalculator _discountCalculator;\n    private readonly ITaxCalculator _taxCalculator;\n    private readonly IPaymentProcessor _paymentProcessor;\n    private readonly IInventoryService _inventoryService;\n    \n    public ShoppingCart(\n        IDiscountCalculator discountCalculator,\n        ITaxCalculator taxCalculator,\n        IPaymentProcessor paymentProcessor,\n        IInventoryService inventoryService)\n    {\n        _items = new List<CartItem>();\n        _discountCalculator = discountCalculator;\n        _taxCalculator = taxCalculator;\n        _paymentProcessor = paymentProcessor;\n        _inventoryService = inventoryService;\n    }\n    \n    public void AddItem(Product product, int quantity)\n    {\n        // Simple public interface\n        _inventoryService.ReserveItem(product, quantity);\n        \n        // Encapsulated complexity\n        var existingItem = _items.FirstOrDefault(i => i.Product.Id == product.Id);\n        if (existingItem != null)\n        {\n            existingItem.Quantity += quantity;\n        }\n        else\n        {\n            _items.Add(new CartItem { Product = product, Quantity = quantity });\n        }\n        \n        RecalculateTotals();\n        ApplyDiscounts();\n    }\n    \n    public decimal GetTotal()\n    {\n        return _items.Sum(i => i.Total);\n    }\n    \n    public void Checkout()\n    {\n        ValidateCart();\n        ProcessPayment();\n        UpdateInventory();\n        SendConfirmationEmail();\n    }\n    \n    // Private methods encapsulate complex logic\n    private void RecalculateTotals()\n    {\n        foreach (var item in _items)\n        {\n            item.Total = item.Product.Price * item.Quantity;\n        }\n    }\n    \n    private void ApplyDiscounts() { /* Complex discount logic */ }\n    private void ValidateCart() { /* Validation logic */ }\n    private void ProcessPayment() { /* Payment processing */ }\n    private void UpdateInventory() { /* Inventory updates */ }\n    private void SendConfirmationEmail() { /* Email logic */ }\n}\n\n// Usage: Clean abstraction\nIShoppingCart cart = new ShoppingCart(discountCalc, taxCalc, paymentProc, inventorySvc);\ncart.AddItem(product, 2);\ndecimal total = cart.GetTotal();\ncart.Checkout();"
        }
      }
    },
    {
      "id": "readability-idiomatic-code",
      "name": "Readability and Idiomatic Code",
      "category": "Development Principles",
      "description": "Write code that follows community conventions and is easy for others to understand. Use language idioms, consistent naming, and clear structure. Prioritize human readability over clever optimizations.",
      "when_to_use": "[\"Writing new code\",\"Reviewing pull requests\",\"Refactoring legacy code\",\"Onboarding new team members\",\"Maintaining long-term projects\"]",
      "benefits": "[\"Faster code comprehension\",\"Reduced onboarding time\",\"Fewer bugs from misunderstandings\",\"Better collaboration\",\"Easier maintenance\"]",
      "drawbacks": "[\"May require learning language conventions\",\"Can conflict with personal style preferences\",\"Subjective judgments on readability\",\"May require more verbose code\"]",
      "use_cases": "[\"Code style guidelines\",\"Team coding standards\",\"Code review checklists\",\"Documentation writing\",\"API design\"]",
      "complexity": "Low",
      "tags": "[\"principle\",\"readability\",\"conventions\",\"style\",\"collaboration\"]",
      "examples": {
        "typescript": {
          "description": "Idiomatic TypeScript patterns",
          "code": "// NON-IDIOMATIC: Unclear, non-standard patterns\nconst x = (a, b) => { return a > b ? a : b }; // Unnecessary braces\nconst data = arr.map(function(item) { return item.value }); // Old function syntax\nconst config = {}; config.host = 'localhost'; config.port = 3000; // Side effects\n\n// IDIOMATIC: Clear, conventional TypeScript\nconst max = (a: number, b: number): number => a > b ? a : b;\nconst values = items.map(item => item.value);\nconst config = {\n  host: 'localhost',\n  port: 3000,\n};\n\n// Use optional chaining instead of nested checks\n// NON-IDIOMATIC\nconst userName = user && user.profile && user.profile.name;\n// IDIOMATIC\nconst userName = user?.profile?.name;\n\n// Use destructuring for clarity\n// NON-IDIOMATIC\nfunction processUser(user) {\n  return {\n    id: user.id,\n    name: user.name,\n    email: user.email\n  };\n}\n// IDIOMATIC\nfunction processUser({ id, name, email }) {\n  return { id, name, email };\n}\n\n// Use meaningful variable names\n// NON-IDIOMATIC\nconst x = calculateTotal(p, t, r);\n// IDIOMATIC\nconst totalPrice = calculateTotal(price, taxRate, discount);"
        },
        "python": {
          "description": "Pythonic code following PEP 8 and idioms",
          "code": "# NON-IDIOMATIC: Not Pythonic\nresult = []\nfor i in range(len(items)):\n    if items[i] % 2 == 0:\n        result.append(items[i] * 2)\n\n# IDIOMATIC: Pythonic list comprehension\neven_doubled = [x * 2 for x in items if x % 2 == 0]\n\n# Use context managers\n# NON-IDIOMATIC\nfile = open('data.txt', 'r')\ntry:\n    content = file.read()\nfinally:\n    file.close()\n\n# IDIOMATIC\nwith open('data.txt', 'r') as file:\n    content = file.read()\n\n# Use enumerate instead of range(len())\n# NON-IDIOMATIC\nfor i in range(len(names)):\n    print(f\"{i}: {names[i]}\")\n\n# IDIOMATIC\nfor index, name in enumerate(names, 1):\n    print(f\"{index}: {name}\")\n\n# Use truthiness checks\n# NON-IDIOMATIC\nif len(my_list) > 0:\n    process_list(my_list)\n\n# IDIOMATIC\nif my_list:\n    process_list(my_list)\n\n# Follow naming conventions\n# NON-IDIOMATIC\ndef calculate_total_price(product_list):\n    totalPrice = 0\n    for product in product_list:\n        totalPrice += product.price\n    return totalPrice\n\n# IDIOMATIC\ndef calculate_total_price(products):\n    \"\"\"Calculate total price of products.\"\"\"\n    total_price = 0\n    for product in products:\n        total_price += product.price\n    return total_price"
        },
        "java": {
          "description": "Readable Java code following conventions",
          "code": "// NON-IDIOMATIC: Poor readability\npublic List<User> getUsers() {\n    List<User> u = new ArrayList<>();\n    for(User usr : userList) {\n        if (usr.getAge() > 18) {\n            u.add(usr);\n        }\n    }\n    return u;\n}\n\n// IDIOMATIC: Clear and readable\npublic List<User> getAdultUsers() {\n    return userList.stream()\n        .filter(user -> user.getAge() > 18)\n        .collect(Collectors.toList());\n}\n\n// Use meaningful names\n// NON-IDIOMATIC\npublic void proc(List<String> l, int i) {\n    for (int j = 0; j < i; j++) {\n        System.out.println(l.get(j));\n    }\n}\n\n// IDIOMATIC\npublic void printFirstItems(List<String> items, int numberOfItems) {\n    for (int index = 0; index < numberOfItems; index++) {\n        System.out.println(items.get(index));\n    }\n}\n\n// Follow Java naming conventions\n// NON-IDIOMATIC\npublic class userService {\n    private List<user> users;\n    \n    public List<user> getusers() {\n        return users;\n    }\n}\n\n// IDIOMATIC\npublic class UserService {\n    private List<User> users;\n    \n    public List<User> getUsers() {\n        return users;\n    }\n}"
        },
        "csharp": {
          "description": "Readable C# code following .NET conventions",
          "code": "// NON-IDIOMATIC: Unclear patterns\npublic List<User> GetUsers() {\n    var u = new List<User>();\n    foreach (var usr in userList) {\n        if (usr.Age > 18) {\n            u.Add(usr);\n        }\n    }\n    return u;\n}\n\n// IDIOMATIC: LINQ for clarity\npublic IEnumerable<User> GetAdultUsers() {\n    return userList.Where(user => user.Age > 18);\n}\n\n// Use var appropriately\n// NON-IDIOMATIC\nDictionary<string, List<int>> dictionary = new Dictionary<string, List<int>>();\n\n// IDIOMATIC\nvar dictionary = new Dictionary<string, List<int>>();\n\n// Use expression-bodied members\n// NON-IDIOMATIC\npublic string FullName {\n    get {\n        return $\"{FirstName} {LastName}\";\n    }\n}\n\n// IDIOMATIC\npublic string FullName => $\"{FirstName} {LastName}\";\n\n// Use meaningful property names\n// NON-IDIOMATIC\npublic class Data {\n    public string Nm { get; set; }\n    public int Cnt { get; set; }\n}\n\n// IDIOMATIC\npublic class Product {\n    public string Name { get; set; }\n    public int Count { get; set; }\n}\n\n// Follow async/await patterns\n// NON-IDIOMATIC\npublic Task<string> GetDataAsync() {\n    return Task.Run(() => {\n        Thread.Sleep(1000);\n        return \"data\";\n    });\n}\n\n// IDIOMATIC\npublic async Task<string> GetDataAsync() {\n    await Task.Delay(1000);\n    return \"data\";\n}"
        }
      }
    },
    {
      "id": "correctness-testing",
      "name": "Correctness and Testing",
      "category": "Development Principles",
      "description": "Ensure code works as intended through comprehensive testing. Tests verify behavior but don't prove absence of bugs. Prioritize working, correct code over untested clever solutions.",
      "when_to_use": "[\"Writing new features\",\"Refactoring existing code\",\"Fixing bugs\",\"Integrating with external systems\",\"Preparing for deployment\"]",
      "benefits": "[\"Confidence in code behavior\",\"Early bug detection\",\"Regression prevention\",\"Documentation of expected behavior\",\"Safer refactoring\"]",
      "drawbacks": "[\"Time investment in writing tests\",\"False sense of security\",\"Tests don't catch all bugs\",\"Maintenance overhead\",\"Can be skipped under time pressure\"]",
      "use_cases": "[\"Unit testing\",\"Integration testing\",\"End-to-end testing\",\"Property-based testing\",\"Test-driven development\"]",
      "complexity": "Medium",
      "tags": "[\"principle\",\"testing\",\"quality-assurance\",\"correctness\",\"reliability\"]",
      "examples": {
        "typescript": {
          "description": "Comprehensive testing strategy",
          "code": "// Unit tests for business logic\nimport { describe, it, expect, beforeEach } from 'vitest';\n\nclass Calculator {\n  add(a: number, b: number): number {\n    return a + b;\n  }\n  \n  divide(a: number, b: number): number {\n    if (b === 0) throw new Error('Division by zero');\n    return a / b;\n  }\n}\n\ndescribe('Calculator', () => {\n  let calculator: Calculator;\n  \n  beforeEach(() => {\n    calculator = new Calculator();\n  });\n  \n  describe('add', () => {\n    it('should add two positive numbers', () => {\n      expect(calculator.add(2, 3)).toBe(5);\n    });\n    \n    it('should handle negative numbers', () => {\n      expect(calculator.add(-2, 3)).toBe(1);\n    });\n    \n    it('should handle zero', () => {\n      expect(calculator.add(0, 5)).toBe(5);\n    });\n  });\n  \n  describe('divide', () => {\n    it('should divide two numbers', () => {\n      expect(calculator.divide(10, 2)).toBe(5);\n    });\n    \n    it('should throw error for division by zero', () => {\n      expect(() => calculator.divide(10, 0)).toThrow('Division by zero');\n    });\n  });\n});\n\n// Integration test for API endpoint\nimport request from 'supertest';\nimport app from './app';\n\ndescribe('POST /api/users', () => {\n  it('should create a user successfully', async () => {\n    const userData = {\n      name: 'John Doe',\n      email: 'john@example.com'\n    };\n    \n    const response = await request(app)\n      .post('/api/users')\n      .send(userData)\n      .expect(201);\n    \n    expect(response.body).toHaveProperty('id');\n    expect(response.body.name).toBe(userData.name);\n    expect(response.body.email).toBe(userData.email);\n  });\n  \n  it('should validate required fields', async () => {\n    const response = await request(app)\n      .post('/api/users')\n      .send({})\n      .expect(400);\n    \n    expect(response.body.errors).toContain('name is required');\n    expect(response.body.errors).toContain('email is required');\n  });\n});"
        },
        "python": {
          "description": "Testing with pytest and property-based testing",
          "code": "import pytest\nfrom hypothesis import given, strategies as st\n\nclass ShoppingCart:\n    def __init__(self):\n        self.items = []\n    \n    def add_item(self, name, price, quantity=1):\n        if price < 0:\n            raise ValueError(\"Price cannot be negative\")\n        if quantity < 1:\n            raise ValueError(\"Quantity must be positive\")\n        \n        self.items.append({\n            'name': name,\n            'price': price,\n            'quantity': quantity\n        })\n    \n    def get_total(self):\n        return sum(item['price'] * item['quantity'] for item in self.items)\n\n# Unit tests\nclass TestShoppingCart:\n    def setup_method(self):\n        self.cart = ShoppingCart()\n    \n    def test_add_valid_item(self):\n        self.cart.add_item('Apple', 1.50, 3)\n        assert len(self.cart.items) == 1\n        assert self.cart.get_total() == 4.50\n    \n    def test_add_item_negative_price_raises_error(self):\n        with pytest.raises(ValueError, match=\"Price cannot be negative\"):\n            self.cart.add_item('Apple', -1.50)\n    \n    def test_add_item_zero_quantity_raises_error(self):\n        with pytest.raises(ValueError, match=\"Quantity must be positive\"):\n            self.cart.add_item('Apple', 1.50, 0)\n    \n    def test_empty_cart_total_is_zero(self):\n        assert self.cart.get_total() == 0\n    \n    def test_multiple_items_total(self):\n        self.cart.add_item('Apple', 1.50, 2)\n        self.cart.add_item('Banana', 0.75, 4)\n        assert self.cart.get_total() == 4.50\n\n# Property-based tests (hypothesis)\nclass TestShoppingCartProperties:\n    @given(\n        st.lists(\n            st.tuples(\n                st.text(min_size=1),\n                st.floats(min_value=0, max_value=1000),\n                st.integers(min_value=1, max_value=100)\n            ),\n            min_size=0,\n            max_size=10\n        )\n    )\n    def test_total_is_always_non_negative(self, items):\n        cart = ShoppingCart()\n        for name, price, quantity in items:\n            cart.add_item(name, price, quantity)\n        \n        assert cart.get_total() >= 0\n    \n    @given(\n        st.text(min_size=1),\n        st.floats(min_value=0, max_value=1000),\n        st.integers(min_value=1, max_value=100),\n        st.integers(min_value=1, max_value=100)\n    )\n    def test_quantity_multiplication(self, name, price, quantity1, quantity2):\n        cart = ShoppingCart()\n        cart.add_item(name, price, quantity1)\n        cart.add_item(name, price, quantity2)\n        \n        expected_total = price * (quantity1 + quantity2)\n        assert abs(cart.get_total() - expected_total) < 0.01"
        },
        "java": {
          "description": "Testing with JUnit and Mockito",
          "code": "import org.junit.jupiter.api.*;\nimport org.mockito.*;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class UserServiceTest {\n    @Mock\n    private UserRepository userRepository;\n    \n    @Mock\n    private EmailService emailService;\n    \n    private UserService userService;\n    \n    @BeforeEach\n    void setUp() {\n        MockitoAnnotations.openMocks(this);\n        userService = new UserService(userRepository, emailService);\n    }\n    \n    @Test\n    void shouldCreateUserSuccessfully() {\n        // Arrange\n        User user = new User(\"John\", \"john@example.com\");\n        when(userRepository.save(any(User.class))).thenReturn(user);\n        \n        // Act\n        User createdUser = userService.createUser(user);\n        \n        // Assert\n        assertNotNull(createdUser);\n        assertEquals(\"John\", createdUser.getName());\n        verify(emailService).sendWelcomeEmail(user);\n    }\n    \n    @Test\n    void shouldThrowExceptionForInvalidEmail() {\n        // Arrange\n        User invalidUser = new User(\"John\", \"invalid-email\");\n        \n        // Act & Assert\n        assertThrows(ValidationException.class, () -> \n            userService.createUser(invalidUser));\n        \n        verify(userRepository, never()).save(any(User.class));\n        verify(emailService, never()).sendWelcomeEmail(any(User.class));\n    }\n    \n    @ParameterizedTest\n    @ValueSource(strings = {\"\", \"a\", \"invalid\"})\n    void shouldValidateNameLength(String invalidName) {\n        User user = new User(invalidName, \"john@example.com\");\n        \n        assertThrows(ValidationException.class, () -> \n            userService.createUser(user));\n    }\n}\n\n// Integration test with TestContainers\n@Testcontainers\n@SpringBootTest\npublic class UserApiIntegrationTest {\n    \n    @Container\n    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>(\"postgres:13\");\n    \n    @Autowired\n    private TestRestTemplate restTemplate;\n    \n    @Test\n    void shouldCreateUserViaApi() {\n        UserDto userDto = new UserDto(\"Jane\", \"jane@example.com\");\n        \n        ResponseEntity<UserDto> response = restTemplate.postForEntity(\n            \"/api/users\", userDto, UserDto.class);\n        \n        assertEquals(HttpStatus.CREATED, response.getStatusCode());\n        assertNotNull(response.getBody().getId());\n        assertEquals(\"Jane\", response.getBody().getName());\n    }\n}"
        },
        "csharp": {
          "description": "Testing with xUnit and Moq",
          "code": "using Xunit;\nusing Moq;\nusing FluentAssertions;\n\npublic class OrderServiceTests\n{\n    private readonly Mock<IOrderRepository> _orderRepositoryMock;\n    private readonly Mock<IPaymentService> _paymentServiceMock;\n    private readonly OrderService _orderService;\n    \n    public OrderServiceTests()\n    {\n        _orderRepositoryMock = new Mock<IOrderRepository>();\n        _paymentServiceMock = new Mock<IPaymentService>();\n        _orderService = new OrderService(\n            _orderRepositoryMock.Object, \n            _paymentServiceMock.Object);\n    }\n    \n    [Fact]\n    public async Task ProcessOrder_ShouldSucceed_WhenValidOrder()\n    {\n        // Arrange\n        var order = new Order { Total = 100m, Items = new List<OrderItem> { new OrderItem() } };\n        _paymentServiceMock.Setup(p => p.ProcessPaymentAsync(order.Total))\n            .ReturnsAsync(PaymentResult.Success(\"txn_123\"));\n        \n        // Act\n        var result = await _orderService.ProcessOrderAsync(order);\n        \n        // Assert\n        result.Should().BeEquivalentTo(OrderProcessingResult.Success);\n        _orderRepositoryMock.Verify(r => r.SaveAsync(order), Times.Once);\n        _paymentServiceMock.Verify(p => p.ProcessPaymentAsync(order.Total), Times.Once);\n    }\n    \n    [Theory]\n    [InlineData(0)]\n    [InlineData(-10)]\n    public async Task ProcessOrder_ShouldFail_WhenInvalidAmount(decimal invalidAmount)\n    {\n        // Arrange\n        var order = new Order { Total = invalidAmount };\n        \n        // Act\n        var result = await _orderService.ProcessOrderAsync(order);\n        \n        // Assert\n        result.Should().BeEquivalentTo(OrderProcessingResult.InvalidAmount);\n        _orderRepositoryMock.Verify(r => r.SaveAsync(It.IsAny<Order>()), Times.Never);\n        _paymentServiceMock.Verify(p => p.ProcessPaymentAsync(It.IsAny<decimal>()), Times.Never);\n    }\n    \n    [Fact]\n    public async Task ProcessOrder_ShouldHandlePaymentFailure()\n    {\n        // Arrange\n        var order = new Order { Total = 100m };\n        _paymentServiceMock.Setup(p => p.ProcessPaymentAsync(order.Total))\n            .ReturnsAsync(PaymentResult.Failure(\"Insufficient funds\"));\n        \n        // Act\n        var result = await _orderService.ProcessOrderAsync(order);\n        \n        // Assert\n        result.Should().BeEquivalentTo(OrderProcessingResult.PaymentFailed);\n        _orderRepositoryMock.Verify(r => r.SaveAsync(order), Times.Never);\n    }\n}\n\n// Integration tests\n[Collection(\"Database collection\")]\npublic class OrderRepositoryIntegrationTests : IAsyncLifetime\n{\n    private readonly SqlServerTestContainer _container;\n    private readonly OrderRepository _repository;\n    \n    public OrderRepositoryIntegrationTests()\n    {\n        _container = new SqlServerTestContainer();\n        _repository = new OrderRepository(_container.ConnectionString);\n    }\n    \n    public async Task InitializeAsync() => await _container.StartAsync();\n    public async Task DisposeAsync() => await _container.StopAsync();\n    \n    [Fact]\n    public async Task SaveAsync_ShouldPersistOrder()\n    {\n        var order = new Order { Total = 50m, CustomerId = 1 };\n        \n        await _repository.SaveAsync(order);\n        \n        var savedOrder = await _repository.GetByIdAsync(order.Id);\n        savedOrder.Should().NotBeNull();\n        savedOrder.Total.Should().Be(50m);\n    }\n}"
        }
      }
    },
    {
      "id": "performance-awareness",
      "name": "Performance Awareness",
      "category": "Development Principles",
      "description": "Be mindful of resource usage and performance implications, but don't obsess over micro-optimizations. Focus on algorithmic efficiency and architectural decisions that impact scalability.",
      "when_to_use": "[\"Designing system architecture\",\"Choosing algorithms and data structures\",\"Planning for scalability\",\"Identifying performance bottlenecks\",\"Making technology stack decisions\"]",
      "benefits": "[\"Better user experience\",\"Cost-effective resource usage\",\"Future-proof scalability\",\"Informed architectural decisions\",\"Avoidance of performance pitfalls\"]",
      "drawbacks": "[\"Premature optimization risks\",\"Over-engineering for hypothetical scenarios\",\"Distraction from functional requirements\",\"Complex solutions for simple problems\"]",
      "use_cases": "[\"Database query optimization\",\"Caching strategy design\",\"Algorithm selection\",\"Memory management\",\"Network communication design\"]",
      "complexity": "Medium",
      "tags": "[\"principle\",\"performance\",\"optimization\",\"scalability\",\"efficiency\"]",
      "examples": {
        "typescript": {
          "description": "Performance-aware data processing",
          "code": "// PERFORMANCE-AWARE: Efficient data processing\nclass DataProcessor {\n  private cache = new Map<string, any>();\n  \n  // Cache expensive operations\n  async getProcessedData(key: string): Promise<any> {\n    if (this.cache.has(key)) {\n      return this.cache.get(key);\n    }\n    \n    const data = await this.expensiveOperation(key);\n    this.cache.set(key, data);\n    return data;\n  }\n  \n  // Use efficient algorithms\n  findDuplicates(items: number[]): number[] {\n    // O(n) time with Set vs O(n²) with nested loops\n    const seen = new Set<number>();\n    const duplicates: number[] = [];\n    \n    for (const item of items) {\n      if (seen.has(item) && !duplicates.includes(item)) {\n        duplicates.push(item);\n      }\n      seen.add(item);\n    }\n    \n    return duplicates;\n  }\n  \n  // Batch operations to reduce overhead\n  async processBatch(items: any[]): Promise<any[]> {\n    const results: any[] = [];\n    const batchSize = 100;\n    \n    for (let i = 0; i < items.length; i += batchSize) {\n      const batch = items.slice(i, i + batchSize);\n      const batchResults = await this.processBatchItems(batch);\n      results.push(...batchResults);\n    }\n    \n    return results;\n  }\n  \n  // Avoid unnecessary work\n  shouldProcessItem(item: any): boolean {\n    // Early returns prevent unnecessary processing\n    if (!item.isActive) return false;\n    if (item.processedAt && Date.now() - item.processedAt < 3600000) {\n      return false; // Skip if processed within last hour\n    }\n    return true;\n  }\n  \n  private async expensiveOperation(key: string): Promise<any> {\n    // Simulate expensive operation\n    await new Promise(resolve => setTimeout(resolve, 100));\n    return { key, data: `processed-${key}` };\n  }\n  \n  private async processBatchItems(batch: any[]): Promise<any[]> {\n    // Process multiple items efficiently\n    return Promise.all(batch.map(item => this.expensiveOperation(item.key)));\n  }\n}"
        },
        "python": {
          "description": "Performance-aware Python patterns",
          "code": "# PERFORMANCE-AWARE: Efficient data structures and algorithms\nfrom collections import defaultdict, deque\nimport time\n\nclass PerformanceAwareProcessor:\n    def __init__(self):\n        self._cache = {}\n        self._cache_timestamps = {}\n        self._cache_ttl = 300  # 5 minutes\n    \n    def get_frequent_items(self, items, k=10):\n        \"\"\"Find k most frequent items efficiently\"\"\"\n        # Use Counter for O(n) counting vs manual dictionary\n        from collections import Counter\n        return Counter(items).most_common(k)\n    \n    def process_with_caching(self, key, compute_func):\n        \"\"\"Cache results to avoid repeated computation\"\"\"\n        now = time.time()\n        \n        if key in self._cache:\n            if now - self._cache_timestamps[key] < self._cache_ttl:\n                return self._cache[key]\n            else:\n                # Clean expired cache\n                del self._cache[key]\n                del self._cache_timestamps[key]\n        \n        result = compute_func()\n        self._cache[key] = result\n        self._cache_timestamps[key] = now\n        return result\n    \n    def efficient_grouping(self, data, key_func):\n        \"\"\"Group data efficiently using defaultdict\"\"\"\n        # defaultdict avoids KeyError checks\n        groups = defaultdict(list)\n        \n        for item in data:\n            groups[key_func(item)].append(item)\n        \n        return dict(groups)  # Convert to regular dict if needed\n    \n    def sliding_window_maximum(self, nums, k):\n        \"\"\"Find max in each sliding window efficiently\"\"\"\n        if not nums or k == 0:\n            return []\n        \n        # Use deque for O(n) solution vs O(n*k) naive approach\n        from collections import deque\n        \n        result = []\n        window = deque()\n        \n        for i, num in enumerate(nums):\n            # Remove elements outside current window\n            while window and window[0] <= i - k:\n                window.popleft()\n            \n            # Remove smaller elements from back\n            while window and nums[window[-1]] <= num:\n                window.pop()\n            \n            window.append(i)\n            \n            # Add max for current window\n            if i >= k - 1:\n                result.append(nums[window[0]])\n        \n        return result\n    \n    def memory_efficient_processing(self, large_file_path):\n        \"\"\"Process large files without loading everything into memory\"\"\"\n        # Process line by line instead of loading entire file\n        total = 0\n        count = 0\n        \n        with open(large_file_path, 'r') as file:\n            for line in file:\n                try:\n                    value = float(line.strip())\n                    total += value\n                    count += 1\n                except ValueError:\n                    continue  # Skip invalid lines\n        \n        return total / count if count > 0 else 0\n\n# Usage examples\nprocessor = PerformanceAwareProcessor()\n\n# Efficient grouping\ndata = [{'category': 'A', 'value': 1}, {'category': 'B', 'value': 2}, {'category': 'A', 'value': 3}]\ngroups = processor.efficient_grouping(data, lambda x: x['category'])\n\n# Sliding window maximum\nnums = [1, 3, -1, -3, 5, 3, 6, 7]\nmaxes = processor.sliding_window_maximum(nums, 3)  # [3, 3, 5, 5, 6, 7]"
        },
        "java": {
          "description": "Performance-aware Java patterns",
          "code": "// PERFORMANCE-AWARE: Efficient Java patterns\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.stream.Collectors;\n\npublic class PerformanceAwareService {\n    private final ConcurrentHashMap<String, CachedResult> cache = new ConcurrentHashMap<>();\n    private final ScheduledExecutorService cacheCleaner = Executors.newScheduledThreadPool(1);\n    \n    public PerformanceAwareService() {\n        // Clean expired cache entries every 5 minutes\n        cacheCleaner.scheduleAtFixedRate(this::cleanExpiredCache, 5, 5, TimeUnit.MINUTES);\n    }\n    \n    // Efficient caching with TTL\n    public Optional<String> getCachedData(String key) {\n        CachedResult result = cache.get(key);\n        if (result != null && !result.isExpired()) {\n            return Optional.of(result.getData());\n        }\n        return Optional.empty();\n    }\n    \n    public void cacheData(String key, String data, long ttlMillis) {\n        cache.put(key, new CachedResult(data, ttlMillis));\n    }\n    \n    // Efficient string processing\n    public List<String> findDuplicatesEfficient(List<String> items) {\n        // O(n) with HashSet vs O(n²) with nested loops\n        Set<String> seen = ConcurrentHashMap.newKeySet();\n        Set<String> duplicates = ConcurrentHashMap.newKeySet();\n        \n        return items.parallelStream()\n            .filter(item -> !seen.add(item) && duplicates.add(item))\n            .distinct()\n            .collect(Collectors.toList());\n    }\n    \n    // Batch processing to reduce I/O overhead\n    public List<ProcessedItem> processBatch(List<RawItem> items) {\n        final int batchSize = 100;\n        List<CompletableFuture<List<ProcessedItem>>> futures = new ArrayList<>();\n        \n        for (int i = 0; i < items.size(); i += batchSize) {\n            int endIndex = Math.min(i + batchSize, items.size());\n            List<RawItem> batch = items.subList(i, endIndex);\n            \n            CompletableFuture<List<ProcessedItem>> future = \n                CompletableFuture.supplyAsync(() -> processBatchItems(batch));\n            futures.add(future);\n        }\n        \n        return futures.stream()\n            .map(CompletableFuture::join)\n            .flatMap(List::stream)\n            .collect(Collectors.toList());\n    }\n    \n    // Memory-efficient large file processing\n    public double calculateAverageFromLargeFile(String filePath) {\n        // Process line by line instead of loading entire file\n        double sum = 0.0;\n        long count = 0;\n        \n        try (Scanner scanner = new Scanner(new File(filePath))) {\n            while (scanner.hasNextLine()) {\n                try {\n                    double value = Double.parseDouble(scanner.nextLine().trim());\n                    sum += value;\n                    count++;\n                } catch (NumberFormatException e) {\n                    // Skip invalid lines\n                }\n            }\n        }\n        \n        return count > 0 ? sum / count : 0.0;\n    }\n    \n    private void cleanExpiredCache() {\n        cache.entrySet().removeIf(entry -> entry.getValue().isExpired());\n    }\n    \n    private List<ProcessedItem> processBatchItems(List<RawItem> batch) {\n        // Simulate batch processing\n        return batch.stream()\n            .map(item -> new ProcessedItem(item.getId(), item.getData().toUpperCase()))\n            .collect(Collectors.toList());\n    }\n    \n    private static class CachedResult {\n        private final String data;\n        private final long expiryTime;\n        \n        CachedResult(String data, long ttlMillis) {\n            this.data = data;\n            this.expiryTime = System.currentTimeMillis() + ttlMillis;\n        }\n        \n        boolean isExpired() {\n            return System.currentTimeMillis() > expiryTime;\n        }\n        \n        String getData() { return data; }\n    }\n}"
        },
        "csharp": {
          "description": "Performance-aware C# patterns",
          "code": "// PERFORMANCE-AWARE: Efficient C# patterns\nusing System.Collections.Concurrent;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\n\npublic class PerformanceAwareService\n{\n    private readonly ConcurrentDictionary<string, CachedItem> _cache = new();\n    private readonly TimeProvider _timeProvider;\n    \n    public PerformanceAwareService(TimeProvider timeProvider)\n    {\n        _timeProvider = timeProvider;\n        // Start background cache cleanup\n        Task.Run(CleanExpiredCacheAsync);\n    }\n    \n    // Efficient caching with TTL\n    public string? GetCachedData(string key)\n    {\n        if (_cache.TryGetValue(key, out var item) && !item.IsExpired(_timeProvider))\n        {\n            return item.Data;\n        }\n        return null;\n    }\n    \n    public void CacheData(string key, string data, TimeSpan ttl)\n    {\n        _cache[key] = new CachedItem(data, _timeProvider.GetUtcNow().Add(ttl));\n    }\n    \n    // Efficient duplicate finding\n    public IEnumerable<T> FindDuplicates<T>(IEnumerable<T> items)\n    {\n        // O(n) with HashSet vs O(n²) with nested loops\n        var seen = new HashSet<T>();\n        var duplicates = new HashSet<T>();\n        \n        foreach (var item in items)\n        {\n            if (!seen.Add(item))\n            {\n                duplicates.Add(item);\n            }\n        }\n        \n        return duplicates;\n    }\n    \n    // Batch processing with parallelism\n    public async Task<IEnumerable<ProcessedItem>> ProcessBatchAsync(\n        IEnumerable<RawItem> items, \n        int batchSize = 100)\n    {\n        var batches = items\n            .Select((item, index) => (item, index))\n            .GroupBy(x => x.index / batchSize, x => x.item);\n        \n        var tasks = batches.Select(batch => \n            Task.Run(() => ProcessBatchItems(batch)));\n        \n        var results = await Task.WhenAll(tasks);\n        return results.SelectMany(x => x);\n    }\n    \n    // Memory-efficient large file processing\n    public async Task<double> CalculateAverageFromLargeFileAsync(string filePath)\n    {\n        double sum = 0.0;\n        long count = 0;\n        \n        await foreach (var line in File.ReadLinesAsync(filePath))\n        {\n            if (double.TryParse(line.Trim(), out var value))\n            {\n                sum += value;\n                count++;\n            }\n        }\n        \n        return count > 0 ? sum / count : 0.0;\n    }\n    \n    // Efficient grouping with LINQ\n    public ILookup<string, Item> GroupItemsEfficiently(IEnumerable<Item> items)\n    {\n        // LINQ ToLookup is optimized for grouping\n        return items.ToLookup(item => item.Category);\n    }\n    \n    // Sliding window maximum - efficient algorithm\n    public IEnumerable<int> SlidingWindowMaximum(int[] nums, int k)\n    {\n        if (nums.Length == 0 || k == 0) yield break;\n        \n        var window = new LinkedList<int>();\n        \n        for (int i = 0; i < nums.Length; i++)\n        {\n            // Remove elements outside current window\n            while (window.Count > 0 && window.First.Value <= i - k)\n                window.RemoveFirst();\n            \n            // Remove smaller elements from back\n            while (window.Count > 0 && nums[window.Last.Value] <= nums[i])\n                window.RemoveLast();\n            \n            window.AddLast(i);\n            \n            // Add max for current window\n            if (i >= k - 1)\n                yield return nums[window.First.Value];\n        }\n    }\n    \n    private async Task CleanExpiredCacheAsync()\n    {\n        while (true)\n        {\n            await Task.Delay(TimeSpan.FromMinutes(5));\n            var expiredKeys = _cache\n                .Where(kvp => kvp.Value.IsExpired(_timeProvider))\n                .Select(kvp => kvp.Key)\n                .ToList();\n            \n            foreach (var key in expiredKeys)\n            {\n                _cache.TryRemove(key, out _);\n            }\n        }\n    }\n    \n    private IEnumerable<ProcessedItem> ProcessBatchItems(IEnumerable<RawItem> batch)\n    {\n        return batch.Select(item => \n            new ProcessedItem(item.Id, item.Data.ToUpper()));\n    }\n    \n    private record CachedItem(string Data, DateTimeOffset ExpiryTime)\n    {\n        public bool IsExpired(TimeProvider timeProvider) => \n            timeProvider.GetUtcNow() > ExpiryTime;\n    }\n}"
        }
      }
    },
    {
      "id": "modularity-cohesion",
      "name": "Modularity and Cohesion",
      "category": "Development Principles",
      "description": "Group related functionality together (high cohesion) while minimizing dependencies between modules (low coupling). Create focused, independent components that are easy to understand, test, and maintain.",
      "when_to_use": "[\"Designing software architecture\",\"Organizing code into modules\",\"Planning component boundaries\",\"Refactoring monolithic code\",\"Building reusable libraries\"]",
      "benefits": "[\"Easier maintenance\",\"Better testability\",\"Improved reusability\",\"Reduced complexity\",\"Parallel development support\"]",
      "drawbacks": "[\"Over-modularization complexity\",\"Interface design challenges\",\"Dependency management overhead\",\"Potential performance impact\",\"Coordination between modules\"]",
      "use_cases": "[\"Microservices architecture\",\"Library design\",\"Plugin systems\",\"Layered architecture\",\"Component-based frameworks\"]",
      "complexity": "Medium",
      "tags": "[\"principle\",\"modularity\",\"cohesion\",\"coupling\",\"architecture\"]",
      "examples": {
        "typescript": {
          "description": "Modular design with high cohesion and low coupling",
          "code": "// HIGH COHESION: Related functionality grouped together\nclass UserAuthentication {\n  // All authentication-related methods in one place\n  async login(credentials: LoginCredentials): Promise<AuthToken> {\n    // Login logic\n  }\n  \n  async logout(token: AuthToken): Promise<void> {\n    // Logout logic\n  }\n  \n  async refreshToken(token: AuthToken): Promise<AuthToken> {\n    // Token refresh logic\n  }\n  \n  async validateToken(token: AuthToken): Promise<boolean> {\n    // Token validation logic\n  }\n}\n\nclass UserProfile {\n  // All profile-related methods together\n  async getProfile(userId: string): Promise<UserProfile> {\n    // Profile retrieval\n  }\n  \n  async updateProfile(userId: string, updates: Partial<UserProfile>): Promise<UserProfile> {\n    // Profile updates\n  }\n  \n  async uploadAvatar(userId: string, avatar: File): Promise<string> {\n    // Avatar handling\n  }\n}\n\n// LOW COUPLING: Modules depend on abstractions, not concretions\ninterface NotificationService {\n  sendWelcomeEmail(user: User): Promise<void>;\n  sendPasswordReset(user: User): Promise<void>;\n}\n\nclass UserService {\n  constructor(\n    private auth: UserAuthentication,\n    private profile: UserProfile,\n    private notifications: NotificationService\n  ) {}\n  \n  async register(userData: RegisterData): Promise<User> {\n    // User registration logic\n    const user = await this.createUser(userData);\n    \n    // Loose coupling: depends on interface, not implementation\n    await this.notifications.sendWelcomeEmail(user);\n    \n    return user;\n  }\n  \n  private async createUser(userData: RegisterData): Promise<User> {\n    // User creation logic (private, encapsulated)\n  }\n}\n\n// MODULAR FILE ORGANIZATION\n// user/\n//   ├── authentication.ts     (Authentication module)\n//   ├── profile.ts            (Profile module)\n//   ├── notifications.ts      (Notification module)\n//   ├── user-service.ts       (User service orchestrator)\n//   └── types.ts              (Shared types)\n\n// Each module has single responsibility and clear boundaries"
        },
        "python": {
          "description": "Modular Python application structure",
          "code": "# HIGH COHESION: Related functionality in focused modules\n\n# data_access.py - Data access module (cohesive)\nclass DatabaseConnection:\n    def __init__(self, connection_string):\n        self.connection_string = connection_string\n    \n    def connect(self):\n        # Connection logic\n        pass\n    \n    def execute_query(self, query, params=None):\n        # Query execution\n        pass\n    \n    def close(self):\n        # Cleanup\n        pass\n\n# business_logic.py - Business rules module (cohesive)\nclass OrderProcessor:\n    def __init__(self, db_connection):\n        self.db = db_connection\n    \n    def calculate_total(self, items):\n        # Pricing logic\n        pass\n    \n    def apply_discounts(self, order):\n        # Discount logic\n        pass\n    \n    def validate_order(self, order):\n        # Validation logic\n        pass\n    \n    def process_payment(self, order):\n        # Payment processing\n        pass\n\n# LOW COUPLING: Dependency injection with interfaces\n\nfrom abc import ABC, abstractmethod\n\nclass PaymentGateway(ABC):\n    @abstractmethod\n    def charge(self, amount, card_details):\n        pass\n\nclass StripeGateway(PaymentGateway):\n    def charge(self, amount, card_details):\n        # Stripe implementation\n        pass\n\nclass PayPalGateway(PaymentGateway):\n    def charge(self, amount, card_details):\n        # PayPal implementation\n        pass\n\n# Service depends on abstraction, not concrete implementation\nclass PaymentService:\n    def __init__(self, gateway: PaymentGateway):\n        self.gateway = gateway\n    \n    def process_payment(self, order):\n        # Use injected gateway\n        return self.gateway.charge(order.total, order.card_details)\n\n# MODULAR PACKAGE STRUCTURE\n# ecommerce/\n# ├── __init__.py\n# ├── data/\n# │   ├── __init__.py\n# │   ├── database.py\n# │   └── models.py\n# ├── business/\n# │   ├── __init__.py\n# │   ├── order_processor.py\n# │   └── payment_service.py\n# ├── interfaces/\n# │   ├── __init__.py\n# │   └── payment_gateway.py\n# └── utils/\n# │   ├── __init__.py\n# │   └── validators.py\n\n# Each module can be developed, tested, and deployed independently"
        },
        "java": {
          "description": "Modular Java application with Spring",
          "code": "// HIGH COHESION: Related functionality in focused packages\n\n// Package: com.example.user.authentication\n@Service\npublic class UserAuthenticationService {\n    // All authentication logic in one place\n    public AuthenticationResult authenticate(LoginRequest request) {\n        // Authentication logic\n    }\n    \n    public void logout(String token) {\n        // Logout logic\n    }\n    \n    public String refreshToken(String token) {\n        // Token refresh logic\n    }\n}\n\n// Package: com.example.user.profile\n@Service\npublic class UserProfileService {\n    // All profile operations together\n    public UserProfile getProfile(Long userId) {\n        // Profile retrieval\n    }\n    \n    public UserProfile updateProfile(Long userId, ProfileUpdate update) {\n        // Profile updates\n    }\n    \n    public String uploadAvatar(Long userId, MultipartFile avatar) {\n        // Avatar handling\n    }\n}\n\n// LOW COUPLING: Dependency injection with interfaces\npublic interface NotificationService {\n    void sendWelcomeEmail(User user);\n    void sendPasswordReset(User user);\n}\n\n@Service\npublic class EmailNotificationService implements NotificationService {\n    // Email implementation\n}\n\n@Service\npublic class UserService {\n    \n    private final UserAuthenticationService authService;\n    private final UserProfileService profileService;\n    private final NotificationService notificationService;\n    \n    // Constructor injection for loose coupling\n    public UserService(\n        UserAuthenticationService authService,\n        UserProfileService profileService,\n        NotificationService notificationService\n    ) {\n        this.authService = authService;\n        this.profileService = profileService;\n        this.notificationService = notificationService;\n    }\n    \n    @Transactional\n    public User register(UserRegistration registration) {\n        // Business logic orchestration\n        User user = createUser(registration);\n        \n        // Loose coupling through interface\n        notificationService.sendWelcomeEmail(user);\n        \n        return user;\n    }\n    \n    private User createUser(UserRegistration registration) {\n        // User creation logic\n    }\n}\n\n// MODULAR PROJECT STRUCTURE\n// src/main/java/com/example/\n// ├── user/\n// │   ├── authentication/\n// │   │   ├── UserAuthenticationService.java\n// │   │   └── AuthenticationResult.java\n// │   ├── profile/\n// │   │   ├── UserProfileService.java\n// │   │   └── ProfileUpdate.java\n// │   ├── notification/\n// │   │   ├── NotificationService.java\n// │   │   └── EmailNotificationService.java\n// │   ├── UserService.java\n// │   └── User.java\n// ├── order/\n// │   ├── OrderService.java\n// │   ├── OrderRepository.java\n// │   └── Order.java\n// └── common/\n//     ├── exceptions/\n//     └── utils/"
        },
        "csharp": {
          "description": "Modular C# application with dependency injection",
          "code": "// HIGH COHESION: Related functionality in focused namespaces\n\n// Namespace: ECommerce.User.Authentication\npublic class UserAuthenticationService : IUserAuthenticationService\n{\n    // All authentication logic in one place\n    public async Task<AuthenticationResult> AuthenticateAsync(LoginRequest request)\n    {\n        // Authentication logic\n    }\n    \n    public async Task LogoutAsync(string token)\n    {\n        // Logout logic\n    }\n    \n    public async Task<string> RefreshTokenAsync(string token)\n    {\n        // Token refresh logic\n    }\n}\n\n// Namespace: ECommerce.User.Profile\npublic class UserProfileService : IUserProfileService\n{\n    // All profile operations together\n    public async Task<UserProfile> GetProfileAsync(long userId)\n    {\n        // Profile retrieval\n    }\n    \n    public async Task<UserProfile> UpdateProfileAsync(long userId, ProfileUpdate update)\n    {\n        // Profile updates\n    }\n    \n    public async Task<string> UploadAvatarAsync(long userId, IFormFile avatar)\n    {\n        // Avatar handling\n    }\n}\n\n// LOW COUPLING: Dependency injection with interfaces\npublic interface INotificationService\n{\n    Task SendWelcomeEmailAsync(User user);\n    Task SendPasswordResetAsync(User user);\n}\n\npublic class EmailNotificationService : INotificationService\n{\n    // Email implementation\n}\n\npublic class UserService : IUserService\n{\n    private readonly IUserAuthenticationService _authService;\n    private readonly IUserProfileService _profileService;\n    private readonly INotificationService _notificationService;\n    \n    // Constructor injection for loose coupling\n    public UserService(\n        IUserAuthenticationService authService,\n        IUserProfileService profileService,\n        INotificationService notificationService\n    )\n    {\n        _authService = authService;\n        _profileService = profileService;\n        _notificationService = notificationService;\n    }\n    \n    public async Task<User> RegisterAsync(UserRegistration registration)\n    {\n        // Business logic orchestration\n        var user = await CreateUserAsync(registration);\n        \n        // Loose coupling through interface\n        await _notificationService.SendWelcomeEmailAsync(user);\n        \n        return user;\n    }\n    \n    private async Task<User> CreateUserAsync(UserRegistration registration)\n    {\n        // User creation logic\n    }\n}\n\n// MODULAR PROJECT STRUCTURE\n// ECommerce/\n// ├── User/\n// │   ├── Authentication/\n// │   │   ├── IUserAuthenticationService.cs\n// │   │   ├── UserAuthenticationService.cs\n// │   │   └── AuthenticationResult.cs\n// │   ├── Profile/\n// │   │   ├── IUserProfileService.cs\n// │   │   ├── UserProfileService.cs\n// │   │   └── ProfileUpdate.cs\n// │   ├── Notification/\n// │   │   ├── INotificationService.cs\n// │   │   └── EmailNotificationService.cs\n// │   ├── IUserService.cs\n// │   ├── UserService.cs\n// │   └── User.cs\n// ├── Order/\n// │   ├── IOrderService.cs\n// │   ├── OrderService.cs\n// │   ├── IOrderRepository.cs\n// │   └── Order.cs\n// └── Common/\n//     ├── Exceptions/\n//     └── Utils/\n\n// Program.cs - Service registration\nbuilder.Services.AddScoped<IUserAuthenticationService, UserAuthenticationService>();\nbuilder.Services.AddScoped<IUserProfileService, UserProfileService>();\nbuilder.Services.AddScoped<INotificationService, EmailNotificationService>();\nbuilder.Services.AddScoped<IUserService, UserService>();"
        }
      }
    }
  ]
}
