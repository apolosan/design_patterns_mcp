{
  "id": "sql-indexing-strategies",
  "name": "Index Strategy Pattern",
  "category": "Performance",
  "description": "Strategic creation and management of database indexes to optimize query performance. Covers clustered vs non-clustered indexes, composite indexes, covering indexes, filtered indexes, and index maintenance. Proper indexing is critical for query performance but requires careful planning to avoid overhead.",
  "when_to_use": "[\"Slow query performance on large tables\",\"Frequent queries on specific columns\",\"JOIN operations on foreign keys\",\"WHERE clause filters\",\"ORDER BY and GROUP BY operations\",\"Preventing full table scans\"]",
  "benefits": "[\"Dramatically speeds up SELECT queries\",\"Improves JOIN performance\",\"Enables faster sorting and grouping\",\"Reduces I/O operations\",\"Supports query optimizer decisions\",\"Essential for large tables\"]",
  "drawbacks": "[\"Slows down INSERT, UPDATE, DELETE\",\"Consumes additional disk space\",\"Requires maintenance (rebuild/reorganize)\",\"Too many indexes hurt performance\",\"Index fragmentation over time\",\"Requires ongoing monitoring\"]",
  "use_cases": "[\"Primary and foreign key columns\",\"Frequently searched columns\",\"JOIN columns\",\"Columns in WHERE clauses\",\"ORDER BY columns\",\"High-cardinality columns\"]",
  "complexity": "High",
  "tags": ["sql", "indexing", "performance", "clustered-index", "non-clustered", "composite-index", "covering-index"],
  "examples": {
    "tsql": {
      "description": "SQL Server index types and strategies with maintenance operations",
      "code": "-- Clustered index (one per table, determines physical order)\nCREATE CLUSTERED INDEX IX_Orders_OrderID ON Orders(OrderID);\n\n-- Non-clustered index (multiple allowed, separate structure)\nCREATE NONCLUSTERED INDEX IX_Orders_CustomerID ON Orders(CustomerID);\n\n-- Composite index (multiple columns)\nCREATE NONCLUSTERED INDEX IX_Orders_Customer_Date \n  ON Orders(CustomerID, OrderDate DESC);\n\n-- Covering index (INCLUDE additional columns)\nCREATE NONCLUSTERED INDEX IX_Orders_Customer_Covering\n  ON Orders(CustomerID)\n  INCLUDE (OrderDate, TotalAmount, Status);\n-- Query uses only index, no table lookup needed\n\n-- Filtered index (subset of data)\nCREATE NONCLUSTERED INDEX IX_Orders_Active\n  ON Orders(OrderDate)\n  WHERE Status = 'Active';  -- Smaller, faster for active orders\n\n-- Unique index (enforces uniqueness)\nCREATE UNIQUE NONCLUSTERED INDEX IX_Customers_Email\n  ON Customers(Email);\n\n-- Index with FILLFACTOR (leave space for future inserts)\nCREATE NONCLUSTERED INDEX IX_Orders_Date\n  ON Orders(OrderDate)\n  WITH (FILLFACTOR = 80);  -- 20% free space\n\n-- Columnstore index (for analytics/data warehouse)\nCREATE NONCLUSTERED COLUMNSTORE INDEX IX_Sales_Analytics\n  ON Sales (ProductID, CustomerID, OrderDate, Quantity, Revenue);\n\n-- Index on computed column\nALTER TABLE Orders ADD TotalWithTax AS (SubTotal * 1.08) PERSISTED;\nCREATE INDEX IX_Orders_TotalWithTax ON Orders(TotalWithTax);\n\n-- Index maintenance: Rebuild (recreates index)\nALTER INDEX IX_Orders_CustomerID ON Orders REBUILD;\n\n-- Rebuild all indexes on table\nALTER INDEX ALL ON Orders REBUILD;\n\n-- Reorganize (defragments without full rebuild)\nALTER INDEX IX_Orders_CustomerID ON Orders REORGANIZE;\n\n-- Disable and re-enable index\nALTER INDEX IX_Orders_Date ON Orders DISABLE;\nALTER INDEX IX_Orders_Date ON Orders REBUILD;\n\n-- Drop index\nDROP INDEX IX_Orders_OldIndex ON Orders;\n\n-- Check index fragmentation\nSELECT \n  OBJECT_NAME(ips.object_id) AS TableName,\n  i.name AS IndexName,\n  ips.index_type_desc,\n  ips.avg_fragmentation_in_percent,\n  ips.page_count\nFROM sys.dm_db_index_physical_stats(\n  DB_ID(), NULL, NULL, NULL, 'LIMITED'\n) ips\nJOIN sys.indexes i ON ips.object_id = i.object_id \n  AND ips.index_id = i.index_id\nWHERE ips.avg_fragmentation_in_percent > 10\n  AND ips.page_count > 1000\nORDER BY ips.avg_fragmentation_in_percent DESC;\n\n-- Find missing indexes (recommendations)\nSELECT \n  migs.avg_user_impact * (migs.user_seeks + migs.user_scans) AS impact,\n  mid.statement AS table_name,\n  mid.equality_columns,\n  mid.inequality_columns,\n  mid.included_columns,\n  'CREATE INDEX IX_' + \n    OBJECT_NAME(mid.object_id) + '_' + \n    REPLACE(REPLACE(REPLACE(mid.equality_columns, ', ', '_'), '[', ''), ']', '') +\n    ' ON ' + mid.statement + ' (' + \n    ISNULL(mid.equality_columns, '') + \n    CASE WHEN mid.inequality_columns IS NOT NULL \n      THEN ',' + mid.inequality_columns ELSE '' END + ')' +\n    CASE WHEN mid.included_columns IS NOT NULL \n      THEN ' INCLUDE (' + mid.included_columns + ')' ELSE '' END \n    AS create_statement\nFROM sys.dm_db_missing_index_groups mig\nJOIN sys.dm_db_missing_index_group_stats migs \n  ON mig.index_group_handle = migs.group_handle\nJOIN sys.dm_db_missing_index_details mid \n  ON mig.index_handle = mid.index_handle\nWHERE migs.avg_user_impact > 50\nORDER BY impact DESC;\n\n-- Find unused indexes\nSELECT \n  OBJECT_NAME(i.object_id) AS TableName,\n  i.name AS IndexName,\n  i.type_desc,\n  ius.user_seeks,\n  ius.user_scans,\n  ius.user_lookups,\n  ius.user_updates\nFROM sys.indexes i\nLEFT JOIN sys.dm_db_index_usage_stats ius\n  ON i.object_id = ius.object_id AND i.index_id = ius.index_id\nWHERE OBJECTPROPERTY(i.object_id, 'IsUserTable') = 1\n  AND i.type_desc != 'HEAP'\n  AND (ius.user_seeks + ius.user_scans + ius.user_lookups) = 0\n  AND ius.user_updates > 0\nORDER BY ius.user_updates DESC;"
    },
    "postgresql": {
      "description": "PostgreSQL index types including B-tree, Hash, GIN, GiST, and BRIN",
      "code": "-- B-tree index (default, most common)\nCREATE INDEX idx_orders_customer ON orders(customer_id);\n\n-- Composite B-tree index\nCREATE INDEX idx_orders_customer_date ON orders(customer_id, order_date DESC);\n\n-- Unique index\nCREATE UNIQUE INDEX idx_users_email ON users(email);\n\n-- Partial/filtered index\nCREATE INDEX idx_orders_active ON orders(order_date)\n  WHERE status = 'active';\n\n-- Expression/functional index\nCREATE INDEX idx_users_email_lower ON users(LOWER(email));\n\n-- Multi-column index with mixed order\nCREATE INDEX idx_products_category_price \n  ON products(category_id ASC, price DESC);\n\n-- Hash index (equality only, PostgreSQL 10+)\nCREATE INDEX idx_products_sku_hash ON products USING HASH (sku);\n\n-- GIN index for full-text search\nCREATE INDEX idx_articles_content_gin ON articles \n  USING GIN (to_tsvector('english', content));\n\n-- GIN index for JSONB\nCREATE INDEX idx_users_preferences_gin ON users USING GIN (preferences);\n\n-- GIN index for arrays\nCREATE INDEX idx_products_tags_gin ON products USING GIN (tags);\n\n-- GiST index for geometric data\nCREATE INDEX idx_locations_point_gist ON locations USING GIST (location);\n\n-- BRIN index (block range, for large sequential tables)\nCREATE INDEX idx_logs_timestamp_brin ON logs USING BRIN (timestamp);\n\n-- Covering index with INCLUDE\nCREATE INDEX idx_orders_customer_covering ON orders(customer_id)\n  INCLUDE (order_date, total_amount);\n\n-- Concurrent index creation (doesn't block writes)\nCREATE INDEX CONCURRENTLY idx_orders_date ON orders(order_date);\n\n-- Reindex single index\nREINDEX INDEX CONCURRENTLY idx_orders_customer;\n\n-- Reindex all indexes on table\nREINDEX TABLE CONCURRENTLY orders;\n\n-- Drop index\nDROP INDEX CONCURRENTLY IF EXISTS idx_old_index;\n\n-- Check index size and usage\nSELECT \n  schemaname,\n  tablename,\n  indexname,\n  pg_size_pretty(pg_relation_size(indexrelid)) AS index_size,\n  idx_scan AS index_scans,\n  idx_tup_read AS tuples_read,\n  idx_tup_fetch AS tuples_fetched\nFROM pg_stat_user_indexes\nWHERE schemaname = 'public'\nORDER BY pg_relation_size(indexrelid) DESC;\n\n-- Find unused indexes\nSELECT \n  schemaname,\n  tablename,\n  indexname,\n  idx_scan,\n  pg_size_pretty(pg_relation_size(indexrelid)) AS size\nFROM pg_stat_user_indexes\nWHERE idx_scan = 0\n  AND indexrelname NOT LIKE '%_pkey'\nORDER BY pg_relation_size(indexrelid) DESC;\n\n-- Find duplicate indexes\nSELECT \n  pg_size_pretty(SUM(pg_relation_size(idx))::BIGINT) AS size,\n  (array_agg(idx))[1] AS idx1,\n  (array_agg(idx))[2] AS idx2,\n  (array_agg(idx))[3] AS idx3\nFROM (\n  SELECT \n    indexrelid::regclass AS idx,\n    (indrelid::text || E'\\n' || indclass::text || E'\\n' || \n     indkey::text || E'\\n' || COALESCE(indexprs::text, '') || E'\\n' || \n     COALESCE(indpred::text, '')) AS key\n  FROM pg_index\n) sub\nGROUP BY key\nHAVING COUNT(*) > 1;\n\n-- Check index bloat\nSELECT \n  schemaname,\n  tablename,\n  indexname,\n  pg_size_pretty(pg_relation_size(indexrelid)) AS index_size,\n  ROUND(100 * (pg_relation_size(indexrelid) - \n    (pg_relation_size(indexrelid, 'main') - pg_relation_size(indexrelid, 'fsm'))) / \n    NULLIF(pg_relation_size(indexrelid), 0), 2) AS bloat_pct\nFROM pg_stat_user_indexes\nWHERE pg_relation_size(indexrelid) > 100000000  -- > 100MB\nORDER BY pg_relation_size(indexrelid) DESC;\n\n-- Autovacuum settings for better index maintenance\nALTER TABLE orders SET (\n  autovacuum_vacuum_scale_factor = 0.05,\n  autovacuum_analyze_scale_factor = 0.02\n);"
    },
    "mysql": {
      "description": "MySQL index types and optimization strategies",
      "code": "-- Primary key (clustered in InnoDB)\nALTER TABLE orders ADD PRIMARY KEY (order_id);\n\n-- Secondary index (B-tree)\nCREATE INDEX idx_orders_customer ON orders(customer_id);\n\n-- Composite index\nCREATE INDEX idx_orders_customer_date ON orders(customer_id, order_date);\n\n-- Unique index\nCREATE UNIQUE INDEX idx_users_email ON users(email);\n\n-- Full-text index\nCREATE FULLTEXT INDEX idx_articles_content ON articles(title, content);\n\n-- Spatial index (for geometric data)\nCREATE SPATIAL INDEX idx_locations_point ON locations(coordinates);\n\n-- Prefix index (for long strings)\nCREATE INDEX idx_articles_title_prefix ON articles(title(50));\n\n-- Descending index (MySQL 8.0+)\nCREATE INDEX idx_orders_date_desc ON orders(order_date DESC);\n\n-- Invisible index (not used by optimizer, for testing)\nCREATE INDEX idx_test ON orders(status) INVISIBLE;\nALTER INDEX idx_test ON orders VISIBLE;\n\n-- Functional/generated column index\nALTER TABLE users ADD full_name VARCHAR(200) \n  GENERATED ALWAYS AS (CONCAT(first_name, ' ', last_name)) STORED;\nCREATE INDEX idx_users_fullname ON users(full_name);\n\n-- Multi-valued index for JSON arrays (MySQL 8.0.17+)\nALTER TABLE products ADD INDEX idx_tags (\n  (CAST(attributes->'$.tags' AS CHAR(100) ARRAY))\n);\n\n-- Drop index\nDROP INDEX idx_old_index ON orders;\n\n-- Analyze table (update statistics)\nANALYZE TABLE orders;\n\n-- Check index cardinality\nSHOW INDEX FROM orders;\n\n-- Force index usage\nSELECT * FROM orders\nFORCE INDEX (idx_orders_customer)\nWHERE customer_id = 123;\n\n-- Ignore specific index\nSELECT * FROM orders\nIGNORE INDEX (idx_orders_date)\nWHERE customer_id = 123;\n\n-- Find tables without primary key\nSELECT \n  tables.table_schema,\n  tables.table_name\nFROM information_schema.tables\nLEFT JOIN information_schema.statistics \n  ON tables.table_schema = statistics.table_schema\n  AND tables.table_name = statistics.table_name\n  AND statistics.index_name = 'PRIMARY'\nWHERE tables.table_schema NOT IN ('mysql', 'information_schema', 'performance_schema')\n  AND tables.table_type = 'BASE TABLE'\n  AND statistics.index_name IS NULL;\n\n-- Check index size\nSELECT \n  table_name,\n  index_name,\n  ROUND(stat_value * @@innodb_page_size / 1024 / 1024, 2) AS size_mb\nFROM mysql.innodb_index_stats\nWHERE database_name = 'your_database'\n  AND stat_name = 'size'\nORDER BY stat_value DESC;\n\n-- Find duplicate indexes\nSELECT \n  t1.table_name,\n  t1.index_name AS index_1,\n  t2.index_name AS index_2,\n  GROUP_CONCAT(t1.column_name ORDER BY t1.seq_in_index) AS columns\nFROM information_schema.statistics t1\nJOIN information_schema.statistics t2\n  ON t1.table_schema = t2.table_schema\n  AND t1.table_name = t2.table_name\n  AND t1.index_name < t2.index_name\n  AND t1.column_name = t2.column_name\n  AND t1.seq_in_index = t2.seq_in_index\nWHERE t1.table_schema = 'your_database'\nGROUP BY t1.table_name, t1.index_name, t2.index_name\nHAVING COUNT(*) > 1;\n\n-- Optimize table (rebuild, update stats)\nOPTIMIZE TABLE orders;\n\n-- Enable/disable index statistics collection\nALTER TABLE orders STATS_PERSISTENT = 1;\nALTER TABLE orders STATS_AUTO_RECALC = 1;"
    }
  }
}
