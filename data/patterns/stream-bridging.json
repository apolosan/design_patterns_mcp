{
  "id": "stream-bridging",
  "name": "Stream Bridging Pattern",
  "category": "Edge Computing",
  "description": "Connects edge device data streams to cloud services with buffering and reconnection handling",
  "when_to_use": "Rural IoT\nMobile devices\nSatellite connectivity\nCost-sensitive deployments",
  "benefits": "Efficient bandwidth usage\nResilient connections\nCost optimization\nData prioritization",
  "drawbacks": "Buffer management complexity\nLatency\nData loss risk\nConfiguration complexity",
  "use_cases": "Rural IoT\nMobile data collection\nSatellite telemetry\nCost-optimized streaming",
  "complexity": "Medium",
  "tags": [
    "edge",
    "stream-bridging",
    "data-transmission",
    "buffering"
  ],
  "examples": {
    "typescript": {
      "language": "typescript",
      "code": "// Stream Bridging: connect edge streams to cloud\n\ninterface StreamConfig {\n  bufferSize: number;\n  batchSize: number;\n  compressionEnabled: boolean;\n  reconnectDelay: number;\n  maxRetries: number;\n  priorityTags: string[];\n}\n\ninterface StreamData {\n  id: string;\n  timestamp: Date;\n  source: string;\n  payload: any;\n  priority: number;\n  tags: string[];\n}\n\ninterface BridgeStats {\n  messagesSent: number;\n  messagesBuffered: number;\n  bytesSent: number;\n  retries: number;\n  lastSuccessfulSend: Date | null;\n}\n\nclass StreamBridge {\n  private buffer: RingBuffer<StreamData>;\n  private batcher: BatchProcessor;\n  private compressor: DataCompressor;\n  private cloudConnector: CloudConnector;\n  private config: StreamConfig;\n  private stats: BridgeStats;\n  private isConnected: boolean = false;\n  private reconnectTimer: NodeJS.Timeout | null = null;\n\n  constructor(config: StreamConfig, cloudConnector: CloudConnector) {\n    this.config = config;\n    this.cloudConnector = cloudConnector;\n    this.buffer = new RingBuffer<StreamData>(config.bufferSize);\n    this.batcher = new BatchProcessor(config.batchSize);\n    this.compressor = new DataCompressor();\n    this.stats = {\n      messagesSent: 0,\n      messagesBuffered: 0,\n      bytesSent: 0,\n      retries: 0,\n      lastSuccessfulSend: null\n    };\n  }\n\n  async connect(): Promise<void> {\n    try {\n      await this.cloudConnector.connect();\n      this.isConnected = true;\n      console.log(\"Stream bridge connected to cloud\");\n      this.startSending();\n    } catch (error) {\n      console.error(\"Failed to connect to cloud:\", error);\n      this.scheduleReconnect();\n    }\n  }\n\n  async disconnect(): Promise<void> {\n    this.isConnected = false;\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n    }\n    await this.cloudConnector.disconnect();\n    console.log(\"Stream bridge disconnected\");\n  }\n\n  async ingest(data: StreamData): Promise<IngestResult> {\n    if (this.buffer.isFull()) {\n      const dropped = this.buffer.enqueue(data);\n      if (dropped) {\n        this.stats.messagesBuffered++;\n        return { success: false, reason: \"Buffer full\", dropped: true };\n      }\n    }\n\n    this.buffer.enqueue(data);\n    this.stats.messagesBuffered++;\n\n    return { success: true, buffered: true };\n  }\n\n  private async startSending(): Promise<void> {\n    while (this.isConnected) {\n      if (this.buffer.isEmpty()) {\n        await this.sleep(1000);\n        continue;\n      }\n\n      const batch = await this.collectBatch();\n      if (batch.length === 0) continue;\n\n      await this.sendBatch(batch);\n    }\n  }\n\n  private async collectBatch(): Promise<StreamData[]> {\n    const batch: StreamData[] = [];\n    const priorityOrder = this.config.priorityTags;\n\n    while (batch.length < this.config.batchSize && !this.buffer.isEmpty()) {\n      const item = this.buffer.dequeue();\n      if (item) {\n        batch.push(item);\n      }\n    }\n\n    return batch;\n  }\n\n  private async sendBatch(batch: StreamData[]): Promise<void> {\n    try {\n      let payload = batch.map(d => d.payload);\n\n      if (this.config.compressionEnabled) {\n        payload = await this.compressor.compress(payload);\n      }\n\n      await this.cloudConnector.send({\n        count: batch.length,\n        data: payload,\n        metadata: batch.map(d => ({ id: d.id, priority: d.priority }))\n      });\n\n      this.stats.messagesSent += batch.length;\n      this.stats.bytesSent += JSON.stringify(payload).length;\n      this.stats.lastSuccessfulSend = new Date();\n    } catch (error) {\n      console.error(\"Failed to send batch:\", error);\n      await this.handleSendFailure(batch);\n    }\n  }\n\n  private async handleSendFailure(batch: StreamData[]): Promise<void> {\n    this.stats.retries++;\n\n    for (const item of batch) {\n      await this.ingest(item);\n    }\n\n    if (this.stats.retries >= this.config.maxRetries) {\n      this.stats.retries = 0;\n      await this.disconnect();\n      this.scheduleReconnect();\n    }\n  }\n\n  private scheduleReconnect(): Promise<void> {\n    return new Promise((resolve) => {\n      this.reconnectTimer = setTimeout(async () => {\n        await this.connect();\n        resolve();\n      }, this.config.reconnectDelay);\n    });\n  }\n\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  getStats(): BridgeStats {\n    return { ...this.stats };\n  }\n\n  getBufferStatus(): { used: number; capacity: number; utilization: number } {\n    return {\n      used: this.buffer.size(),\n      capacity: this.config.bufferSize,\n      utilization: this.buffer.size() / this.config.bufferSize\n    };\n  }\n}\n\nclass RingBuffer<T> {\n  private buffer: T[];\n  private head: number = 0;\n  private tail: number = 0;\n  private count: number = 0;\n\n  constructor(capacity: number) {\n    this.buffer = new Array(capacity);\n  }\n\n  enqueue(item: T): T | null {\n    if (this.count === this.buffer.length) {\n      return item;\n    }\n    this.buffer[this.tail] = item;\n    this.tail = (this.tail + 1) % this.buffer.length;\n    this.count++;\n    return null;\n  }\n\n  dequeue(): T | null {\n    if (this.count === 0) return null;\n    const item = this.buffer[this.head];\n    this.head = (this.head + 1) % this.buffer.length;\n    this.count--;\n    return item;\n  }\n\n  isEmpty(): boolean {\n    return this.count === 0;\n  }\n\n  isFull(): boolean {\n    return this.count === this.buffer.length;\n  }\n\n  size(): number {\n    return this.count;\n  }\n}\n\nclass BatchProcessor {\n  constructor(private batchSize: number) {}\n\n  async process<T>(items: T[]): T[][] {\n    const batches: T[][] = [];\n    for (let i = 0; i < items.length; i += this.batchSize) {\n      batches.push(items.slice(i, i + this.batchSize));\n    }\n    return batches;\n  }\n}\n\nclass DataCompressor {\n  async compress<T>(data: T[]): Promise<T[]> {\n    return data;\n  }\n\n  async decompress<T>(data: T[]): Promise<T[]> {\n    return data;\n  }\n}\n\ninterface CloudConnector {\n  connect(): Promise<void>;\n  disconnect(): Promise<void>;\n  send(data: any): Promise<void>;\n}\n\ninterface IngestResult {\n  success: boolean;\n  buffered?: boolean;\n  reason?: string;\n  dropped?: boolean;\n}"
    }
  },
  "relationships": [
    {
      "target_pattern_id": "edge-processing",
      "type": "uses",
      "description": "Stream bridging sends processed edge data to cloud"
    },
    {
      "target_pattern_id": "compression",
      "type": "uses",
      "description": "Stream bridging often uses compression"
    }
  ]
}
