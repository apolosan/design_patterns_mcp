{
  "id": "event-listener-performance-antipatterns",
  "name": "Event Listener Performance Antipatterns",
  "category": "Async/Event-Driven",
  "description": "Common performance issues and antipatterns when working with event listeners",
  "when_to_use": "Performance optimization, memory leak prevention, large-scale applications",
  "benefits": "Better performance, reduced memory usage, improved user experience",
  "drawbacks": "Increased complexity, potential for bugs if not handled correctly",
  "use_cases": "SPAs, large lists, real-time applications, games",
  "complexity": "Medium",
  "tags": ["javascript", "events", "performance", "memory-leaks", "antipatterns"],
  "examples": {
    "typescript": {
      "language": "typescript",
      "code": "// Antipattern: Adding listeners in loops\nclass BadList {\n  constructor(items: string[]) {\n    items.forEach((item, index) => {\n      const element = document.createElement('div');\n      element.textContent = item;\n      element.addEventListener('click', () => {\n        console.log(`Clicked ${item} at index ${index}`);\n      }); // Creates many listeners\n      document.body.appendChild(element);\n    });\n  }\n}\n\n// Good pattern: Event delegation\nclass GoodList {\n  constructor(items: string[]) {\n    const container = document.createElement('div');\n    container.addEventListener('click', (event) => {\n      const target = event.target as HTMLElement;\n      if (target.classList.contains('list-item')) {\n        const index = target.dataset.index!;\n        console.log(`Clicked item at index ${index}`);\n      }\n    });\n    \n    items.forEach((item, index) => {\n      const element = document.createElement('div');\n      element.className = 'list-item';\n      element.dataset.index = index.toString();\n      element.textContent = item;\n      container.appendChild(element);\n    });\n    \n    document.body.appendChild(container);\n  }\n}\n\n// Antipattern: Not removing listeners\nclass MemoryLeak {\n  private intervalId: number;\n  \n  constructor(button: HTMLElement) {\n    button.addEventListener('click', this.handleClick);\n    this.intervalId = setInterval(() => {\n      console.log('Still running...');\n    }, 1000);\n  }\n  \n  private handleClick = () => {\n    console.log('Clicked');\n  };\n  \n  // Missing cleanup!\n}\n\n// Good pattern: Proper cleanup\nclass CleanComponent {\n  private button: HTMLElement;\n  private intervalId: number;\n  private boundHandler: () => void;\n  \n  constructor(button: HTMLElement) {\n    this.button = button;\n    this.boundHandler = this.handleClick.bind(this);\n    button.addEventListener('click', this.boundHandler);\n    this.intervalId = setInterval(() => {\n      console.log('Running...');\n    }, 1000);\n  }\n  \n  private handleClick() {\n    console.log('Clicked');\n  }\n  \n  destroy() {\n    this.button.removeEventListener('click', this.boundHandler);\n    clearInterval(this.intervalId);\n  }\n}\n\n// Antipattern: Inline arrow functions in render\nclass BadReactComponent extends React.Component {\n  render() {\n    return (\n      <div>\n        {this.props.items.map(item => (\n          <button \n            key={item.id}\n            onClick={() => this.handleClick(item.id)} // New function each render\n          >\n            {item.name}\n          </button>\n        ))}\n      </div>\n    );\n  }\n  \n  private handleClick(id: string) {\n    console.log(`Clicked ${id}`);\n  }\n}\n\n// Good pattern: Bind in constructor or use useCallback\nclass GoodReactComponent extends React.Component {\n  constructor(props: any) {\n    super(props);\n    this.handleClick = this.handleClick.bind(this);\n  }\n  \n  render() {\n    return (\n      <div>\n        {this.props.items.map(item => (\n          <button \n            key={item.id}\n            onClick={() => this.handleClick(item.id)}\n          >\n            {item.name}\n          </button>\n        ))}\n      </div>\n    );\n  }\n  \n  private handleClick(id: string) {\n    console.log(`Clicked ${id}`);\n  }\n}"
    }
  }
}
