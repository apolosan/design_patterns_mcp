{
  "id": "consistent-core",
  "name": "Consistent Core",
  "category": "Distributed Systems",
  "description": "A pattern ensuring core business logic remains consistent across distributed services",
  "when_to_use": "Microservices architecture, distributed systems, data consistency requirements",
  "benefits": "Data consistency, predictable behavior, easier debugging",
  "drawbacks": "Increased complexity, potential performance overhead",
  "use_cases": "Financial systems, e-commerce, inventory management",
  "complexity": "High",
  "tags": ["distributed-systems", "consistency", "microservices", "data-integrity"],
  "examples": {
    "typescript": {
      "language": "typescript",
      "code": "interface Order {\n  id: string;\n  items: OrderItem[];\n  total: number;\n  status: 'pending' | 'confirmed' | 'shipped' | 'delivered';\n}\n\ninterface OrderItem {\n  productId: string;\n  quantity: number;\n  price: number;\n}\n\nclass ConsistentCore {\n  private eventStore: EventStore;\n  private readModel: ReadModel;\n  \n  constructor(eventStore: EventStore, readModel: ReadModel) {\n    this.eventStore = eventStore;\n    this.readModel = readModel;\n  }\n  \n  async createOrder(items: OrderItem[]): Promise<string> {\n    // Validate business rules\n    this.validateOrder(items);\n    \n    const orderId = generateId();\n    const total = this.calculateTotal(items);\n    \n    // Create order in consistent core\n    const order: Order = {\n      id: orderId,\n      items,\n      total,\n      status: 'pending'\n    };\n    \n    // Store as single transaction\n    await this.eventStore.appendEvents(orderId, [\n      { type: 'OrderCreated', data: order }\n    ]);\n    \n    // Update read model\n    await this.readModel.updateOrder(order);\n    \n    return orderId;\n  }\n  \n  async confirmOrder(orderId: string): Promise<void> {\n    const order = await this.readModel.getOrder(orderId);\n    if (!order) throw new Error('Order not found');\n    if (order.status !== 'pending') throw new Error('Order cannot be confirmed');\n    \n    // Business rule: check inventory\n    for (const item of order.items) {\n      const available = await this.checkInventory(item.productId);\n      if (available < item.quantity) {\n        throw new Error(`Insufficient inventory for ${item.productId}`);\n      }\n    }\n    \n    // Reserve inventory atomically\n    await this.reserveInventory(order.items);\n    \n    // Update order status\n    const updatedOrder = { ...order, status: 'confirmed' as const };\n    await this.eventStore.appendEvents(orderId, [\n      { type: 'OrderConfirmed', data: { orderId, timestamp: Date.now() } }\n    ]);\n    await this.readModel.updateOrder(updatedOrder);\n  }\n  \n  private validateOrder(items: OrderItem[]): void {\n    if (items.length === 0) throw new Error('Order must have at least one item');\n    for (const item of items) {\n      if (item.quantity <= 0) throw new Error('Item quantity must be positive');\n      if (item.price < 0) throw new Error('Item price cannot be negative');\n    }\n  }\n  \n  private calculateTotal(items: OrderItem[]): number {\n    return items.reduce((total, item) => total + (item.price * item.quantity), 0);\n  }\n  \n  private async checkInventory(productId: string): Promise<number> {\n    // Implementation would check inventory service\n    return 100; // Mock\n  }\n  \n  private async reserveInventory(items: OrderItem[]): Promise<void> {\n    // Implementation would call inventory service\n    // This ensures consistency between order and inventory\n  }\n}\n\n// Event Sourcing for consistency\ninterface Event {\n  type: string;\n  data: any;\n  timestamp: number;\n}\n\nclass EventStore {\n  async appendEvents(aggregateId: string, events: Event[]): Promise<void> {\n    // Store events atomically\n    // This ensures the core business logic is captured consistently\n  }\n  \n  async getEvents(aggregateId: string): Promise<Event[]> {\n    // Retrieve events to rebuild state\n    return [];\n  }\n}\n\nclass ReadModel {\n  async getOrder(orderId: string): Promise<Order | null> {\n    // Get current order state\n    return null;\n  }\n  \n  async updateOrder(order: Order): Promise<void> {\n    // Update read model for queries\n  }\n}"
    }
  }
}
