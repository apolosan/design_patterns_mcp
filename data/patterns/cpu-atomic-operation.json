{
  "id": "cpu-atomic-operation",
  "name": "CPU Atomic Operation",
  "category": "Concurrency",
  "description": "CPU architectures support atomic instructions for memory safety",
  "when_to_use": "Lock-free programming\nHigh performance\nMemory consistency\nThread synchronization",
  "benefits": "No locks needed\nBetter performance\nMemory safety\nHardware support",
  "drawbacks": "Platform dependent\nLimited operations\nComplex implementation\nDebugging difficulty",
  "use_cases": "Counters\nFlags\nPointers\nReference counting",
  "complexity": "High",
  "tags": ["concurrency", "atomic", "lock-free", "cpu-instruction", "memory-safety"],
  "examples": {
    "typescript": {
      "language": "typescript",
      "code": "// CPU Atomic Operation Pattern\n// Using atomic CPU instructions for memory safety and performance\n\n// Atomic counter using simulated CPU atomic operations\nclass AtomicCounter {\n  private value: number = 0;\n\n  // Atomic increment (simulated)\n  increment(): number {\n    // In real implementation, this would use CPU atomic instructions\n    // like lock xaddl (x86) or ldrex/strex (ARM)\n    return this.atomicOperation('increment', 1);\n  }\n\n  // Atomic decrement (simulated)\n  decrement(): number {\n    return this.atomicOperation('decrement', 1);\n  }\n\n  // Atomic add (simulated)\n  add(delta: number): number {\n    return this.atomicOperation('add', delta);\n  }\n\n  // Atomic compare and swap (simulated)\n  compareAndSwap(expected: number, newValue: number): boolean {\n    if (this.value === expected) {\n      this.value = newValue;\n      return true;\n    }\n    return false;\n  }\n\n  // Get current value\n  get(): number {\n    return this.value;\n  }\n\n  // Simulate atomic operation (in real implementation, use CPU instructions)\n  private atomicOperation(operation: string, delta: number): number {\n    let attempts = 0;\n    const maxAttempts = 1000;\n\n    while (attempts < maxAttempts) {\n      const current = this.value;\n      let newValue: number;\n\n      switch (operation) {\n        case 'increment':\n          newValue = current + delta;\n          break;\n        case 'decrement':\n          newValue = current - delta;\n          break;\n        case 'add':\n          newValue = current + delta;\n          break;\n        default:\n          throw new Error(`Unknown operation: ${operation}`);\n      }\n\n      // Simulate atomic compare-and-swap\n      if (this.compareAndSwapInternal(current, newValue)) {\n        return newValue;\n      }\n\n      attempts++;\n    }\n\n    throw new Error('Atomic operation failed after max attempts');\n  }\n\n  // Internal compare and swap without locking\n  private compareAndSwapInternal(expected: number, newValue: number): boolean {\n    // Simulate atomic CAS instruction\n    // In real CPU: lock cmpxchg (x86), ldrex/strex (ARM), etc.\n    if (this.value === expected) {\n      this.value = newValue;\n      return true;\n    }\n    return false;\n  }\n}\n\n// Usage example\nfunction demonstrateAtomicOperations() {\n  const counter = new AtomicCounter();\n\n  console.log('Initial value:', counter.get());\n\n  // Multiple operations\n  console.log('Increment 1:', counter.increment());\n  console.log('Increment 2:', counter.increment());\n  console.log('Add 5:', counter.add(5));\n  console.log('Decrement:', counter.decrement());\n\n  console.log('Final value:', counter.get());\n}\n\ndemonstrateAtomicOperations();\n\n// Lock-free stack using atomic operations\nclass LockFreeStack<T> {\n  private head: Node<T> | null = null;\n\n  push(value: T): void {\n    const newNode = new Node(value);\n\n    let attempts = 0;\n    const maxAttempts = 1000;\n\n    while (attempts < maxAttempts) {\n      const currentHead = this.head;\n      newNode.next = currentHead;\n\n      // Atomic compare and swap\n      if (this.compareAndSwapHead(currentHead, newNode)) {\n        console.log(`Pushed: ${value}`);\n        return;\n      }\n\n      attempts++;\n    }\n\n    throw new Error('Push operation failed');\n  }\n\n  pop(): T | null {\n    let attempts = 0;\n    const maxAttempts = 1000;\n\n    while (attempts < maxAttempts) {\n      const currentHead = this.head;\n\n      if (currentHead === null) {\n        return null; // Stack is empty\n      }\n\n      const nextHead = currentHead.next;\n\n      // Atomic compare and swap\n      if (this.compareAndSwapHead(currentHead, nextHead)) {\n        console.log(`Popped: ${currentHead.value}`);\n        return currentHead.value;\n      }\n\n      attempts++;\n    }\n\n    throw new Error('Pop operation failed');\n  }\n\n  private compareAndSwapHead(expected: Node<T> | null, newValue: Node<T> | null): boolean {\n    // Simulate atomic CAS on head pointer\n    if (this.head === expected) {\n      this.head = newValue;\n      return true;\n    }\n    return false;\n  }\n\n  isEmpty(): boolean {\n    return this.head === null;\n  }\n}\n\nclass Node<T> {\n  constructor(public value: T, public next: Node<T> | null = null) {}\n}\n\n// Demonstrate lock-free stack\nfunction demonstrateLockFreeStack() {\n  const stack = new LockFreeStack<number>();\n\n  console.log('Stack empty:', stack.isEmpty());\n\n  stack.push(1);\n  stack.push(2);\n  stack.push(3);\n\n  console.log('Pop:', stack.pop());\n  console.log('Pop:', stack.pop());\n  console.log('Pop:', stack.pop());\n  console.log('Pop empty stack:', stack.pop());\n}\n\ndemonstrateLockFreeStack();"
    }
  }
}
