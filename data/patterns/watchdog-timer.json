{
  "id": "watchdog-timer",
  "name": "Watchdog Timer",
  "category": "Embedded Systems",
  "description": "Hardware timer that resets the system if not periodically serviced, ensuring system reliability and preventing hangs in embedded applications",
  "when_to_use": "Mission-critical embedded systems\nSystems with real-time requirements\nApplications running without supervision\nSystems exposed to harsh environments\nWhen software reliability is paramount",
  "benefits": "Automatic recovery from software faults\nIncreased system reliability\nPrevents infinite loops and deadlocks\nLow overhead implementation\nHardware-based reliability",
  "drawbacks": "Can cause unnecessary resets\nRequires careful timeout selection\nDebugging can be challenging\nMay mask underlying issues\nPower consumption considerations",
  "use_cases": "Industrial control systems\nMedical devices\nAutomotive electronics\nAerospace systems\nIoT devices\nRemote monitoring systems",
  "complexity": "Low",
  "tags": ["embedded", "reliability", "hardware", "fault-tolerance", "system-monitoring", "reset"],
  "examples": {
    "c": {
      "language": "c",
      "code": "// Watchdog Timer Interface\nvoid watchdog_init(uint32_t timeout_ms) {\n    // Configure watchdog timer with specified timeout\n    WDT->LOAD = (SystemCoreClock / 1000) * timeout_ms;\n    WDT->CTRL = WDT_CTRL_ENABLE;\n}\n\nvoid watchdog_feed(void) {\n    // Reset the watchdog timer\n    WDT->FEED = WDT_FEED_SEQUENCE1;\n    WDT->FEED = WDT_FEED_SEQUENCE2;\n}\n\nvoid watchdog_disable(void) {\n    // Disable watchdog (use with caution)\n    WDT->CTRL &= ~WDT_CTRL_ENABLE;\n}\n\n// Application watchdog service\nvoid watchdog_service(void) {\n    static uint32_t last_feed_time = 0;\n    uint32_t current_time = get_system_time_ms();\n    \n    // Feed watchdog every 100ms if system is healthy\n    if (current_time - last_feed_time >= 100) {\n        if (system_is_healthy()) {\n            watchdog_feed();\n            last_feed_time = current_time;\n        }\n    }\n}\n\nbool system_is_healthy(void) {\n    // Check critical system components\n    return (\n        uart_is_responsive() &&\n        sensors_are_reading() &&\n        memory_is_accessible() &&\n        !critical_error_flag\n    );\n}\n\n// Main application loop\nint main(void) {\n    system_init();\n    watchdog_init(500); // 500ms timeout\n    \n    while (1) {\n        process_inputs();\n        update_outputs();\n        watchdog_service(); // Must be called regularly\n        \n        // If this loop hangs or watchdog_service isn't called,\n        // the system will automatically reset\n    }\n}\n\n// Watchdog interrupt handler (if available)\nvoid WDT_IRQHandler(void) {\n    // System is about to reset due to watchdog timeout\n    // Perform emergency cleanup if possible\n    emergency_save_state();\n    \n    // Clear interrupt flag\n    WDT->INTCLR = 1;\n}"
    },
    "typescript": {
      "language": "typescript",
      "code": "// Software watchdog implementation for systems without hardware watchdog\nclass WatchdogTimer {\n    private timeoutId: NodeJS.Timeout | null = null;\n    private lastFeedTime: number = Date.now();\n    private readonly timeoutMs: number;\n    private onTimeout: () => void;\n    \n    constructor(timeoutMs: number, onTimeout: () => void) {\n        this.timeoutMs = timeoutMs;\n        this.onTimeout = onTimeout;\n        this.start();\n    }\n    \n    private start(): void {\n        this.timeoutId = setInterval(() => {\n            const now = Date.now();\n            if (now - this.lastFeedTime >= this.timeoutMs) {\n                console.error('Watchdog timeout - system reset');\n                this.onTimeout();\n            }\n        }, 100); // Check every 100ms\n    }\n    \n    feed(): void {\n        this.lastFeedTime = Date.now();\n    }\n    \n    dispose(): void {\n        if (this.timeoutId) {\n            clearInterval(this.timeoutId);\n            this.timeoutId = null;\n        }\n    }\n}\n\n// System health monitor\nclass SystemHealthMonitor {\n    private watchdog: WatchdogTimer;\n    private errorCount: number = 0;\n    private maxErrors: number = 5;\n    \n    constructor() {\n        this.watchdog = new WatchdogTimer(2000, () => this.handleTimeout());\n    }\n    \n    checkHealth(): void {\n        try {\n            // Perform health checks\n            if (this.checkMemoryUsage() && \n                this.checkNetworkConnectivity() && \n                this.checkDatabaseConnection()) {\n                \n                this.errorCount = 0;\n                this.watchdog.feed(); // System is healthy\n                \n            } else {\n                this.errorCount++;\n                if (this.errorCount >= this.maxErrors) {\n                    console.error('Too many health check failures');\n                    this.triggerReset();\n                }\n            }\n            \n        } catch (error) {\n            console.error('Health check failed:', error);\n            this.errorCount++;\n        }\n    }\n    \n    private checkMemoryUsage(): boolean {\n        // Check if memory usage is within limits\n        return process.memoryUsage().heapUsed < 100 * 1024 * 1024; // 100MB\n    }\n    \n    private checkNetworkConnectivity(): boolean {\n        // Check network connectivity\n        return true; // Simplified\n    }\n    \n    private checkDatabaseConnection(): boolean {\n        // Check database connection\n        return true; // Simplified\n    }\n    \n    private handleTimeout(): void {\n        console.error('Watchdog timeout - initiating system reset');\n        this.triggerReset();\n    }\n    \n    private triggerReset(): void {\n        // Perform emergency cleanup\n        this.saveCriticalState();\n        \n        // Reset the system\n        process.exit(1); // In a real embedded system, this would trigger hardware reset\n    }\n    \n    private saveCriticalState(): void {\n        console.log('Saving critical system state...');\n        // Save important state to persistent storage\n    }\n    \n    dispose(): void {\n        this.watchdog.dispose();\n    }\n}\n\n// Usage\nconst healthMonitor = new SystemHealthMonitor();\n\n// Main application loop\nsetInterval(() => {\n    healthMonitor.checkHealth();\n    // Perform normal operations\n}, 500);\n\n// Cleanup on exit\nprocess.on('exit', () => {\n    healthMonitor.dispose();\n});"
    }
  }
}
