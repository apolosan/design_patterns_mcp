{
  "id": "hierarchical-edge",
  "name": "Hierarchical Edge Pattern",
  "category": "Edge Computing",
  "description": "Organizes edge devices in multiple layers for optimized processing and data flow",
  "when_to_use": "Large-scale IoT deployments\nSmart cities\nIndustrial IoT\nMulti-site deployments",
  "benefits": "Scalability\nEfficient data flow\nResource optimization\nFault isolation",
  "drawbacks": "Architecture complexity\nSynchronization challenges\nManagement overhead\nCost",
  "use_cases": "Smart city infrastructure\nIndustrial automation\nRegional IoT networks\nMulti-tier processing",
  "complexity": "High",
  "tags": [
    "edge",
    "hierarchical",
    "multi-layer",
    "orchestration"
  ],
  "examples": {
    "typescript": {
      "language": "typescript",
      "code": "// Hierarchical Edge: multi-layer edge architecture\n\ninterface EdgeLayer {\n  level: number;\n  name: string;\n  nodes: EdgeNode[];\n  computeCapacity: number;\n  storageCapacity: number;\n  latencyBudget: number;\n}\n\ninterface LayerConfig {\n  levels: number;\n  nodesPerLayer: Map<number, number>;\n  computeAllocation: Map<number, number>;\n  dataRetentionMs: Map<number, number>;\n}\n\nclass HierarchicalEdgeOrchestrator {\n  private layers: Map<number, EdgeLayer> = new Map();\n  private config: LayerConfig;\n  private dataRouter: DataRouter;\n  private cacheHierarchy: CacheHierarchy;\n\n  constructor(config: Partial<LayerConfig> = {}) {\n    this.config = {\n      levels: config.levels ?? 3,\n      nodesPerLayer: config.nodesPerLayer ?? new Map([\n        [1, 1000],\n        [2, 100],\n        [3, 10]\n      ]),\n      computeAllocation: config.computeAllocation ?? new Map([\n        [1, 1],\n        [2, 8],\n        [3, 32]\n      ]),\n      dataRetentionMs: config.dataRetentionMs ?? new Map([\n        [1, 3600000],\n        [2, 86400000],\n        [3, 604800000]\n      ]),\n      ...config\n    };\n\n    this.dataRouter = new DataRouter();\n    this.cacheHierarchy = new CacheHierarchy();\n    this.initializeLayers();\n  }\n\n  private initializeLayers(): void {\n    for (let level = 1; level <= this.config.levels; level++) {\n      const layer: EdgeLayer = {\n        level,\n        name: this.getLayerName(level),\n        nodes: this.createNodesForLevel(level),\n        computeCapacity: this.config.computeAllocation.get(level)! * this.config.nodesPerLayer.get(level)!,\n        storageCapacity: this.config.dataRetentionMs.get(level)!,\n        latencyBudget: this.calculateLatencyBudget(level)\n      };\n\n      this.layers.set(level, layer);\n    }\n  }\n\n  async processData(data: EdgeData): Promise<ProcessingResult> {\n    const optimalLayer = await this.determineOptimalLayer(data);\n    const layer = this.layers.get(optimalLayer);\n\n    if (!layer) {\n      throw new Error(`Layer ${optimalLayer} not found`);\n    }\n\n    const suitableNode = await this.findSuitableNode(layer, data);\n    if (!suitableNode) {\n      return this.offloadToUpperLayer(data, layer.level);\n    }\n\n    const result = await this.processOnNode(suitableNode, data);\n    await this.cacheHierarchy.cache(data.key, result, optimalLayer);\n\n    return {\n      ...result,\n      processedAt: new Date(),\n      layer: optimalLayer,\n      node: suitableNode.id\n    };\n  }\n\n  private async determineOptimalLayer(data: EdgeData): Promise<number> {\n    const latency = data.requirements?.maxLatency || 1000;\n    const criticality = data.requirements?.criticality || \"normal\";\n\n    for (let level = 1; level <= this.config.levels; level++) {\n      const layer = this.layers.get(level)!;\n      if (layer.latencyBudget >= latency) {\n        return level;\n      }\n    }\n\n    return this.config.levels;\n  }\n\n  private async findSuitableNode(layer: EdgeLayer, data: EdgeData): Promise<EdgeNode | null> {\n    const availableNodes = layer.nodes.filter(n => n.status === \"online\");\n    if (availableNodes.length === 0) return null;\n\n    const sorted = availableNodes.sort((a, b) =>\n      this.calculateNodeScore(a, data) - this.calculateNodeScore(b, data)\n    );\n\n    return sorted[0];\n  }\n\n  private calculateNodeScore(node: EdgeNode, data: EdgeData): number {\n    return node.load * 0.5 + node.latency * 0.3 + (1 - node.capacity.utilization) * 0.2;\n  }\n\n  private async processOnNode(node: EdgeNode, data: EdgeData): Promise<any> {\n    return { result: \"processed\", node: node.id };\n  }\n\n  private async offloadToUpperLayer(data: EdgeData, currentLevel: number): Promise<ProcessingResult> {\n    if (currentLevel >= this.config.levels) {\n      throw new Error(\"No available layer for processing\");\n    }\n\n    const upperLevel = currentLevel + 1;\n    const upperLayer = this.layers.get(upperLevel)!;\n    const node = await this.findSuitableNode(upperLayer, data);\n\n    if (!node) {\n      throw new Error(`No node available at layer ${upperLevel}`);\n    }\n\n    return this.processOnNode(node, data);\n  }\n\n  async routeData(data: EdgeData): Promise<RoutingDecision> {\n    return this.dataRouter.route(data, this.layers);\n  }\n\n  async syncLayers(): Promise<void> {\n    for (const [level, layer] of this.layers) {\n      if (level < this.config.levels) {\n        await this.syncToUpperLayer(layer);\n      }\n    }\n  }\n\n  private async syncToUpperLayer(layer: EdgeLayer): Promise<void> {\n    const upperLevel = layer.level + 1;\n    const upperLayer = this.layers.get(upperLevel);\n    if (!upperLayer) return;\n\n    const dataToSync = await this.collectDataForSync(layer);\n    await upperLayer.nodes[0].receiveSync(dataToSync);\n  }\n\n  private async collectDataForSync(layer: EdgeLayer): Promise<any[]> {\n    return [];\n  }\n\n  private createNodesForLevel(level: number): EdgeNode[] {\n    const count = this.config.nodesPerLayer.get(level)!;\n    return Array.from({ length: count }, (_, i) => ({\n      id: `node-${level}-${i}`,\n      level,\n      status: \"online\",\n      load: Math.random(),\n      latency: Math.random() * 10,\n      capacity: { utilization: Math.random(), total: 100 }\n    }));\n  }\n\n  private getLayerName(level: number): string {\n    const names: Record<number, string> = {\n      1: \"Device Edge\",\n      2: \"Gateway Edge\",\n      3: \"Regional Edge\"\n    };\n    return names[level] || `Edge Level ${level}`;\n  }\n\n  private calculateLatencyBudget(level: number): number {\n    const baseLatency = [100, 500, 2000];\n    return baseLatency[level - 1] || 5000;\n  }\n\n  getLayerStatus(): LayerStatus[] {\n    return Array.from(this.layers.values()).map(layer => ({\n      level: layer.level,\n      name: layer.name,\n      nodesOnline: layer.nodes.filter(n => n.status === \"online\").length,\n      nodesTotal: layer.nodes.length,\n      computeCapacity: layer.computeCapacity,\n      latencyBudget: layer.latencyBudget\n    }));\n  }\n}\n\ninterface EdgeData {\n  key: string;\n  payload: any;\n  requirements?: {\n    maxLatency: number;\n    criticality: string;\n  };\n}\n\ninterface EdgeNode {\n  id: string;\n  level: number;\n  status: \"online\" | \"offline\";\n  load: number;\n  latency: number;\n  capacity: { utilization: number; total: number };\n  receiveSync(data: any[]): Promise<void>;\n}\n\ninterface ProcessingResult {\n  result: any;\n  processedAt: Date;\n  layer: number;\n  node: string;\n}\n\ninterface RoutingDecision {\n  targetLayer: number;\n  reason: string;\n  estimatedLatency: number;\n}\n\ninterface LayerStatus {\n  level: number;\n  name: string;\n  nodesOnline: number;\n  nodesTotal: number;\n  computeCapacity: number;\n  latencyBudget: number;\n}\n\nclass DataRouter {\n  async route(data: EdgeData, layers: Map<number, EdgeLayer>): Promise<RoutingDecision> {\n    return {\n      targetLayer: 1,\n      reason: \"Optimal for latency requirements\",\n      estimatedLatency: 50\n    };\n  }\n}\n\nclass CacheHierarchy {\n  async cache(key: string, data: any, layer: number): Promise<void> {}\n}"
    }
  },
  "relationships": [
    {
      "target_pattern_id": "edge-processing",
      "type": "contains",
      "description": "Hierarchical edge contains multiple edge processing layers"
    },
    {
      "target_pattern_id": "stream-bridging",
      "type": "uses",
      "description": "Hierarchical edge uses stream bridging between layers"
    }
  ]
}
